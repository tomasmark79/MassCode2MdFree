{
  "folders": [
    {
      "name": "C/C++",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "c_cpp",
      "id": "3vpCAP33",
      "createdAt": 1710278299115,
      "updatedAt": 1711618663086,
      "index": 0
    },
    {
      "name": "RevidedC++",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "c_cpp",
      "id": "h_XqOL4T",
      "createdAt": 1711970084961,
      "updatedAt": 1711970279357,
      "index": 1
    },
    {
      "name": "VSCode",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "json",
      "id": "u6rnxgPx",
      "createdAt": 1711613794649,
      "updatedAt": 1711613813693,
      "index": 2
    },
    {
      "name": "PShell",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "powershell",
      "id": "0RzxMo7F",
      "createdAt": 1710279713029,
      "updatedAt": 1710705084311,
      "index": 3
    },
    {
      "name": "Bash",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "sh",
      "id": "ahtjgpcH",
      "createdAt": 1710705433634,
      "updatedAt": 1711300456666,
      "index": 4
    },
    {
      "name": "Fráze",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "plain_text",
      "id": "TRNwKjeZ",
      "createdAt": 1712296133386,
      "updatedAt": 1712296142274,
      "index": 5
    },
    {
      "name": "MySQL",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "mysql",
      "id": "3a0scZOU",
      "createdAt": 1712516833367,
      "updatedAt": 1712516855289,
      "index": 6
    }
  ],
  "snippets": [
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Odstran licha cisla",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n// Odstraní všechna lichá čísla\nnumbers.erase(remove_if(numbers.begin(), numbers.end(), [](int number) {\n    return number % 2 != 0;\n}), numbers.end());\n"
        }
      ],
      "id": "XCgsQek2",
      "createdAt": 1710250177146,
      "updatedAt": 1710704974413
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "cout vertical centered multiline string in console",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "void Graphic::coutVerticalCenteredMultilineString(int startAtRow, string multilineString) const\n{\n    std::istringstream iss(multilineString);\n    string line;\n    while (std::getline(iss, line))\n    {\n        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), COORD\n        { (short)( (totalW / 2) - (line.length() / 2) ), static_cast<short>(startAtRow++) } );\n        cout << line << endl;\n    }\n}"
        }
      ],
      "id": "i4LDqiQy",
      "createdAt": 1710250540222,
      "updatedAt": 1710704996016
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Console cursor position",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), COORD{ 0,0 });"
        }
      ],
      "id": "xH8EUOPw",
      "createdAt": 1710250977857,
      "updatedAt": 1710704996449
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Press enter to continue",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');"
        }
      ],
      "id": "odARiw-x",
      "createdAt": 1710251239805,
      "updatedAt": 1710704996478
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "smart pointers",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::shared_ptr <Field> field;\nfield(std::make_shared    <Field>   (width, height)),\n\nstd::unique_ptr <Fruit> fruit;\nfruit(std::make_unique    <Fruit>   (fruitEmptiness, width, height)),\n\n// Graphic graphic\nstd::unique_ptr <Graphic> graphic;\ngraphic(std::make_unique  <Graphic> (width, height)),\n\n// Player ** players\nstd::unique_ptr <unique_ptr<Player>[]> players;\nplayers(std::make_unique  <unique_ptr <Player> []> (totalPlayers + 1)),\n\n// Snake ** snakes\nsnakes(std::make_unique   <shared_ptr <Snake>  []> (totalPlayers + 1)),\nstd::unique_ptr <shared_ptr<Snake> []> snakes;"
        }
      ],
      "id": "gmcUoI1l",
      "createdAt": 1710251333682,
      "updatedAt": 1710704987833
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": "z webu itnetwork",
      "name": "Agregace",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "// Řešení přes metody kolekcí:\n\nvector<int> numbers = {5, 10, 15, 3, 9, 4, 2};\n\nvector<int> result = accumulate(\n    numbers.begin(),\n    numbers.end(),\n    vector<int>(),\n    [](vector<int> output, int current) -> vector<int> {\n        if (!output.empty() && output.back() != 0 && current % output.back() == 0) {\n            output.push_back(current + 1);\n        } else {\n            output.push_back(current);\n        }\n        return output;\n    });\n\n\n// Řešení přes cyklus:\n\nvector<int> numbers = { 5, 10, 15, 3, 9, 4, 2 };\nint previousNumber = numbers.front();\n\nfor (size_t i = 1; i < numbers.size(); i++) {\n    if (previousNumber != 0 && numbers[i] % previousNumber == 0) {\n        numbers[i]++;\n    }\n    previousNumber = numbers[i];\n}\n\n"
        },
        {
          "label": "Fragment 2",
          "language": "plain_text",
          "value": ""
        }
      ],
      "id": "9CAOUzZI",
      "createdAt": 1710251725190,
      "updatedAt": 1710704974061
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "cout vector of strings elements in for each",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "vector<string> names = {\"Anna\", \"Petr\", \"Jan\", \"Lucie\"};\n\nfor(const string& name : names) {\n    cout << name << endl;\n}"
        }
      ],
      "id": "CKyqW3OF",
      "createdAt": 1710252050842,
      "updatedAt": 1710704996511
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "přítomnost bodu v obdélníku",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "if (mouse.x >= button.x && mouse.x < button.x + button.width && mouse.y >= button.y && mouse.y < button.y + button.height)\n     clicked = true;"
        }
      ],
      "id": "KYULhcim",
      "createdAt": 1710252308239,
      "updatedAt": 1710705024188
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "map<int, string> definition",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "const map<int, string> deadDescription\n    {\n        {0, \"is living\"}, {1, \"wall\"}, {2, \"self\"}, {3, \"another Snake\"}\n    };\n    \nMap<String, String> seznamPsc = Map.of(\n    \"Praha 1\", \"10000\",\n    \"Praha 10\", \"11000\",\n    ...\n    ...\n    ...\n);"
        }
      ],
      "id": "pwjEnDNZ",
      "createdAt": 1710252592501,
      "updatedAt": 1710917145174
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "cout colors to console",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "void print_colors()\n{\n    int bg, fg;\n    for( fg = 0; fg <  8; fg += 1 ) aput(\"    \", fg, 0);\n    cout << endl;\n    for( fg = 8; fg < 16; fg += 1 ) aput(\"    \", fg, 0);\n    cout << endl;\n    cout << endl;\n    for( bg = 0; bg < 16; bg += 1 )\n    {\n        for( fg = 0; fg < 16; fg += 1 )\n        {\n            aput( \"10\", bg, fg );\n        }\n        cout << endl;\n    }\n}\n\nvoid aput( char* c, char bg_col, char fg_col )\n{\n    int bg, fg;\n    if( bg_col > 7 ) bg = 100 + bg_col-8;\n    else             bg =  40 + bg_col;\n    if( fg_col > 7 ) fg =  90 + fg_col-8;\n    else             fg =  30 + fg_col;\n    printf( \"\\033[%i;%im%s\\033[0;0m\", fg, bg, c );\n}"
        }
      ],
      "id": "LafeofGy",
      "createdAt": 1710253373528,
      "updatedAt": 1710704996432
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Cp1250 to Cp852 CZ ceska konzole console",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const unsigned char tranform_table_for_cz[]\n{\n    129, 130, 131, 132, 133, 134, 135, 136, 137, 230, 139, 140,\n    155, 166, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152,\n    153, 231, 155, 156, 156, 167, 159, 160, 161, 162, 163, 164,\n    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,\n    177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 149,\n    189, 150, 191, 232, 181, 194, 195, 142, 145, 198, 199, 172,\n    144, 202, 203, 183, 214, 206, 210, 208, 209, 213, 224, 226,\n    213, 214, 215, 252, 222, 233, 219, 220, 237, 222, 223, 234,\n    160, 226, 227, 132, 146, 230, 231, 159, 130, 234, 235, 216,\n    161, 238, 212, 240, 241, 229, 162, 147, 245, 246, 247, 253,\n    133, 163, 251, 252, 236, 254, 255\n};\n\nchar c_Cp1250_to_Cp852(unsigned char c)\n{\n    if (c < 128)\n        return c;\n    else\n        return tranform_table_for_cz[c - 129];\n}\n\nstring char_Cp1250_to_string_Cp852(const char* charCp1250)\n{\n    string result;\n    for (const char *p = charCp1250; *p; p++)\n        result += c_Cp1250_to_Cp852(*p);\n    return result;\n}\n\nstring string_Cp1250_to_string_Cp852(string textCp1250)\n{\n    string result(textCp1250.size(), ' ');\n    transform(textCp1250.begin(), textCp1250.end(), // <algoritmh>\n              result.begin(), c_Cp1250_to_Cp852);\n    return result;\n}\n\nint main()\n{\n    // system(\"CHCP 852 > NUL\");\n\n    string textCp1250 = \"přílišžluťoučkýkůňúpělďábelskéódy\";\n        cout << textCp1250 << endl;\n    string textCp852;\n    textCp852 = string_Cp1250_to_string_Cp852(textCp1250);\n    cout << textCp852 << endl;\n\n    const char *charCp1250 = \"přílišžluťoučkýkůňúpělďábelskéódy\";\n        cout << charCp1250 << endl;\n    string charCp852;\n    charCp852 = char_Cp1250_to_string_Cp852(charCp1250);\n    cout << charCp852 << endl;\n\n}\n"
        }
      ],
      "id": "4nwafshy",
      "createdAt": 1710253865663,
      "updatedAt": 1710704996354
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Random",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <random>\n\nint main() {\n    std::random_device rd;  // Seed pro generátor náhodných čísel\n    std::mt19937 gen(rd()); // Mersenne Twister engine - algoritmus pro generování náhodných čísel\n    std::uniform_int_distribution<> dis(1, 50); // Rozsah náhodných čísel\n\n    int randomNumber = dis(gen); // Generování náhodného čísla v rozsahu <1, 50>\n\n    std::cout << \"Nahodne cislo od 1 do 50: \" << randomNumber << std::endl;\n\n    return 0;\n}\n"
        }
      ],
      "id": "xx_6F0Nz",
      "createdAt": 1710257353300,
      "updatedAt": 1711950079356
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "get Numeric Answer From Player template",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "template<typename T1>\nT1 getNumericAnswerFromPlayer(std::string_view question, int min, int max, int attemptTreshold)\n{\n    T1 value = 0;\n    int totalAnswers = 0;\n    do\n    {\n        if (totalAnswers == attemptTreshold)\n        {\n            std::cout << userfailed;\n            throw std::runtime_error(\"User failed to provide valid input.\");\n        }\n        std::cout << question;\n        std::cin >> value;\n        std::cin.clear();\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n        totalAnswers++;\n    }\n    while(value < min || value > max);\n    return value;\n}"
        }
      ],
      "id": "fEJaxVij",
      "createdAt": 1710257532890,
      "updatedAt": 1710704996401
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "get String Answer From Player",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::string getStringAnswerFromPlayer(std::string_view question, int min, int max, int attemptTreshold)\n{\n    std::string answer = \"\";\n    int totalAnswers = 0;\n    do\n    {\n        if (totalAnswers == attemptTreshold)\n        {\n            std::cout << userfailed;\n            throw std::runtime_error(\"User failed to provide valid input.\");\n        }\n        std::cout << question;\n        std::cin >> answer;\n        std::cin.clear();\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n        totalAnswers++;\n    }\n    while(static_cast<int>(answer.length()) < min || static_cast<int>(answer.length()) > max);\n    return answer;\n}"
        }
      ],
      "id": "SgcztUJ7",
      "createdAt": 1710257559009,
      "updatedAt": 1710704996371
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "shorten string - zkrátit řetězec",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\nstd::string zkrat_text(std::string text, int nova_delka)\n{\n\n    if (text.length() <= nova_delka || nova_delka == 0)\n        return text;\n\n    std::string strtemp = text.substr(0, nova_delka - 3) + \"...\";\n    return strtemp;\n}\n\nint main()\n{\n    std::string text_na_zkr=\"\";\n    int nova_delka=0;\n\n    std::cout << \"Zadejte text na zkraceni: \";\n    getline(cin, text_na_zkr);\n\n    std::cout << \"Zadejte novou delku textu: \";\n    std::cin >> nova_delka;\n\n    std::string zkraceny_text = zkrat_text(text_na_zkr, nova_delka);\n    std::cout << \"Text po zkraceni: \" << zkraceny_text << std::endl;\n\n    return 0;\n}\n\n#include <string>\n#include <iostream>\nusing namespace std;\n\n\n// drha varianta\nstring zkrat_text( string text, int nova_delka )\n{\n\tint skutecna_delka = text.length();\n\tif( skutecna_delka > nova_delka )\n\t{\n\t\t//musime zkratit\n\t\ttext.erase(nova_delka-3,skutecna_delka-nova_delka+3);\n\t\tfor(int i = 0; i < 3; i++ )\n\t\t\ttext = text + '.';\n\t}\n\treturn text;\n}\n\nint main()\n{\n\n\tstring text;\n\tint pozadovana_delka;\n\n\tcout << \"Zadejte text na zkraceni: \";\n\tgetline(cin, text);\n\tcout << \"Zadejte novou delku textu: \";\n\tcin >> pozadovana_delka;\n\n\tstring novy_text = zkrat_text( text, pozadovana_delka );\n\n\tcout << \"Text po zkraceni: \" << novy_text << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}\n"
        }
      ],
      "id": "TMxteK-f",
      "createdAt": 1710264918990,
      "updatedAt": 1710704981217
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Zadávání slov dokola",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint main()\n{\n    std::string vstup;\n    set<string> seznam;\n    while ( vstup != \"konec\" )\n    {\n        cin >> vstup;\n        seznam.insert(vstup);\n    }\n    cout << \"Celkem slov: \" << seznam.size() - 1;\nreturn 0;\n}\n"
        }
      ],
      "id": "pXvB1Zj4",
      "createdAt": 1710265090099,
      "updatedAt": 1710704996323
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Vigenerova šifra",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\n// Vigenerova šifra\nint main()\n{\n    string zprava_k_zasifrovani = \"moribundus\";\n    cout << \"Zadejte text k zasifrovani: \";\n    cin >> zprava_k_zasifrovani;\n    // cout << endl;\n\n    string heslo = \"ahoj\";\n    cout << \"Zadejte heslo: \";\n    cin >> heslo;\n    // cout << endl;\n\n    string sifra = \"\";\n    char znak_sifry = 0;\n    char znak_zpravy = 0;\n\n    string abeceda = \"abcdefghijklmnopqrstuvwxyz\";\n\n    for (\n    int index_zpravy = 0, index_hesla = 0;\n    index_zpravy < zprava_k_zasifrovani.length();\n    index_zpravy++, index_hesla++)\n    {\n        if (index_hesla == heslo.length()) index_hesla = 0;\n        znak_sifry = abeceda.find(heslo[index_hesla]+1);\n        znak_zpravy = zprava_k_zasifrovani[index_zpravy];\n\n        // přetečení adresy\n        if ( ((int)znak_sifry + (int)znak_zpravy) > 122 /* z */)\n            znak_zpravy -= abeceda.length();\n\n        sifra += znak_sifry + znak_zpravy;\n    // cout << (int)znak_sifry << \" + \" << (char)znak_zpravy << \" = \" << (int)znak_sifry + (int)znak_zpravy << endl;\n    // cout << (int)znak_sifry << \" + \" << (char)znak_zpravy << \" = \" << (char)((int)znak_sifry + (int)znak_zpravy) << endl;\n\n    }\n\n    cout << sifra;\n    return 0;\n}\n"
        }
      ],
      "id": "YI7LCF83",
      "createdAt": 1710265137596,
      "updatedAt": 1710704981236
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Tab as ostream",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include \"Tab.h\"\nchar Tab::tab = '\\t';\nclass Tab\n{\npublic:\n    static char tab;\n};\n\n#include <iostream>\n#include \"Tab.h\"\nusing namespace std;\n\nint main()\n{\n    cout\n    << \"Zacatek\"\n    << Tab::tab << Tab::tab\n    << \"a konec textu\"\n    << endl;\n\n    return 0;\n}\n\n// itnetwork priklad\n\n\n#ifndef __TAB__H_\n#define __TAB_H_\n#include <iostream>\n\nclass Tab\n{\npublic:\n\tstatic const Tab tab;\nprivate:\n\tTab();\n\tTab(const Tab&) = delete;\n};\n\nstd::ostream& operator<<(std::ostream& str,const Tab &tab);\n\n#endif\n\n#include \"Tab.h\"\n\nconst Tab Tab::tab;\n\nTab::Tab()\n{\n}\n\nstd::ostream & operator<<(std::ostream & str, const Tab &tab)\n{\n\treturn str << \"\\t\";\n}\n\n#include <iostream>\n#include \"Tab.h\"\n\nusing namespace std;\n\n\nint main()\n{\n\tcout << \"Zacatek\" << Tab::tab << Tab::tab << \"a konec textu\" << endl;\n\n\tcin.get();\n\treturn 0;\n}"
        }
      ],
      "id": "s-GyPJkS",
      "createdAt": 1710265196254,
      "updatedAt": 1710704996154
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Kolik si date ryb k veceri?",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "int main()\n{\n\tcout << \"Kolik si date ryb k veceri?\" << endl;\n\tint pocet_ryb;\n\tcin >> pocet_ryb;\n\n\tfor (int i = 0; i < pocet_ryb; i++)\n\t\tcout << \"<* )))-<\" << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
        }
      ],
      "id": "HgRMfZf7",
      "createdAt": 1710265517806,
      "updatedAt": 1710704996293
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Soucet trech nejvetsich prvku",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "int secti_tri_nejvetsi_prvky(int pole[], int delka_pole)\n{\n\tint soucet = 0;\n\n\tsort(pole, pole + delka_pole);\n\tfor (int a = 0; a < 3; a++)\n\t\tsoucet = soucet + pole[delka_pole - 1 - a];\n\n\treturn soucet;\n}\n\nvoid vypsani_pole( int pole[], int delka_pole )\n{\n\tint i;\n\tcout <<  \"Prohledavam pole: \";\n\tfor( i = 0; i < delka_pole; i++ )\n\t\tcout << pole[i] << ' ';\n\tcout << endl;\n}\n\nint main( int argc, char** argv ) {\n\n\tint pole[] = { 1, 5, 9, 12, 16, 14 };\n\n\tvypsani_pole( pole, 6 );\n\tint soucet = secti_tri_nejvetsi_prvky( pole, 6 );\n\tcout << \"Soucet trech nejvetsich prvku: \" << soucet << endl;\n\n\tcin.get();\n\treturn 0;\n}"
        }
      ],
      "id": "wXOPRhw3",
      "createdAt": 1710265661985,
      "updatedAt": 1710704974369
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Kvadraticka rovnice",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "int main() {\n\tcout << \"Zadejte postupne koeficienty a,b,c kvadraticke rovnice ax^2+bx+c=0:\\n\";\n\tdouble a, b, c;\n\tcin >> a;\n\tcin >> b;\n\tcin >> c;\n\n\tif (a != 0)\n\t{\n\t\t// výpočet diskriminantu\n\t\tdouble d = b * b - 4 * a * c;\n\t\tif (d < 0)\n\t\t\tcout << \"Neexistuje reseni v oblasti realnych cisel\" << endl;\n\t\telse if (d == 0)\n\t\t{\n\t\t\tdouble x = -b / (2 * a);\n\t\t\tcout << \"Rovnice ma jeden koren x = \" << x << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble x1 = (-b + sqrt(d)) / (2 * a);\n\t\t\tdouble x2 = (-b - sqrt(d)) / (2 * a);\n\t\t\tcout << \"Rovnice ma 2 realne koreny x1 = \" << x1 << \", x2 = \" << x2 << endl;\n\t\t}\n\t}\n\telse\n\t\tcout << \"Neni kvadraticka rovnice\" << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}\n"
        },
        {
          "label": "Fragment 2",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <math.h>\n#include \"konzola.h\" // Jen Windows\n\nusing namespace std;\n \nconst int realne{ 0 }, komplexni{ 1 }, chybne_zadani{ 3 };\n\nint res_q_rovnici(double koef[], double x[])\n{\n\tif (koef[0] == 0)\n\t{\n\t\treturn chybne_zadani;\n\t}\n\tdouble d = koef[1] * koef[1] - 4 * koef[0] * koef[2];\n\tif (d >= 0)\n\t{\n\t\tx[0] = (-koef[1] + sqrt(d)) / (2 * koef[0]);\n\t\tx[1] = (-koef[1] - sqrt(d)) / (2 * koef[0]);\n\t\treturn realne;\n\t}\n\telse\n\t{\n\t\tx[0] = -koef[1] / (2 * koef[0]);\n\t\tx[1] = sqrt(-d) / (2 * koef[0]);\n\t\treturn komplexni;\n\t}\n}\n\nvoid vypis_reseni(int priznak, double koef[], double koreny[])\n{\n\tcout << \"�e�en� kvadratick� rovnice \"\n\t\t<< koef[0] << \"x^2 + \" << koef[1] << \"x + \" << koef[2] << \" = 0\" << endl;\n\tswitch (priznak)\n\t{\n\tcase realne:\n\t\tcout << \"Re�ln� ko�eny: \";\n\t\tcout << \"x1 = \" << koreny[0] << \", x2 = \" << koreny[1];\n\t\tbreak;\n\tcase komplexni:\n\t\tcout << \"Komplexn� sdru�en� ko�eny: \";\n\t\tcout << \"x1, x2 = \" << koreny[0] << \" \\xB1 i.\" << koreny[1];\n\t\tbreak;\n\tcase chybne_zadani:\n\t\tcout << \"Zad�n� nep�edstavuje kvadratickou rovnici\";\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tnastav_konzolu_pro_cp1250();  // jen Windows\n\tdouble koreny[2];\n\tdouble koeficienty1[3]{ 1,2,1 };\n\tint priznak = res_q_rovnici(koeficienty1, koreny);\n\tvypis_reseni(priznak, koeficienty1, koreny);\n\tdouble koeficienty2[3]{ 1,0,1 };\n\tpriznak = res_q_rovnici(koeficienty2, koreny);\n\tvypis_reseni(priznak, koeficienty2, koreny);\n\tdouble koeficienty3[3]{ 0,1,1 };\n\tpriznak = res_q_rovnici(koeficienty3, koreny);\n\tvypis_reseni(priznak, koeficienty3, koreny);\n}"
        }
      ],
      "id": "aJQQ7ofg",
      "createdAt": 1710265764670,
      "updatedAt": 1710704974135
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Obvod a obsah kruhu",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "int main()\n{\n\tfloat polomer;\n\tcout << \"Zadejte polomer: \";\n\tcin >> polomer;\n\tfloat obvod = 2 * 3.1415 * polomer;\n\tfloat obsah = 3.1415 * polomer * polomer;\n\tcout << \"Obvod kruhu je: \" << obvod << \" cm a jeho obsah je \" << obsah << \" cm2\" << endl;\n\tcin.get(); cin.get();\n\treturn 0;\n}\n"
        }
      ],
      "id": "A1pQKe1a",
      "createdAt": 1710265852746,
      "updatedAt": 1710704974339
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "String as array",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "int main()\n{\n\tstring pozdrav = \"Hello World!\";\n\tpozdrav[0] = 'h';\n\tfor( int a = 0; a < 12; a++ )\n\t\tcout << pozdrav[a] << ' ';\n\tcout << endl;\n\tcin.get();\n\treturn 0;\n}"
        }
      ],
      "id": "UEwEF8nC",
      "createdAt": 1710266015429,
      "updatedAt": 1710704981201
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Zadejte text k zasifrovani",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "int main()\n{\n\tstring text;\n\tstring heslo;\n\t//ziskani vstupu\n\tcout << \"Zadejte text k zasifrovani: \";\n\tcin >> text;\n\tcout << \"Zadejte heslo: \";\n\tcin >> heslo;\n\n\t//secteni a ulozeni do vysledku\n\tfor( int i = 0; i < text.length(); i++ )\n\t\ttext[i] = text[i] + heslo[i%heslo.length()] - 'a' + 1;\n\n\t//zkontrolovani, zda nam nekde pismeno neprekrocilo hranici\n\t//predpokldame pouze a-z, tj. 26 znaku\n\tfor( int i = 0; i < text.length(); i++ )\n\t\tif( text[i] > 'z' || text[i] < 'a' )\n\t\t\ttext[i] = text[i] - 26;\n\n\tcout << text;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
        }
      ],
      "id": "mCxwfeL3",
      "createdAt": 1710266049844,
      "updatedAt": 1710704981171
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Palindrom",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "int main() \n{\n\n\tstring slovo;\n\tcout << \"Zadejte palindrom: \";\n\tcin >> slovo;\n\n\tfor(int i = 0; i <= slovo.length() / 2 ; i++ )\n\t{\n\t\tif( slovo[i] != slovo[slovo.length() - 1 - i] ) //jdeme zleva i zprava\n\t\t{\n\t\t\tcout << \"Nejedna se o palindrom\" << endl;\n\t\t\tcin.get(); cin.get();\n\t\t\treturn 1;\n\t\t}\n\t}\n\tcout << \"Jedna se o palindrom\" << endl;\n\n\n\tcin.get(); cin.get();\n\treturn 0;\n}\n\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n//mnou vypracovane\nint main()\n{\n    cout << \"Zadejte palindrom: \";\n    string zadane_slovo = \"\";\n    cin >> zadane_slovo;\n\n    string zadane_slovo_obracene = \"\";\n    zadane_slovo_obracene = zadane_slovo;\n\n    reverse(zadane_slovo.begin(), zadane_slovo.end());\n\n    if (zadane_slovo_obracene == zadane_slovo)\n    {\n        cout << \"Jedna se o palindrom\" << endl;\n    }\n    else\n    {\n        cout << \"Nejedna se o palindrom\" << endl;\n    }\n\nreturn 0;\n}\n"
        }
      ],
      "id": "ZxeOYiPK",
      "createdAt": 1710266082455,
      "updatedAt": 1710704981080
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "cout char in cycle",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "int main()\n{\n    for( int a = 0; a <= 127; a++ )\n        cout << a << ':' << (char)a << endl;\n    return 0;\n}"
        }
      ],
      "id": "PBV0whIF",
      "createdAt": 1710266192029,
      "updatedAt": 1710704981157
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Trideni pole",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\nusing namespace std;\n\nint main( int argc, char** argv ) {\n\n\tint pole_k_setrideni[10] = { 1,9,8,6,4,7,2,3,5,0 };\n\n\tcout << \"Pole pred setridenim: \";\n\tfor( int i = 0; i < 10; i++ )\n\t\tcout << pole_k_setrideni[i] << ' ';\n\tcout << endl;\n\n\tfor( int i = 0; i < 10; i++ )\n\t\tfor( int j = 1; j<10; j++ )\n\t\t\tif( pole_k_setrideni[j - 1]>pole_k_setrideni[j] )\n\t\t\t{\n\t\t\t\tint meziulozeni = pole_k_setrideni[j];\n\t\t\t\tpole_k_setrideni[j] = pole_k_setrideni[j - 1];\n\t\t\t\tpole_k_setrideni[j - 1] = meziulozeni;\n\t\t\t}\n\n\tcout << \"Pole po setrideni: \";\n\tfor( int i = 0; i < 10; i++ )\n\t\tcout << pole_k_setrideni[i] << ' ';\n\tcout << endl;\n\n\tcin.get();\n\treturn 0;\n}"
        }
      ],
      "id": "wNVTiaf9",
      "createdAt": 1710266262635,
      "updatedAt": 1710705074959
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Miminum Maximum Prumer",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tdouble cisla[10];\n\n\tfor( int i = 0; i < 10; i++ )\n\t{\n\t\tcout << \"Zadejte cislo: \";\n\t\tcin >> cisla[i];\n\t}\n\n\t//pocatecni inicializace, aby byly hodnoty v rozmezi hodnot\n\tint min = cisla[0];\n\tint max = cisla[0];\n\tint sum = 0;\n\n\t//vypocet\n\tfor( int i = 0; i < 10; i++ )\n\t{\n\t\tif( cisla[i] > max )\n\t\t\tmax = cisla[i];\n\t\tif( cisla[i] < min )\n\t\t\tmin = cisla[i];\n\t\tsum = sum + cisla[i];\n\t}\n\n\tcout << \"Minimum=\" << min << endl;\n\tcout << \"Maximum=\" << max << endl;\n\tcout << \"Prumer=\" << sum / 10.0 << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}\n\n   \n    auto it = max_element(cisla.begin(), cisla.end()); // C++11\n    cout << it.base() << endl;\n    cout << *it << endl;\n    cout << \"Max: \" << *max_element(cisla.begin(), cisla.end()) << endl;\n    cout << \"Min: \" << *min_element(cisla.begin(), cisla.end()) << endl;\n    \n\n"
        },
        {
          "label": "Fragment 2",
          "language": "c_cpp",
          "value": "int main()\n{\n    const int polesize {10};\n    double pole[polesize];\n    double suma {0};\n\n    for (int i = 0; i < 10; i++)\n    {\n        cout << \"Zadejte cislo: \";\n        cin >> pole[i];\n        suma+=pole[i];\n        // cout << suma;\n    }\n\n    double *minit = min_element(pole, pole+polesize);\n    double *maxit = max_element(pole, pole+polesize);\n\n    cout << \"Minimum=\" << *minit << endl;\n    cout << \"Maximum=\" << *maxit << endl;\n    cout << \"Prumer=\" << suma/polesize << endl;\n\n    return 0;\n}"
        },
        {
          "label": "Fragment 3",
          "language": "c_cpp",
          "value": "int main()\n{\n    vector<string> msg {\"Hello\", \"C++\", \"World\", \"from\", \"VS Code\", \"and the C++ extension!\"};\n\n    for (const string& word : msg)\n    {\n        cout << word << \" \";\n    }\n    cout << endl;\n\n    vector<int> cisla;\n    for (size_t i = 0; i < 65535/2; i++)\n    {\n        /* code */\n        Number n1(65535);\n        cisla.push_back(n1.getSecretNumber());\n        // cout << n1.getSecretNumber() << endl;\n    }\n   \n    auto it = max_element(cisla.begin(), cisla.end()); // C++11\n    cout << it.base() << endl;\n    cout << *it << endl;\n    cout << \"Max: \" << *max_element(cisla.begin(), cisla.end()) << endl;\n    cout << \"Min: \" << *min_element(cisla.begin(), cisla.end()) << endl;\n\n}"
        }
      ],
      "id": "31bdhfTT",
      "createdAt": 1710266303157,
      "updatedAt": 1711544492231
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Kalkulacka",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <conio.h>\n#include <clocale>\nusing namespace std;\n\nint main(void) {\n\tsetlocale(LC_ALL, \"\");\n\tcout << \"Vítejte v kalkulačce\" << endl;\n\tcout << \"Zadejte první číslo:\" << endl;\n\tfloat a;\n\tcin >> a;\n\tcout << \"Zadejte druhé číslo:\" << endl;\n\tfloat b;\n\tcin >> b;\n\tcout << \"Zvolte si operaci:\" << endl;\n\tcout << \"1 - sčítání\" << endl;\n\tcout << \"2 - odčítání\" << endl;\n\tcout << \"3 - násobení\" << endl;\n\tcout << \"4 - dělení\" << endl;\n\tint volba;\n\tcin >> volba;\n\tfloat vysledek = 0;\n\tswitch (volba) {\n\tcase 1:\n\t\tvysledek = a + b;\n\t\tbreak;\n\tcase 2:\n\t\tvysledek = a - b;\n\t\tbreak;\n\tcase 3:\n\t\tvysledek = a * b;\n\t\tbreak;\n\tcase 4:\n\t\tvysledek = a / b;\n\t\tbreak;\n\t}\n\tif ((volba > 0) && (volba < 5))\n\t\tcout << \"Výsledek:\" << vysledek << endl;\n\telse\n\t\tcout << \"Neplatná volba\" << endl;\n\tcout << \"Děkuji za použití kalkulačky, aplikaci ukončíte libovolnou klávesou.\" << endl;\n\tcin.get();cin.get();\n\treturn 0;\n}"
        }
      ],
      "id": "zfcCsp1L",
      "createdAt": 1710266395937,
      "updatedAt": 1710704996269
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Nasobilka Mocninator",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <conio.h>\nusing namespace std;\n\nint main(void) {\n\n\t/***************\\\n\t|*  násobilka  *|\n\t\\***************/\n\t\n\tsetlocale(LC_ALL, \"\");\n\tcout << \"Malá násobilka pomocí dvou cyklů:\" << endl;\n\tfor (int j = 1; j <= 10; j++) {\n\t\tfor (int i = 1; i <= 10; i++)\n\t\t\tcout << i * j << ' ';\n\t\tcout << endl;\n\t}\n\tcin.get();\n\n\t/****************\\\n\t|*  mocninátor  *|\n\t\\****************/\n\n\tsetlocale(LC_ALL, \"\");\n\tcout << \"Mocninátor\" << endl;\n\tcout << \"==========\" << endl;\n\tcout << \"Zadejte základ mocniny: \" << endl;\n\tint a, n; // vytvoříme 2 proměnné naráz\n\tcin >> a;\n\tcout << \"Zadejte exponent: \" << endl;\n\tcin >> n;\n\n\tint vysledek = a;\n\tfor (int i = 0; i < (n - 1); i++)\n\t\tvysledek = vysledek * a;\n\n\tcout << \"Výsledek: \" << vysledek << endl;\n\tcout << \"Děkuji za použití mocninátoru\" << endl;\n\tcin.get();cin.get();\n\n\treturn 0;\n}"
        }
      ],
      "id": "lAdWeA0U",
      "createdAt": 1710266446405,
      "updatedAt": 1710704996234
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Bubblesort",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\nvoid bubble(char pole[], int velikost_pole)\n{\n    for (int wave = 1; wave < velikost_pole; wave++)\n    {\n        for (int i = 0; i < velikost_pole - wave; i++)\n        {\n            if (pole[i] > pole[i+1])\n            {\n                char temp = pole[i+1];\n                pole[i+1] = pole[i];\n                pole[i] = temp;\n            }\n        }\n    }\n}\n\nint main()\n{\n    char setridit[4] = {'c','b','a'};\n    cout << setridit << endl;\n\n    bubble(setridit, 3);\n\n    cout << setridit << endl;\n\n    return 0;\n}\n"
        }
      ],
      "id": "KE4qbvpd",
      "createdAt": 1710266826367,
      "updatedAt": 1710705074994
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "CPP Version",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "//MIT License\n//\n//Copyright (c) 2024 Tomas Mark\n//\n#pragma once\n#include <string>\n#include <sstream>\n\nclass Cpp\n{\n    std::string cppV;\npublic:\n    Cpp()\n        : cppV{}\n    {\n        if (__cplusplus == 202101L) this->cppV = \"C++23\";\n        else if (__cplusplus == 202002L) this->cppV =\"C++20\";\n        else if (__cplusplus == 201703L) this->cppV = \"C++17\";\n        else if (__cplusplus == 201402L) this->cppV = \"C++14\";\n        else if (__cplusplus == 201103L) this->cppV = \"C++11\";\n        else if (__cplusplus == 199711L) this->cppV = \"C++98\";\n        else this->cppV = \"pre-standard C++.\" + __cplusplus;\n    }\n\n    std::string getCppV() const\n    {\n        return this->cppV;\n    };\n\n    friend std::ostream& operator<<(std::ostream& str, const Cpp& cp)\n    {\n        return str << cp.cppV;\n    };\n};\n\n\n\nstd::string getAppBanner()\n{\n    // 11 rows\n    Cpp cpp;\n    return\n        \"----------------------------------------\\n\"\n        \"Welcome to the game\\n\"\n        \" ___              _\\n\"\n        \"/ __| _ _   __ _ | |_____\\n\"\n        \"\\\\__ \\\\| ' \\\\ / _` || / / -_)\\n\"\n        \"|___/|_||_|\\\\__/_||_\\\\_\\\\___| in console\\n\"\n        \"----------------------------------------\\n\"\n        \"Copyright (c) 2024 Tomas Mark\\n\"\n        \"tomas@digitalspace.name\\n\"\n        \"Enjoy this example of OOP \" + cpp.getCppV() + \" code!\\n\"\n        \"build v0.0.4\\n\";\n}\n"
        }
      ],
      "id": "0bP0uDze",
      "createdAt": 1710266917169,
      "updatedAt": 1710921189061
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Factory tvar",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <functional>\n\nusing namespace std;\n\n// Rozhraní IVykreslitelny\nclass IVykreslitelny\n{\npublic:\n    virtual void Vykresli() = 0;\n    virtual ~IVykreslitelny() {}\n};\n\n// Třídy reprezentující tvary\nclass Ctverec : public IVykreslitelny\n{\npublic:\n    void Vykresli() override\n    {\n        cout << \"Vykresluji ctverec\" << endl;\n    }\n};\n\nclass Trojuhelnik : public IVykreslitelny\n{\npublic:\n    void Vykresli() override\n    {\n        cout << \"Vykresluji trojuhelnik\" << endl;\n    }\n};\n\nclass Kruh : public IVykreslitelny\n{\npublic:\n    void Vykresli() override\n    {\n        cout << \"Vykresluji kruh\" << endl;\n    }\n};\n\n// Továrna na tvary\nclass TvarFactory\n{\nprivate:\n    unordered_map<string, std::function <IVykreslitelny*(string totojezbytecnystring)> > m_tvary;\n\npublic:\n    TvarFactory()\n    {\n        m_tvary[\"Ctverec\"] = [](string totojezbytecnystring)\n        {\n            return new Ctverec();\n        };\n        m_tvary[\"Trojuhelnik\"] = [](string totojezbytecnystring)\n        {\n            return new Trojuhelnik();\n        };\n        m_tvary[\"Kruh\"] = [](string totojezbytecnystring)\n        {\n            return new Kruh();\n        };\n    }\n\n    // Vrati ukazatel na tvar\n    IVykreslitelny* Vytvor(const string& typ)\n    {\n        auto it = m_tvary.find(typ);\n        if (it == m_tvary.end())\n        {\n            throw invalid_argument(\"Neznámý typ tvaru: \" + typ);\n        }\n        string totojezbytecnystring;\n        return it->second(totojezbytecnystring);\n    }\n};\n\n// Použití továrny v programu\nint main()\n{\n    TvarFactory faktorka;\n\n    IVykreslitelny* ctverec = faktorka.Vytvor(\"Ctverec\");\n    ctverec->Vykresli();\n\n    IVykreslitelny* kruh = faktorka.Vytvor(\"Kruh\");\n    kruh->Vykresli();\n\n    delete ctverec;\n    delete kruh;\n\n    return 0;\n}\n"
        }
      ],
      "id": "YsMqk-yG",
      "createdAt": 1710267004411,
      "updatedAt": 1710705042042
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Factory method 1",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Factory Method\nclass Auto\n{\nprivate:\n    string znacka;\n    string model;\n\npublic:\n    Auto(string znacka, string model)\n    {\n        this->znacka = znacka;\n        this->model = model;\n    }\n    string getZnacku()\n    {\n        return this->znacka;\n    }\n    string getModel()\n    {\n        return this->model;\n    }\n};\n\nclass TovarnaNaAuta\n{\npublic:\n    Auto VytvorFelicii()\n    {\n        return Auto(\"Skoda\", \"Felicia\");\n    }\n    Auto VytvorCadilac()\n    {\n        return Auto(\"Cadilac\", \"Ultra\");\n    }\n\n};\n\nint main()\n{\n    // cout << \"Fabia bez faktorky!\" << endl;\n    // Auto fabia = new Auto(\"Skoda\", \"Fabia\");\n\n    cout << \"Felicia pres faktorku!\" << endl << endl;\n\n    // Instance tovarny\n    TovarnaNaAuta* tovarna = new TovarnaNaAuta();\n\n    // Instance felicie inicializovana v tovarne\n    Auto felicia = tovarna->VytvorFelicii();\n        cout << felicia.getZnacku() << \" \" << felicia.getModel() << endl;\n\n    // Instance cadilacu inicializovana v tovarne\n    Auto cadilac = tovarna->VytvorCadilac();\n        cout << cadilac.getZnacku() << \" \" << cadilac.getModel() << endl;\n\n    return 0;\n}\n"
        }
      ],
      "id": "CiiKlTNT",
      "createdAt": 1710267062355,
      "updatedAt": 1710705042027
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Factory method 2",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Factory\nclass Auto\n{\n\nprivate:\n    string znacka;\n    string model;\n\n    Auto(string znacka, string model)\n    {\n        this->znacka = znacka;\n        this->model = model;\n    }\n\npublic:\n    static Auto Felicia()\n    {\n        return Auto(\"Skoda\", \"Felicia\");\n    }\n    static Auto Cadilac()\n    {\n        return Auto(\"Cadilac\", \"Ultra\");\n    }\n\n    string getZnacku()\n    {\n        return this->znacka;\n    }\n    string getModel()\n    {\n        return this->model;\n    }\n};\n\nint main()\n{\n    // cout << \"Fabia bez faktorky!\" << endl;\n    cout << \"Felicia pres statickou faktorku!\" << endl << endl;\n\n    // Instance ze statické metody\n    Auto felicia = Auto::Felicia();\n         cout << felicia.getZnacku() << \" \" << felicia.getModel() << endl;\n\n    // Instance ze statické metody\n    Auto cadilac = Auto::Cadilac();\n        cout << cadilac.getZnacku() << \" \" << cadilac.getModel() << endl;\n\n    return 0;\n}\n"
        }
      ],
      "id": "AWHs-ZSA",
      "createdAt": 1710267130176,
      "updatedAt": 1710705042001
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Implementace bubblesort",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef POLE_H\n#define POLE_H\n\ntemplate<typename T>\nclass Pole\n{\nprivate:\n    T* pole;\n    int pocet_prvku;\n    int velikost_pole;\npublic:\n    Pole(int velikost=8);\n    ~Pole();\n    Pole(const Pole& p);\n    Pole& operator = (const Pole& s);\n    void bubblesort(T pole, int velikost_pole);\n};\n\ntemplate<typename T>\nPole<T>::Pole(int velikost) : velikost_pole(velikost), pocet_prvku(0)\n{\n    this->pole = new T[velikost];\n}\n\ntemplate<typename T>\ninline Pole<T>::~Pole()\n{\n    delete[] this->pole;\n}\n\ntemplate<typename T>\ninline Pole<T>::Pole(const Pole<T> & p) : pole(nullptr)\n{\n    *this = p;\n}\n\ntemplate<typename T>\ninline Pole<T> & Pole<T>::operator=(const Pole<T> & s)\n{\n    if (this == &s)\n        return *this;\n    this->~Pole();\n    this->pole = new T[s.pocet_prvku];\n    for (int i = 0; i < s.pocet_prvku; i++)\n        this->pole[i] = s->pole[i];\n    this->pocet_prvku = s.pocet_prvku;\n    this->velikost_pole = this->pocet_prvku;\n    return *this;\n}\n\ntemplate<typename T>\nvoid Pole<T>::bubblesort(T pole, int velikost_pole)\n{\n    for (int wave = 1; wave < velikost_pole; wave++)\n    {\n        for (int i = 0; i < velikost_pole - wave; i++)\n        {\n            if (pole[i] > pole[i+1])\n            {\n                int temp = pole[i+1];\n                pole[i+1] = pole[i];\n                pole[i] = temp;\n            }\n        }\n    }\n}\n\n#endif // POLE_H\n\n\n#include <iostream>\n#include \"Pole.h\"\n\nusing namespace std;\n\nint main()\n{\n    char str[9] = {'A','B','C','D','Z','X','Y','T'};\n    Pole<char*> c;\n    c.bubblesort(str, 8);\n    for (int i = 0; i < 8; i++)\n        cout << str[i] << \" \";\n\n    cout << endl;\n    int cisla[9] = {9,8,7,6,5,4,3,2};\n    Pole<int*> pInt;\n    pInt.bubblesort(cisla, 8);\n    for (int i = 0; i < 8; i++)\n        cout << cisla[i] << \" \";\n\nreturn 0;\n}\n"
        }
      ],
      "id": "iZrboOTR",
      "createdAt": 1710267194056,
      "updatedAt": 1710705041974
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Namespaces jmenné prostory",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\nnamespace mojeapka\n{\n    class A\n    {\n        public:\n        A() {\n            std::cout << \"mojeapka:class:a\" << std::endl;}\n    };\n}\nnamespace tvojeapka\n{\n    class A\n    {\n        public:\n        A() {\n            std::cout << \"tvojeapka:class:a\" << std::endl;}\n\n    };\n}\n\nint main()\n{\n    cout << \"Hello namespace!\" << endl;\n\n    mojeapka::A maa;\n    tvojeapka::A taa;\n\n\n\n    return 0;\n}\n"
        }
      ],
      "id": "Ce4X2RAc",
      "createdAt": 1710267283694,
      "updatedAt": 1710705041958
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Komplexni cisla",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef __KOMPLEXNI_H_\n#define __KOMPLEXNI_H_\n#include <iostream>\n\nclass Komplexni\n{\nprivate:\n\tdouble realna;\n\tdouble imaginarni;\npublic:\n\tKomplexni();\n\tKomplexni(double a, double b);\n\n\tKomplexni operator+(Komplexni druhe);\n\tKomplexni operator-(Komplexni druhe);\n\tKomplexni operator/(Komplexni druhe);\n\tKomplexni operator*(Komplexni druhe);\n\n\tdouble realnaCast();\n\tdouble imaginarniCast();\n\n\tvoid nastavRealnouCast(double hodnota);\n\tvoid nastavImaginarniCast(double hodnota);\n};\n\nstd::ostream& operator<<(std::ostream& str, Komplexni cislo);\n\n#endif\n\n\n#include \"Komplexni.h\"\n#include <iostream>\n\nKomplexni::Komplexni()\n{\n\tthis->realna = 0;\n\tthis->imaginarni = 0;\n}\n\nKomplexni::Komplexni(double a, double b)\n{\n\tthis->realna = a;\n\tthis->imaginarni = b;\n}\n\nKomplexni Komplexni::operator+(Komplexni druhe)\n{\n\treturn Komplexni(this->realna + druhe.realna, this->imaginarni + druhe.imaginarni);\n}\n\nKomplexni Komplexni::operator-(Komplexni druhe)\n{\n\treturn Komplexni(this->realna - druhe.realna, this->imaginarni - druhe.imaginarni);\n}\n\nKomplexni Komplexni::operator/(Komplexni druhe)\n{\n\tif (druhe.realna == 0 && druhe.imaginarni == 0)\n\t\treturn Komplexni(0, 0);\n\n\tdouble jmenovatel = druhe.realna * druhe.realna + druhe.imaginarni * druhe.imaginarni;\n\tdouble realna = (this->realna * druhe.realna + this->imaginarni * druhe.imaginarni) / jmenovatel;\n\tdouble imaginarni = ((this->imaginarni * druhe.realna - this->realna * druhe.imaginarni) / jmenovatel);\n\treturn Komplexni();\n}\n\nKomplexni Komplexni::operator*(Komplexni druhe)\n{\n\tdouble realna = this->realna * druhe.realna - this->imaginarni * druhe.imaginarni;\n\tdouble imaginarni = this->imaginarni * druhe.realna + this->realna * druhe.imaginarni;\n\treturn Komplexni(realna, imaginarni);\n}\n\ndouble Komplexni::realnaCast()\n{\nreturn this->realna;\n}\n\ndouble Komplexni::imaginarniCast()\n{\n\treturn this->imaginarni;\n}\n\nvoid Komplexni::nastavRealnouCast(double hodnota)\n{\n\tthis->realna = hodnota;\n}\n\nvoid Komplexni::nastavImaginarniCast(double hodnota)\n{\n\tthis->imaginarni = hodnota;\n}\n\nstd::ostream & operator << (std::ostream & str, Komplexni cislo)\n{\n\tstr << cislo.realnaCast();\n\tstr << (cislo.imaginarniCast() >= 0 ? '+' : '-');\n\tstr << cislo.imaginarniCast() << 'i';\n\treturn str;\n}\n\n\n#include <iostream>\n#include \"Komplexni.h\"\n\nusing namespace std;\n\nint main()\n{\n\tKomplexni a(1, 1);\n\tKomplexni b(-1,3);\n\n\tcout << a << \" + \" << b << \" = \" << (a + b) << endl;\n\tcout << a << \" - \" << b << \" = \" << (a - b) << endl;\n\tcout << a << \" * \" << b << \" = \" << (a * b) << endl;\n\tcout << a << \" / \" << b << \" = \" << (a / b) << endl;\n\n\t// cin.get();\n\treturn 0;\n}\n\n"
        },
        {
          "label": "Fragment 2",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\nclass komplex\n{\n    double re, im;\npublic:\n    komplex(double _re = 0, double _im = 0);\n    komplex plus(komplex a);\n};\n\nkomplex::komplex(double _re, double _im)\n: re(_re), im(_im)\n{\n    cout << \"konstr\" << _re << \" \" << _im << endl;\n}\n\nkomplex komplex::plus(komplex a)\n{\n    return komplex(re + a.re, im + a.im);\n}\n\nkomplex a(5), b(3.1, 5.2);\n\nint main()\n{\n    nastav_konzolu_pro_cp1250();\n    komplex pole[5]{komplex(3,7), a, a.plus(b), 8};\n    return 0;\n}\n"
        },
        {
          "label": "Fragment 3",
          "language": "c_cpp",
          "value": "class komplex\n{\n\tdouble re, im;\npublic:\n\tkomplex(double _re, double _im = 0)\n\t\t:re(_re), im(_im)\n\t{}\n\tstatic const komplex i;\n\tstatic const komplex nula;\n\tkomplex plus(komplex a)\n\t{\n\t\treturn komplex(re + a.re, im + a.im);\n\t}\n};\n\nconst komplex komplex::i{ 0, 1 };\nconst komplex komplex::nula{ 0, 0 };\n\n\nint main()\n{\n\tkomplex w{ 6,2 };\n\tkomplex z = w.plus(komplex::i);\n}"
        }
      ],
      "id": "sqqX1QcM",
      "createdAt": 1710267347797,
      "updatedAt": 1710705041795
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Konverze tridy na jiny typ 1 class conversion",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef TRIDAA_H_INCLUDED\n#define TRIDAA_H_INCLUDED\n\n#include <iostream>\n\nclass TridaA\n{\npublic:\n    double atribut = 12;\n};\n\n#endif // TRIDAA_H_INCLUDED\n\n#ifndef TRIDAB_H_INCLUDED\n#define TRIDAB_H_INCLUDED\n\n#include <iostream>\nusing namespace std;\nclass TridaB\n{\nprivate:\n    int atribut = 14;\npublic:\n    operator TridaA() const; // operátor konverze na typ TridaA\n};\nTridaB::operator TridaA() const\n{\n    TridaA a;\n    a.atribut = (double)this->atribut;\n    return a;\n}\n\n#endif // TRIDAB_H_INCLUDED\n\n#include <iostream>\n#include \"TridaA.h\"\n#include \"TridaB.h\"\nusing namespace std;\n\nint main()\n{\n    TridaB b;\n    TridaA b_konvertovano = (TridaA)b;\n    TridaA b_implicitne = b;\n    cout << \"Konvertovano: \" << b_konvertovano.atribut << endl;\n    cout << \"Implicitne: \" << b_implicitne.atribut << endl;\n    return 0;\n\n}\n\n"
        }
      ],
      "id": "CvdzGyTs",
      "createdAt": 1710267415351,
      "updatedAt": 1710705041942
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Konverze tridy na jiny typ 2 class conversion",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef TRIDAA_H_INCLUDED\n#define TRIDAA_H_INCLUDED\n\nclass TridaA\n{\npublic:\n    double atribut = 12;\n};\n\n#endif // TRIDAA_H_INCLUDED\n\n#ifndef TRIDAB_H_INCLUDED\n#define TRIDAB_H_INCLUDED\n\n#include <iostream>\nusing namespace std;\nclass TridaB\n{\nprivate:\n    int atribut = 14;\npublic:\n    operator TridaA() const;\n};\n\nTridaB::operator TridaA() const\n{\n    TridaA a;\n    a.atribut = (double)this->atribut;\n    return a;\n}\n\nvoid funkce(TridaA a) // použili jsme typ, na který lze třída převést\n{\n    cout << \"Z funkce: \" << a.atribut << endl;\n}\n\n#endif // TRIDAB_H_INCLUDED\n\n#include <iostream>\n#include \"TridaA.h\"\n#include \"TridaB.h\"\nusing namespace std;\n\nint main()\n{\n    TridaB b;\n    funkce(b);\n    return 0;\n}\n"
        }
      ],
      "id": "qLzgClm5",
      "createdAt": 1710267485730,
      "updatedAt": 1710705041918
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Konverze tridy na jiny typ 3 class conversion",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef TRIDAA_H_INCLUDED\n#define TRIDAA_H_INCLUDED\n\n#include <iostream>\n\nclass TridaA\n{\npublic:\n    double atribut = 12;\n};\n\n\n#endif // TRIDAA_H_INCLUDED\n\n#ifndef TRIDAB_H_INCLUDED\n#define TRIDAB_H_INCLUDED\n\n#include <iostream>\nusing namespace std;\n\nclass TridaB\n{\nprivate:\n    int atribut = 14;\npublic:\n    explicit operator TridaA() const;\n};\n\nTridaB::operator TridaA() const\n{\n    TridaA a;\n    a.atribut = (double)this->atribut;\n    return a;\n}\n\nvoid funkce(TridaA a) // použili jsme typ, na který lze třída převést\n{\n    cout << \"Z funkce: \" << a.atribut << endl;\n}\n\n#endif // TRIDAB_H_INCLUDED\n\n\n#include <iostream>\n#include \"TridaA.h\"\n#include \"TridaB.h\"\nint main()\n{\n    TridaB b;\n    //funkce(b); //nefunguje\n    funkce((TridaA)b);\n    return 0;\n}\n"
        }
      ],
      "id": "y2A6qwOw",
      "createdAt": 1710267521449,
      "updatedAt": 1710705041891,
      "folder": {
        "name": "oop",
        "parentId": null,
        "isOpen": false,
        "isSystem": false,
        "defaultLanguage": "c_cpp",
        "id": "ypL8xUlj",
        "createdAt": 1710266998471,
        "updatedAt": 1710267016958
      }
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Sinusoida",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nint main()\n{\n    const int jednotka_casu = 1;\n    const int delka_casu = 59;\n    const int vyska_konzole = 20;\n\n    char platno[delka_casu+1][vyska_konzole+1];\n\n    // vycisti platno\n    for (int v = 0; v < delka_casu; v++)\n    {\n        for (int h = 0; h < vyska_konzole; h++)\n        {\n            platno[v][h] = ' ';\n        }\n\n    }\n\n    double pomer_do_sirky = ( 2.0 * 3.14 ) / (double)delka_casu; //jaká hodnota připadá šířce jednoho políčka v poli\n\tdouble pomer_do_vysky = (double)2 / (double)( vyska_konzole - 2 ); //jaká hodnota připadá výšce jednoho políčka v poli\n\n    // zapis sinus do platna\n    for (int cas = 0; cas < delka_casu; cas++)\n    {\n        double pocitana_hodnota = cas * pomer_do_sirky; //jakou hodnotu (v radiánech) počítáme\n\t\tdouble hodnota = sin( pocitana_hodnota ); //vypočítaná hodnota\n\t\tint j = ( hodnota / pomer_do_vysky ) + ( vyska_konzole / 2 );\n\n\t\tplatno[cas][j] = '#'; //naplnění bufferu\n\n        // moje vlastni funkce, ktera funguje podobne, jen ma jinou presnost\n        // double amp = sin( 2 * pi) / + ( cas * koeficient_casu ) );\n        // cout << amp << \"\\t\" << round(amp*vyska_vlny) << \"\\t cas: \" << cas << endl;\n        // platno[ (int)((floor(amp*vyska_vlny)*-1)/*swap sign*/) + vertikalni_stred_konzole] [cas] = '#';\n    }\n\n    // vykresli platno\n    for (int v = 0; v < vyska_konzole; v++)\n    {\n        for (int h = 0; h < delka_casu; h++)\n        {\n            cout << platno[h][vyska_konzole - 1 - v];\n        }\n        cout /* << v */ << endl;\n    }\n\n    return 0;\n}\n\t"
        }
      ],
      "id": "zaNun6C4",
      "createdAt": 1710267636199,
      "updatedAt": 1710704974310
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Stupne na radian",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef PREVODNIK_H\n#define PREVODNIK_H\n\n\n\nclass Prevodnik\n{\n    public:\n        Prevodnik();\n        double stupneNaRadiany(double stupne);\n        double radianyNaStupne(double radiany);\n        static int instance_cislo;\n};\n\n#endif // PREVODNIK_H\n\n#include \"Prevodnik.h\"\n\n#define PI (double)3.1416\n\nint Prevodnik::instance_cislo = 0;\n\nPrevodnik::Prevodnik()\n{\n    Prevodnik::instance_cislo +=1;\n}\n\ndouble Prevodnik::stupneNaRadiany(double stupne)\n{\n    return stupne * (PI / 180);\n}\n\ndouble Prevodnik::radianyNaStupne(double radiany)\n{\n    return radiany / (PI / 180);\n}\n\n#include <iostream>\n#include \"Prevodnik.h\"\n\nusing namespace std;\n\nint main()\n{\n    Prevodnik s2r;\n\n    std::cout << \"6.28 radianu je \" <<\n    s2r.radianyNaStupne(6.28) << \" stupnu\\n\";\n\n    std::cout << \"90 stupnu je \" <<\n    s2r.stupneNaRadiany(90) << \" radianu\\n\";\n\n    return 0;\n}\n\t\n"
        }
      ],
      "id": "Y_mcvaVc",
      "createdAt": 1710267711113,
      "updatedAt": 1710704974278
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Kulicka",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <unistd.h>\n#include <stdlib.h>\n#include <windows.h>\n\nusing namespace std;\n\n// atributy micku\nstruct micek\n{\n    int micek_x = 0;\n    int micek_y = 0;\n    const int pocet_smeru = 8;\n    int smer = rand() % pocet_smeru; // nahodny prvni smer micku\n    int rychlost;\n    enum smer {doprava, dolu, doleva, nahoru};\n};\n\nint main()\n{\n    /* initialize random seed: */\n    srand (time(NULL));\n\n    const int kroku_max = 1000000;\n    int krok_index = 0;\n\n    const int v = 15, h = 60;\n\n    char matrix[v][h];\n    for (int i=0; i<v; i++)\n        for (int j=0; j<h; j++)\n            matrix[i][j]=' ';\n\n    // vytvarime instanci micudy\n    micek micuda;\n\n    // centrujeme micudu\n    micuda.micek_x = v/2;\n    micuda.micek_y = h/2;\n\n\n    // --- hlavni smycka\n    do\n    {\n        usleep(10000);\n        // system(\"CLS\");\n        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), COORD{ 0,0 });\n\n\n        // kresli obdelnik do bufferu\n        for (int i=0; i<v; i++)\n        {\n            // plnime vertikaly\n            matrix[i][0]='#';\n            matrix[i][h-1]='#';\n\n            for (int j=0; j<h; j++)\n            {\n                // plnime horizontaly\n                matrix[0][j]='#';\n                matrix[v-1][j]='#';\n\n                // plnime micudu\n                matrix[micuda.micek_x][micuda.micek_y] = 'O';\n\n                // kreslime buffer\n                cout << matrix[i][j];\n            }\n            cout << endl;\n        }\n\n        // vymazat stareho micudu z bufferu\n        matrix[micuda.micek_x][micuda.micek_y] = ' ';\n\n        // posouvame micudu - udavame nove souradnice dle smeru\n        switch (micuda.smer)\n        {\n            case 0: // doprava\n            {\n                micuda.micek_y+=1;\n                break;\n            }\n            case 1: // sikmo doprava dolu\n            {\n                micuda.micek_x+=1;\n                micuda.micek_y+=1;\n                break;\n            }\n            case 2: // dolu\n            {\n                micuda.micek_x+=1;\n                break;\n            }\n            case 3: // sikmo doleva dolu\n            {\n                micuda.micek_x+=1;\n                micuda.micek_y-=1;\n                break;\n            }\n            case 4: // doleva\n            {\n                micuda.micek_y-=1;\n                break;\n            }\n            case 5: // sikmo doleva nahoru\n            {\n                micuda.micek_x-=1;\n                micuda.micek_y-=1;\n                break;\n            }\n            case 6: // nahoru\n            {\n                micuda.micek_x-=1;\n                break;\n            }\n            case 7: // sikmo doprava nahoru\n            {\n                micuda.micek_x-=1;\n                micuda.micek_y+=1;\n                break;\n            }\n        }\n\n        // kontrola kolize a odrazu\n        // kolizni drahy jsou\n        // vertikalni   [0][?],[v-1][?]\n        // horizontalni [?][0],[?][h-1]\n        // rohy leve    [0][0],[v-1][0]\n        // rohy prave   [0][h-1],[v-1][h-1]\n\n\n        if (micuda.micek_x == 1 || micuda.micek_x == v-1)\n        {\n            cout << \"kolize horizontalni cary\" << endl;\n            micuda.micek_x == 1 ? micuda.smer = rand() % 3 + 1, micuda.micek_x++ : micuda.smer = rand() % 2 + 5, micuda.micek_x--;\n        }\n\n        if (micuda.micek_y == 1 || micuda.micek_y == h-1)\n        {\n            cout << \"kolize vertikalni cary\" << endl;\n\n            // vetsi legrace\n            int randomPrava[]{0,1,7}; // pomucka pro necelistvost\n            micuda.micek_y == 1 ? micuda.smer = randomPrava[rand() % 3], micuda.micek_y++ : micuda.smer = rand() % 2 + 3, micuda.micek_y--;\n        }\n\n    krok_index++;\n    }\n    while (krok_index < kroku_max);\n\n    return 0;\n}\n"
        }
      ],
      "id": "KxNtc-7e",
      "createdAt": 1710267762691,
      "updatedAt": 1710704996202
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Generator vet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef Generator_H\n#define Generator_H\n#include <string>\n\nusing namespace std;\n\n\nclass Generator\n{\n    public:\n        Generator();\n        ~Generator();\n\n        string * jaky;\n        string * kdo;\n        string * jak;\n        string * sloveso;\n        string * kde;\n\n    protected:\n\n    private:\n};\n\n#endif // Generator_H\n\n#include <iostream>\n#include \"Generator.h\"\n#include <cstdlib>\n\nusing namespace std;\n\nGenerator::Generator()\n{\n    //ctor\n    srand(time(nullptr));\n\n    int cjaky=7,ckdo=7,cjak=4,csloveso=6,ckde=6;\n\n    jaky = new string [cjaky]{\"Tlusty\",\"Maly\", \"Rychly\", \"Nejlepsi\", \"Nejhorsi\", \"Modry\", \"Automatizovany\"};\n    //int pocetPrvku=0;\n    // Iterace přes pole, dokud nenarazíme na prázdný řetězec\n    //while (!jaky[pocetPrvku].empty()) {\n    //    pocetPrvku++;\n    //}\n    kdo = new string [ckdo]\n    {\"horolezec\", \"postak\", \"programator\", \"elektrikar\", \"dinosaurus\", \"alkoholik\", \"doktor\"};\n    jak = new string [cjak]\n    {\"malo\", \"pomalu\", \"nerad\", \"rychle\"};\n    sloveso = new string [csloveso]\n    {\"programoval\", \"pocital\", \"jezdil\", \"cetl\", \"behal\", \"psal\"};\n    kde = new string [ckde]\n    {\"ve sklepe\",\"u babicky\", \"ve meste\", \"na strese\", \"doma\", \"ve vsi\"};\n\n\n    for (int i = 0; i < 10; i ++)\n    {\n        cout    << jaky[rand() % cjaky] << \" \"\n                << kdo [rand() % ckdo] << \" \"\n                << jak [rand() % cjak] << \" \"\n                << sloveso [rand() % csloveso] << \" \"\n                << kde [rand() % ckde] << \" \"\n                << endl;\n    }\n}\n\nGenerator::~Generator()\n{\n    //dtor\n    delete [] jaky;\n    delete [] kdo;\n    delete [] jak;\n    delete [] sloveso;\n    delete [] kde;\n}\n\n#include <iostream>\n#include \"Generator.h\"\n\nusing namespace std;\n\nint main()\n{\n    Generator gen;\n    return 0;\n}\n\n\n"
        }
      ],
      "id": "s6vlGQyg",
      "createdAt": 1710267842861,
      "updatedAt": 1710705041732
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "List windows locales",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <Windows.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <ostream>\n\nusing namespace std;\n\nvector<wstring> locals;\n\nBOOL CALLBACK MyFuncLocaleEx(LPWSTR pStr, DWORD dwFlags, LPARAM lparam)\n{\n    locals.push_back(pStr);\n    return TRUE;\n}\n\nint main(int argc, char **argv)\n{\n    EnumSystemLocalesEx(MyFuncLocaleEx, LOCALE_ALL, NULL, NULL);\n\n    for (vector<wstring>::const_iterator str = locals.begin(); str != locals.end(); ++str)\n        wcout << *str << endl;\n\n    wcout << \"Total \" << locals.size() << \" locals found.\" << endl;\n\n    return 0;\n}"
        }
      ],
      "id": "Wz4cBKj5",
      "createdAt": 1710267899583,
      "updatedAt": 1710704981097
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Najdi Patek 13 Patky",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    char retezec[80];\n    char tecka;\n    time_t ted = time(NULL);\n    tm odData = *localtime(&ted);\n    tm doData = *localtime(&ted);\n\n    cout << \"Zadejte datum od jako dd.mm.yyyy: \";\n    cin >> odData.tm_mday >> tecka >> odData.tm_mon >> tecka >> odData.tm_year;\n    cout << \"Zadejte datum do jako dd.mm.yyyy: \";\n    cin >> doData.tm_mday >> tecka >> doData.tm_mon >> tecka >> doData.tm_year;\n    odData.tm_year -= 1900;\n    doData.tm_year -= 1900;\n\n    cout << \"Patek 13.\" << endl;\n    while (mktime(&odData) != mktime(&doData)) {\n\n        if (odData.tm_mday == 13 && odData.tm_wday == 5) {\n            strftime(retezec, 79, \"%a %b %d %Y\", &odData);\n            cout << retezec << endl;\n        }\n        odData.tm_mday++;\n    }\n    return 0;\n}\n"
        }
      ],
      "id": "m10UEdlK",
      "createdAt": 1710268005651,
      "updatedAt": 1710705015370
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Template exam 1",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef SABLONA_H_INCLUDED\n#define SABLONA_H_INCLUDED\n#include <iostream>\n\ntemplate <class T>\nT f(T t)\n{\n    return 0;\n}\n\ntemplate <class T>\nclass X\n{\n    public:\n        X(T t) { std::cout << t << std::endl; };\n};\n\n//template <class T>\n//X<T>::X(T t)\n//{\n//    // Implementace konstruktoru\n//}\n\ntemplate <class T, class U=T, int n=0>\nclass M\n{\npublic:\n    M(T t) { std::cout << t; };\n};\n\n\n#endif // SABLONA_H_INCLUDED\n\n#include <iostream>\n#include \"sablona.h\"\nusing namespace std;\n\nint main()\n{\n    cout << \"sablona\" << endl;\n    double d = f<long>(66.7);\n\n    X<double> x(58.6);\n\n    M<int> a(2);\n\n    return 0;\n}\n"
        }
      ],
      "id": "V98S8NC5",
      "createdAt": 1710268132026,
      "updatedAt": 1710705047864
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Class Template exam 1",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef POLE_H\n#define POLE_H\n\n//Pokud použijeme statiku u šablonových tøíd, musíme poèítat s tím,\n//že bude sdílena jen pro každou sadu šablonových parametrù. Budeme-li mít\n//statický atribut, potom pro všechny rozdílné parametry šablony bude tento\n//atribut jedineèný a nebude sdílen. Pøedveïme si to na jednoduchém\n//pøíkladu. Naše pole bude mít statický atribut, ve kterém budeme poèítat,\n//kolik instancí pole existuje.\n//Zdroj: https://www.itnetwork.cz/cplusplus/oop/sablonove-tridy-v-cplusplus-tutorial\n\ntemplate<typename T>\nclass Pole\n{\npublic:\n    Pole();\n    ~Pole();\n    static int pocet_instanci;\n};\n\ntemplate<typename T>\nint Pole<T>::pocet_instanci = 0;\n\ntemplate<typename T>\nPole<T>::Pole()\n{\n    pocet_instanci++;\n}\n\ntemplate<typename T>\ninline Pole<T>::~Pole()\n{\n    pocet_instanci--;\n}\n\n#endif // POLE_H\n\nint main()\n{\n    Pole<int> p;\n    Pole<int> q;\n    Pole<float> a;\n    Pole<float> b;\n    Pole<float> c;\n    Pole<char> x;\n    cout << \"Pole int: \" << p.pocet_instanci << endl;\n    cout << \"Pole float: \" << a.pocet_instanci << endl;\n    cout << \"Pole char: \" << x.pocet_instanci << endl;\n    return 0;\n}\n"
        }
      ],
      "id": "JTLgU_sh",
      "createdAt": 1710268219098,
      "updatedAt": 1710705047839,
      "folder": {
        "name": "temp",
        "parentId": null,
        "isOpen": false,
        "isSystem": false,
        "defaultLanguage": "c_cpp",
        "id": "YqoiptpJ",
        "createdAt": 1710268118215,
        "updatedAt": 1710268127530
      }
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Class Template exam 2",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef POLE0_H\n#define POLE0_H\n\n//Pokud implementaci oddìlíme, potom musíme pøed každou metodou pøidat\n//klíèové slovo  template zároveò s parametry,\n//které jsme zvolili pøi deklaraci tøídy. Stejnì tak musíme použít\n//parametry pøi každém výskytu naší tøídy. Taková základní implementace\n//by mohla vypadat nìjak takto:\n//Zdroj: https://www.itnetwork.cz/cplusplus/oop/sablonove-tridy-v-cplusplus-tutorial\n\ntemplate<typename T>\nclass Pole\n{\nprivate:\n    T* pole;\n    int pocet_prvku;\n    int velikost_pole;\npublic:\n    Pole(int velikost=8);\n    ~Pole();\n    Pole(const Pole& p);\n    Pole& operator = (const Pole& s);\n\n    template<int ZVETSENI=2>\n    void vlozNakonec(T prvek);\n\n    T& operator [](int index);\n    const T& operator [](int index) const;\n    int velikost() const;\n};\n\ntemplate<typename T>\nPole<T>::Pole(int velikost) : pocet_prvku(0), velikost_pole(velikost)\n{\n    this->pole = new T[velikost];\n}\n\ntemplate<typename T>\nPole<T>::~Pole()\n{\n    delete[] this->pole;\n}\n\ntemplate<typename T>\nPole<T>::Pole(const Pole<T> & p) : pole(nullptr)\n{\n    *this = p;\n}\n\ntemplate<typename T>\nPole<T> & Pole<T>::operator=(const Pole<T> & s)\n{\n    if (this == &s)\n        return *this;\n    this->~Pole();\n    this->pole = new T[s.pocet_prvku];\n    for (int i = 0; i < s.pocet_prvku; i++)\n        this->pole[i] = s->pole[i];\n    this->pocet_prvku = s.pocet_prvku;\n    this->velikost_pole = this->pocet_prvku;\n    return *this;\n}\n\n// ...zbytek implementace\ntemplate<typename T>\nT & Pole<T>::operator[](int index)\n{\n    if (index < 0 || index >= this->pocet_prvku)\n        index = 0; //Nahradime pozdeji necim jinym\n    return this->pole[index];\n}\n\ntemplate<typename T>\nconst T & Pole<T>::operator[](int index) const\n{\n    if (index < 0 || index >= this->pocet_prvku)\n        index = 0; //Nahradime pozdeji necim jinym\n    return this->pole[index];\n}\n\ntemplate<typename T>\nint Pole<T>::velikost() const\n{\n    return this->pocet_prvku;\n}\ntemplate<typename T>\ntemplate<int ZVETSENI>\nvoid Pole<T>::vlozNakonec(T prvek)\n{\n    if (this->velikost_pole == this->pocet_prvku)\n    {\n        this->velikost_pole = this->velikost_pole * ZVETSENI;\n        T* vytvoreno = new T[this->velikost_pole];\n        for (int i = 0; i<this->pocet_prvku; i++)\n            vytvoreno[i] = this->pole[i];\n        delete[] this->pole;\n        this->pole = vytvoreno;\n    }\n    this->pole[pocet_prvku] = prvek;\n    pocet_prvku++;\n}\n\n#endif // POLE0_H\n\nusing namespace std;\n\n// Pole0.h\nint main()\n{\n    Pole<int> p;\n    for (int i = 0; i < 10; i++)\n        p.vlozNakonec(i * 2);\n    cout << \"Pole: \";\n    for (int i = 0; i < p.velikost(); i++)\n        cout << p[i] << \" \";\n    cout << endl;\n    return 0;\n}"
        }
      ],
      "id": "TzT2Uf-v",
      "createdAt": 1710268308917,
      "updatedAt": 1710705047814,
      "folder": {
        "name": "temp",
        "parentId": null,
        "isOpen": false,
        "isSystem": false,
        "defaultLanguage": "c_cpp",
        "id": "YqoiptpJ",
        "createdAt": 1710268118215,
        "updatedAt": 1710268127530
      }
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Pocet instanci tridy - number of class instance",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include \"PocitajiciTrida.h\"\n\ntemplate<typename T>\nclass NejakaSablona : public PocitajiciTrida\n{\n\n};\n\nclass PocitajiciTrida\n{\nprivate:\n\tstatic int pocetInstanci;\nprotected:\n\tPocitajiciTrida();\n\tvirtual ~PocitajiciTrida();\npublic:\n\tstatic int ziskejPocetInstanci();\n};\n\n#include \"PocitajiciTrida.h\"\n\nint PocitajiciTrida::pocetInstanci = 0;\n\n\nPocitajiciTrida::PocitajiciTrida()\n{\n\tpocetInstanci++;\n}\n\n\nPocitajiciTrida::~PocitajiciTrida()\n{\n\tpocetInstanci--;\n}\n\nint PocitajiciTrida::ziskejPocetInstanci()\n{\n\treturn pocetInstanci;\n}\n\n#include <iostream>\n#include \"NejakaSablona.h\"\n\nusing namespace std;\n\nint main()\n{\n\tcout << NejakaSablona<int>::ziskejPocetInstanci() << endl;\n\tNejakaSablona<int> a;\n\tcout << NejakaSablona<int>::ziskejPocetInstanci() << endl;\n\tNejakaSablona<char> b;\n\tcout << NejakaSablona<int>::ziskejPocetInstanci() << endl;\n\t{\n\t\tNejakaSablona<int> c;\n\t\tcout << NejakaSablona<int>::ziskejPocetInstanci() << endl;\n\t}\n\tcout << NejakaSablona<int>::ziskejPocetInstanci() << endl;\n\n\n\tcin.get();\n\treturn 0;\n}"
        }
      ],
      "id": "H1bVgDrV",
      "createdAt": 1710275249684,
      "updatedAt": 1710705041866
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Zasobnik",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "template<typename T>\nclass Pole\n{\nprivate:\n\tT * pole;\n\tint pocet_prvku;\n\tint velikost_pole;\npublic:\n\tPole(int velikost = 8);\n\t~Pole();\n\tPole(const Pole& p);\n\tPole& operator = (const Pole& s);\n\ttemplate<int ZVETSENI = 2>\n\tvoid vlozNakonec(T prvek);\n\tT& operator [](int index);\n\tconst T& operator [](int index) const;\n\tint velikost() const;\n\tvoid smazNaPozici(int index);\n};\n\ntemplate<typename T>\nPole<T>::Pole(int velikost) : pocet_prvku(0), velikost_pole(velikost)\n{\n\tthis->pole = new T[velikost];\n}\n\ntemplate<typename T>\nPole<T>::~Pole()\n{\n\tdelete[] this->pole;\n}\n\ntemplate<typename T>\nPole<T>::Pole(const Pole<T> & p) : pole(NULL)\n{\n\t*this = p;\n}\n\ntemplate<typename T>\nPole<T> & Pole<T>::operator=(const Pole<T> & s)\n{\n\tif (this == &s)\n\t\treturn *this;\n\tthis->~Pole();\n\tthis->pole = new T[s.pocet_prvku];\n\tfor (int i = 0; i < s.pocet_prvku; i++)\n\t\tthis->pole[i] = s->pole[i];\n\tthis->pocet_prvku = s.pocet_prvku;\n\tthis->velikost_pole = this->pocet_prvku;\n\treturn *this;\n}\n\n// ...zbytek implementace\ntemplate<typename T>\nT & Pole<T>::operator[](int index)\n{\n\tif (index < 0 || index >= this->pocet_prvku)\n\t\tindex = 0; //Nahradime pozdeji necim jinym\n\treturn this->pole[index];\n}\n\ntemplate<typename T>\nconst T & Pole<T>::operator[](int index) const\n{\n\tif (index < 0 || index >= this->pocet_prvku)\n\t\tindex = 0; //Nahradime pozdeji necim jinym\n\treturn this->pole[index];\n}\n\ntemplate<typename T>\nint Pole<T>::velikost() const\n{\n\treturn this->pocet_prvku;\n}\n\ntemplate<typename T>\ninline void Pole<T>::smazNaPozici(int index)\n{\n\tif (index >= this->velikost())\n\t\treturn;\n\n\tfor (int i = 0; i < this->velikost() - index; i++)\n\t\tthis->pole[index + i] = this->pole[index + i + 1];\n\n\tthis->pocet_prvku--;\n}\n\n\ntemplate<typename T>\ntemplate<int ZVETSENI>\nvoid Pole<T>::vlozNakonec(T prvek)\n{\n\tif (this->velikost_pole == this->pocet_prvku)\n\t{\n\t\tthis->velikost_pole = this->velikost_pole * ZVETSENI;\n\t\tT* vytvoreno = new T[this->velikost_pole];\n\t\tfor (int i = 0; i<this->pocet_prvku; i++)\n\t\t\tvytvoreno[i] = this->pole[i];\n\t\tdelete[] this->pole;\n\t\tthis->pole = vytvoreno;\n\t}\n\tthis->pole[pocet_prvku] = prvek;\n\tpocet_prvku++;\n}\n\n#include \"Pole.h\"\n\ntemplate<typename T>\nclass Zasobnik\n{\nprivate:\n\tPole<T> zasobnik;\npublic:\n\tvoid vloz(T prvek);\n\tT odeber();\n\tbool jePrazdny() const;\n};\n\n\ntemplate<typename T>\nvoid Zasobnik<T>::vloz(T prvek)\n{\n\tthis->zasobnik.vlozNakonec(prvek);\n}\n\ntemplate<typename T>\nT Zasobnik<T>::odeber()\n{\n\tint pozice = this->zasobnik.velikost() - 1;\n\tT tmp = this->zasobnik[pozice];\n\tthis->zasobnik.smazNaPozici(pozice);\n\treturn tmp;\n}\n\ntemplate<typename T>\nbool Zasobnik<T>::jePrazdny() const\n{\n\treturn this->zasobnik.velikost() == 0;\n}\n\n#include <iostream>\n#include \"Zasobnik.h\"\n\nusing namespace std;\n\nint main()\n{\n\tZasobnik<int> a;\n\tfor (int i = 0; i < 10; i++)\n\t\ta.vloz(i * 2);\n\n\twhile (!a.jePrazdny())\n\t\tcout << a.odeber() << endl;\n\n\tcin.get();\n\treturn 0;\n}\n\n"
        }
      ],
      "id": "sv7_Zf2c",
      "createdAt": 1710275379203,
      "updatedAt": 1710705041827
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": "Vaším úkolem bude napsat funkci, ve které uživatel \nopakovaně zadává slova. Ovšem ve chvíli, kdy uživatel vypíše \"end\" nebo\n\"konec\", funkce se ukončí výjimkou. Výjimka bude obsahovat poslední zadané\nslovo (tedy to ukončovací) a také všechna zadaná slova. Musíte si tedy pro\nvýjimku vytvořit vlastní třídu.",
      "name": "Exception 1",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n\nclass MojeVyjimka\n{\npublic:\n\tvector<string> slova;\n\tstring konecneSlovo;\n\tMojeVyjimka(vector<string> slova, string konecneSlovo);\n};\n\nMojeVyjimka::MojeVyjimka(vector<string> slova, string konecneSlovo)\n\t: slova(slova), konecneSlovo(konecneSlovo)\n{}\n\n\nvoid zadavniSlov()\n{\n\tvector<string> databaze;\n\n\twhile (true)\n\t{\n\t\tstring slovo;\n\t\tcout << \"Zadejte slovo: \";\n\t\tcin >> slovo;\n\t\tif (slovo == \"konec\" || slovo == \"end\")\n\t\t\tthrow MojeVyjimka(databaze, slovo);\n\n\t\tdatabaze.push_back(slovo);\n\t}\n}\n\nint main()\n{\n\ttry\n\t{\n\t\tzadavniSlov();\n\t}\n\tcatch (MojeVyjimka vyjimka)\n\t{\n\t\tfor (int i = 0; i < vyjimka.slova.size(); i++)\n\t\t\tcout << vyjimka.slova[i] << \" \";\n\t\tcout << endl;\n\t\tcout << \"Ukonceno slovem: \" << vyjimka.konecneSlovo << endl;\n\t}\n\n\n\tcin.get();\n\tcin.get();\n\treturn 0;\n}"
        }
      ],
      "id": "n90Qf2i7",
      "createdAt": 1710276202026,
      "updatedAt": 1710705053578
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": "Vytvořte třídu Fronta, která bude fungovat jako FIFO struktura. To znamená, že první hodnotu, kterou do fronty vložíte, vytáhnete jako první. Jako by prvky v kolekci opravdu stály ve frontě, ty nové se přidávaly na konec fronty a odebíralo se z jejího začátku. Je to opačná struktura k zásobníku, který jsme již v cvičeních implementovali. Ukázka fronty - Objektově orientované programování v C++\nFrontu samozřejmě vytvořte jako šablonu. Opět můžete použít již implementovanou třídu Pole uvnitř fronty.\nSpeciální případ nastane, pokud budeme chtít z fronty získat další prvek, ale fronta je již prázdná. V takovém případě fronta vyvolá výjimku.\nKód naplnění a výpisu vaší fronty může vypadat následovně:",
      "name": "Exception 2 ",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "\n\n#ifndef __POLE_H_\n#define __POLE_H_\n\ntemplate<typename T>\nclass Pole\n{\nprivate:\n\tT * pole;\n\tint pocet_prvku;\n\tint velikost_pole;\npublic:\n\tPole(int velikost = 8);\n\t~Pole();\n\tPole(const Pole& p);\n\tPole& operator = (const Pole& s);\n\ttemplate<int ZVETSENI = 2>\n\tvoid vlozNakonec(T prvek);\n\tT& operator [](int index);\n\tconst T& operator [](int index) const;\n\tint velikost() const;\n\tvoid smazNaPozici(int index);\n};\n\ntemplate<typename T>\nPole<T>::Pole(int velikost) : pocet_prvku(0), velikost_pole(velikost)\n{\n\tthis->pole = new T[velikost];\n}\n\ntemplate<typename T>\nPole<T>::~Pole()\n{\n\tdelete[] this->pole;\n}\n\ntemplate<typename T>\nPole<T>::Pole(const Pole<T> & p) : pole(NULL)\n{\n\t*this = p;\n}\n\ntemplate<typename T>\nPole<T> & Pole<T>::operator=(const Pole<T> & s)\n{\n\tif (this == &s)\n\t\treturn *this;\n\tthis->~Pole();\n\tthis->pole = new T[s.pocet_prvku];\n\tfor (int i = 0; i < s.pocet_prvku; i++)\n\t\tthis->pole[i] = s->pole[i];\n\tthis->pocet_prvku = s.pocet_prvku;\n\tthis->velikost_pole = this->pocet_prvku;\n\treturn *this;\n}\n\n// ...zbytek implementace\ntemplate<typename T>\nT & Pole<T>::operator[](int index)\n{\n\tif (index < 0 || index >= this->pocet_prvku)\n\t\tindex = 0; //Nahradime pozdeji necim jinym\n\treturn this->pole[index];\n}\n\ntemplate<typename T>\nconst T & Pole<T>::operator[](int index) const\n{\n\tif (index < 0 || index >= this->pocet_prvku)\n\t\tindex = 0; //Nahradime pozdeji necim jinym\n\treturn this->pole[index];\n}\n\ntemplate<typename T>\nint Pole<T>::velikost() const\n{\n\treturn this->pocet_prvku;\n}\n\ntemplate<typename T>\ninline void Pole<T>::smazNaPozici(int index)\n{\n\tif (index >= this->velikost())\n\t\treturn;\n\n\tfor (int i = 0; i < this->velikost() - index; i++)\n\t\tthis->pole[index + i] = this->pole[index + i + 1];\n\n\tthis->pocet_prvku--;\n}\n\n\ntemplate<typename T>\ntemplate<int ZVETSENI>\nvoid Pole<T>::vlozNakonec(T prvek)\n{\n\tif (this->velikost_pole == this->pocet_prvku)\n\t{\n\t\tthis->velikost_pole = this->velikost_pole * ZVETSENI;\n\t\tT* vytvoreno = new T[this->velikost_pole];\n\t\tfor (int i = 0; i<this->pocet_prvku; i++)\n\t\t\tvytvoreno[i] = this->pole[i];\n\t\tdelete[] this->pole;\n\t\tthis->pole = vytvoreno;\n\t}\n\tthis->pole[pocet_prvku] = prvek;\n\tpocet_prvku++;\n}\n\n#endif\n\n#ifndef __FRONTA_H_\n#define __FRONTA_H_\n#include <exception>\n#include \"Pole.h\"\n\ntemplate<typename T>\nclass Fronta\n{\nprivate:\n\tPole<T> pole;\npublic:\n\tvoid vloz(T prvek);\n\tT odeber();\n\tbool jePrazdna() const;\n};\n\n\ntemplate<typename T>\ninline void Fronta<T>::vloz(T prvek)\n{\n\tpole.vlozNakonec(prvek);\n}\n\ntemplate<typename T>\ninline T Fronta<T>::odeber()\n{\n\tif (this->jePrazdna())\n\t\tthrow exception(\"Fronta je prazdna\");\n\n\tT prvek = this->pole[0];\n\tthis->pole.smazNaPozici(0);\n\treturn prvek;\n}\n\ntemplate<typename T>\ninline bool Fronta<T>::jePrazdna() const\n{\n\treturn pole.velikost() == 0;\n}\n\n#endif\n\n#include <iostream>\n#include <exception>\n#include \"Fronta.h\"\n\nusing namespace std;\n\nint main()\n{\n\tFronta<int> f;\n\n\tfor (int i = 0; i < 10; i++)\n\t\tf.vloz(i * 3);\n\n\ttry \n\t{\n\t\twhile (true)\n\t\t\tcout << f.odeber() << endl;\n\t}\n\tcatch (exception ex)\n\t{\n\t\tcout << ex.what() << endl;\n\t}\n\n\n\tcin.get();\n\treturn 0;\n}\n\n\n"
        }
      ],
      "id": "xZZlVlWJ",
      "createdAt": 1710276494598,
      "updatedAt": 1710705053562
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": "V pokročilém příkladu naimplementujte jednoduchou maticovou kalkulačku. Matice je několik čísel, uspořádaných do obdélníkového tvaru. Sčítání a odčítání matic funguje po jednotlivých prvcích (tj. prvky na stejném indexu se sečtou, resp. odečtou). Násobení matic je o něco\nkomplikovanější a namísto dlouhého vysvětlování se doporučuji podívat na wikipedii.\n\n\n\n\n\nPro všechny tyto operace musí být matice ve správném tvaru. To znamená,\nže nejde sečíst matici 2x2 s maticí 3x3 a podobně. Obdobné podmínky\nexistují i pro násobení. Váš program takové situace detekuje a v\npřípadě nevyhovujících matic vyvolá výjimku.",
      "name": "Exception 3",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef __MATICE_H_\n#define __MATICE_H_\n#include <ostream>\n\nclass Matice\n{\n\tdouble * matice;\n\tint vyska;\n\tint sirka;\npublic:\n\tMatice(double * hodnoty, int vyska, int sirka);\n\tMatice(const Matice& druhy);\n\t~Matice();\n\tdouble at(int y, int x) const;\n\n\tint ziskejVysku() const;\n\tint ziskejSirku() const;\n\n\tMatice operator+(const Matice& druhy) const;\n\tMatice operator-(const Matice& druhy) const;\n\tMatice operator-() const;\n\tMatice operator*(const Matice& druhy) const;\n};\n\n\nstd::ostream& operator<<(std::ostream& str, const Matice & matice);\n#endif\n\n#include \"Matice.h\"\n#include <cstdlib>\n#include <iostream>\n#include <exception>\n\nusing namespace std;\n\nMatice::Matice(double * hodnoty, int vyska, int sirka) : matice(NULL), vyska(vyska), sirka(sirka)\n{\n\tthis->matice = new double[vyska*sirka];\n\n\tfor (int i = 0; i < vyska*sirka; i++)\n\t\tthis->matice[i] = hodnoty[i];\n}\n\nMatice::Matice(const Matice & druhy) : Matice(druhy.matice, druhy.vyska, druhy.sirka)\n{\n}\n\nMatice::~Matice()\n{\n\tdelete[] this->matice;\n}\n\ndouble Matice::at(int y, int x) const\n{\n\treturn this->matice[y*sirka + x];\n}\n\nint Matice::ziskejVysku() const\n{\n\treturn this->vyska;\n}\n\nint Matice::ziskejSirku() const\n{\n\treturn this->sirka;\n}\n\nMatice Matice::operator+(const Matice & druhy) const\n{\n\tif (this->sirka != druhy.sirka || this->vyska != druhy.vyska)\n\t\tthrow std::exception(\"Spatna velikost matic\");\n\n\tdouble* poleSectene = new double[druhy.vyska * druhy.sirka];\n\n\tfor (int i = 0; i < druhy.vyska * druhy.sirka; i++)\n\t\tpoleSectene[i] = this->matice[i] + druhy.matice[i];\n\n\tMatice sectena(poleSectene, druhy.vyska, druhy.sirka);\n\n\tdelete[] poleSectene;\n\n\treturn sectena;\n}\n\nMatice Matice::operator-(const Matice & druhy) const\n{\n\treturn *this + (-druhy);\n}\n\nMatice Matice::operator*(const Matice & druhy) const\n{\n\tif (this->sirka != druhy.vyska)\n\t\tthrow std::exception(\"Spatna velikost matic\");\n\n\tint sirka = druhy.sirka;\n\tint vyska = this->vyska;\n\tdouble* poleVynasobene = new double[sirka * vyska];\n\n\tfor(int i=0;i<vyska;i++)\n\t\tfor (int j = 0; j < sirka; j++)\n\t\t{\n\t\t\tpoleVynasobene[i * sirka + j] = 0;\n\t\t\tfor (int k = 0; k < this->sirka; k++)\n\t\t\t\tpoleVynasobene[i * sirka + j] += this->at(i, k) * druhy.at(k, j);\n\t\t}\n\n\tMatice vynasobena(poleVynasobene, vyska, sirka);\n\n\tdelete[] poleVynasobene;\n\n\treturn vynasobena;\n}\n\nMatice Matice::operator-() const\n{\n\tMatice minusova(this->matice, this->vyska, this->sirka);\n\n\tfor (int i = 0; i < this->vyska * this->sirka; i++)\n\t\tminusova.matice[i] = (-minusova.matice[i]);\n\n\treturn minusova;\n}\n\nstd::ostream & operator<<(std::ostream & str, const Matice & matice)\n{\n\tfor (int i = 0; i < matice.ziskejVysku(); i++)\n\t{\n\t\tfor (int j = 0; j < matice.ziskejSirku(); j++)\n\t\t\tstr << matice.at(i, j) << \" \";\n\t\tstr << endl;\n\t}\n\treturn str;\n}\n\n#include <iostream>\n#include \"Matice.h\"\n\nusing namespace std;\n\nint main()\n{\n\tdouble aPole[4] = { 1,1,1,0 };\n\tMatice a(aPole, 2, 2);\n\n\tdouble bPole[6] = { 1,2,3,4,5,6 };\n\tdouble cPole[6] = { 1,2,3,4,5,6 };\n\tMatice b(bPole, 2, 3);\n\tMatice c(cPole, 3, 2);\n\n\tcout << b * c << endl;\n\tcout << a + a << endl;\n\tcout << a * a * a << endl;\n\n\ttry\n\t{\n\t\tcout << a + b << endl;\n\t}\n\tcatch (exception e)\n\t{\n\t\tcout << e.what() << endl;\n\t}\n\n\tcin.get();\n\treturn 0;\n}\n"
        }
      ],
      "id": "2Ebzr3Ce",
      "createdAt": 1710276744306,
      "updatedAt": 1710705053532
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Faktorial 1",
      "content": [
        {
          "label": "Faktorial 1",
          "language": "c_cpp",
          "value": "#ifndef __FUNKCE_H__\n#define __FUNKCE_H__\n\nnamespace piskvorky_sw\n{\n\tint faktorial(int m);\n\tint faktorial_rekurzivni(int m);\n\tbool vstup();\n\tbool kontrola();\n\tvoid napoveda();\n\n\textern int n;\n}\n#endif\n\n#include <iostream>\n#include \"funkce.h\"\n\nnamespace piskvorky_sw\n{\n\tusing namespace std;\n\n\tconst int horni_mez_vstupu{ 12 };\n\tconst int dolni_mez_vstupu{ 0 };\n\n\tint n;\n\n\tint hodnota_faktorialu[horni_mez_vstupu + 1]{ 1 };\n\n\tvoid faktorial_priprava()\n\t{\n\t\tint i = 1;\n\t\twhile (i <= horni_mez_vstupu)\n\t\t{\n\t\t\thodnota_faktorialu[i] = i*hodnota_faktorialu[i - 1];\n\t\t\ti++;\n\t\t}\n\t}\n\n\tint faktorial(int n)\n\t{\n\t\tif (hodnota_faktorialu[1] == 0)\n\t\t{\n\t\t\tfaktorial_priprava();\n\t\t}\n\t\treturn hodnota_faktorialu[n];\n\t}\n\n\tbool vstup()\n\t{\n\t\tcout << \"Zadej celé číslo: \";\n\t\tcin >> n;\n\t\tif (!cin)\n\t\t{\n\t\t\tcout << \"Zadaná hodnota nepředstavuje číslo\" << endl;\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tint faktorial_rekurzivni(int m)\n\t{\n\t\tif (m == 0)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn m * faktorial_rekurzivni(m - 1);\n\t\t}\n\t}\n\n\tbool kontrola()\n\t{\n\t\treturn (n >= dolni_mez_vstupu) && (n <= horni_mez_vstupu);\n\t}\n\n\tvoid napoveda()\n\t{\n\t\tcout << \"Faktoriál zadané hodnoty nelze spočítat\" << endl;\n\t\tcout << \"Zadaná hodnota musí být celé číslo mezi \"\n\t\t\t<< dolni_mez_vstupu << \" a \" << horni_mez_vstupu << endl;\n\t}\n\n}\n\n#include <iostream>\n#include \"funkce.h\"\n//#include \"konzola.h\" // Jen Windows\n\nusing namespace std;\nusing namespace piskvorky_sw;\n\nint main()\n{\n\t//nastav_konzolu_pro_cp1250(); //Jen Windows\n\tif (vstup() && kontrola())\n\t{\n\t\tcout << \"Jeho faktoriál je \" << faktorial(n) << endl;\n\t\tcout << \"Jeho faktoriál je \" << faktorial_rekurzivni(n) << endl;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tnapoveda();\n\t}\n\treturn 0;\n}\n"
        }
      ],
      "id": "HmAGp6Hk",
      "createdAt": 1710277452679,
      "updatedAt": 1710704974247
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Sablona Max",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\n\ntemplate<typename T>\nT max(T a, T b)\n{\n    return a > b ? a : b;\n}\n\nint main()\n{\n    std::cout << \"Zadej dvě celá čísla: \";\n    int m, n;\n    std::cin >> m >> n;\n    std::cout << \"Větší je \" << max(m, n) << std::endl;\n    double x, y = 6.8;\n    x = max(y, 3.14);\n    std::cout << x << std::endl;\n    x = max<double>(3, 9.0);\n    std::cout << x << std::endl;\n    return 0;\n}"
        }
      ],
      "id": "4CG_i5fp",
      "createdAt": 1710277785477,
      "updatedAt": 1710705047789
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Sablona dvojice",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\nusing namespace std;\n\ntemplate<typename T>\nT max(T a, T b)\n{\n    return a > b ? a : b;\n}\n\ntemplate<typename T1, typename T2>\nclass dvojice\n{\npublic:\n    dvojice(T1 _prvni, T2 _druha);\n    dvojice(){}\n    T1 prvni();\n    T2 druha();\n    void prvni(T1 _prvni);\n    void druha(T2 _druha);\nprivate:\n    T1 prvni_slozka;\n    T2 druha_slozka;\n};\n\n\ntemplate<typename T1, typename T2>\ndvojice<T1, T2>::dvojice(T1 _prvni, T2 _druha)\n{\n    prvni(_prvni);\n    druha(_druha);\n}\n\ntemplate<class T1, class T2>\nvoid dvojice<T1, T2>::prvni(T1 _prvni)\n{\n    prvni_slozka = _prvni;\n}\n\ntemplate<class T1, class T2>\nvoid dvojice<T1, T2>::druha(T2 _druha)\n{\n    druha_slozka = _druha;\n}\n\ntemplate<class T1, class T2>\nT1 dvojice<T1, T2>::prvni()\n{\n    return prvni_slozka;\n}\n\ntemplate<class T1, class T2>\nT2 dvojice<T1, T2>::druha()\n{\n    return druha_slozka;\n}\n\n\nint main()\n{\n    dvojice<int, int> dva{};\n    dvojice<string, int> kontakt{\"Josef Novák\", 1234567};\n    cout << kontakt.prvni() << endl;\n    return 0;\n}\n"
        }
      ],
      "id": "fktCLCZw",
      "createdAt": 1710277800806,
      "updatedAt": 1710705047769
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Vector 1",
      "content": [
        {
          "label": "Vector 1",
          "language": "c_cpp",
          "value": "#ifndef __VEKTOR_H__\n#define __VEKTOR_H__\n\n\nconst int dim = 3;\n\nclass vektor\n{\n    double pole[dim];\npublic:\n    vektor(double x = 0, double y = 0, double z = 0);\n    vektor(double pole[]);\n    vektor operator+(vektor w);\n    vektor plus(vektor w);\n    void vypis();\n};\n#endif\n\n#include <iostream>\n#include \"vektor.h\"\nusing namespace std;\n\n\nvektor::vektor(double _pole[])\n{\n    for(int i = 0; i < dim; i++)\n    {\n        pole[i]= _pole[i];\n    }\n}\n\n\nvektor::vektor(double x, double y, double z)\n{\n    pole[0] = x;\n    pole[1] = y;\n    pole[2] = z;\n}\n\nvektor vektor::plus(vektor w)\n{\n    double vysledek[dim];\n    for(int i = 0; i < dim; i++)\n    {\n        vysledek[i] = pole[i] + w.pole[i];\n    }\n    return vysledek;\n}\n\nvektor vektor::operator+(vektor w)\n{\n    double vysledek[dim];\n    for(int i = 0; i < dim; i++)\n    {\n        vysledek[i] = pole[i] + w.pole[i];\n    }\n    return vektor(vysledek);\n}\n\n\nvoid vektor::vypis()\n{\n    for(int i = 0; i < dim; i++)\n    {\n        cout << pole[i] << \" \";\n    }\n    cout << endl;\n}\n\n\n#include <iostream>\n#include \"konzola.h\"\n#include \"vektor.h\"\n\nusing namespace std;\n\n\n\nint main()\n{\n    nastav_konzolu_pro_cp1250();\n    vektor u{1,2,3}, v{3,2,1}, w;\n    w = u.plus(v);\n    w.vypis();\n    w = u + v;\n    w.vypis();\n    return 0;\n}"
        },
        {
          "label": "Vector 2",
          "language": "c_cpp",
          "value": "#ifndef __VEKTOR_H__\n#define __VEKTOR_H__\n\n\nconst int dim = 3;\n\nclass vektor\n{\n    double pole[dim];\npublic:\n    vektor(double x = 0, double y = 0, double z = 0);\n    vektor(double pole[]);\n    vektor plus(vektor w);\n    void vypis();\n};\n\nvektor operator+(vektor u, vektor w);\n\n#endif\n\n#include <iostream>\n#include \"vektor.h\"\nusing namespace std;\n\n\nvektor::vektor(double _pole[])\n{\n    for(int i = 0; i < dim; i++)\n    {\n        pole[i]= _pole[i];\n    }\n}\n\nvektor::vektor(double x, double y, double z)\n{\n    pole[0] = x;\n    pole[1] = y;\n    pole[2] = z;\n}\n\nvektor vektor::plus(vektor w)\n{\n    double vysledek[dim];\n    for(int i = 0; i < dim; i++)\n    {\n        vysledek[i] = pole[i] + w.pole[i];\n    }\n    return vysledek;\n}\n\nvektor operator+(vektor u, vektor w)\n{\n    return u.plus(w);\n}\n\n\nvoid vektor::vypis()\n{\n    for(int i = 0; i < dim; i++)\n    {\n        cout << pole[i] << \" \";\n    }\n    cout << endl;\n}\n\n#include <iostream>\n#include \"konzola.h\"\n#include \"vektor.h\"\n\nusing namespace std;\n\n\n\nint main()\n{\n    nastav_konzolu_pro_cp1250();\n    vektor u{1,2,3}, v{3,2,1}, w;\n    w = u.plus(v);\n    w.vypis();\n    w = u + v;\n    w.vypis();\n    return 0;\n}"
        },
        {
          "label": "Fragment 3",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include \"vektor.h\"\n\nusing namespace std;\n\nint main()\n{\n\tvektor w{ 1,2,3,4,5 };\n\tw.vypis();\n\tvektor x(w);\n\tx.nastav(2, 9);\n\tw.vypis();\n\n\tvektor W{ 1,2,3,4,5 };\n\tvektor X{ 22, 11, 999, 7, 1, 42 };\n\tX = W;\n\tX.nastav(2, 9);\n\tW.vypis();\n\tcout << vektor::pocet_instanci() << endl;\n\treturn 0;\n}\n#include <iostream>\n#include \"vektor.h\"\nusing namespace std;\n\n\nvektor::vektor(int n)\n\t: delka(n), pole(new double[n] {})\n{\n\tpocet++;\n}\n\nint vektor::pocet = 0;\n\nvektor::vektor(initializer_list<double> il)\n\t: vektor(il.size())\n{\n\tint i = 0;\n\tfor (double x : il)\n\t{\n\t\tpole[i++] = x;\n\t}\n}\n\nvektor::vektor()\n\t: delka(0), pole(nullptr)\n{\n\tpocet++;\n}\n\nvektor::vektor(const vektor & w)\n:vektor(w.delka)\n{\n\tfor (int i = 0; i < delka; i++)\n\t{\n\t\tpole[i] = w.pole[i];\n\t}\n}\n\nvektor::~vektor()\n{\n\tdelete[] pole;\n\tpocet--;\n}\n\nvektor & vektor::operator=(vektor & v)\n{\n\tif (v.delka != delka)\n\t{\n\t\tdelka = v.delka;\n\t\tdelete[] pole;\n\t\tpole = new double[delka];\n\t}\n\tfor (int i = 0; i < delka; i++)\n\t{\n\t\tpole[i] = v.pole[i];\n\t}\n\treturn *this;\n}\n\nvoid vektor::nastav(int index, double hodnota)\n{\n\tpole[index] = hodnota;\n}\n\nvoid vektor::vypis()\n{\n\tfor (int i = 0; i < delka; i++)\n\t{\n\t\tcout << pole[i] << \" \";\n\t}\n\tcout << endl;\n}\n\nint vektor::pocet_instanci()\n{\n\treturn pocet;\n}\n#ifndef __VEKTOR_H__\n#define __VEKTOR_H__\n\n#include <initializer_list>\n\nusing namespace std;\n\nclass vektor\n{\n\tint delka;\n\tdouble *pole;\n\tstatic int pocet;\npublic:\n\tvektor(initializer_list<double> il);\n\texplicit vektor(int n);\n\tvektor();\n\tvektor(const vektor& w);\n\tvoid vypis();\n\tvoid nastav(int index, double hodnota);\n\t~vektor();\n\tvektor& operator=(vektor& v);\n\tstatic int pocet_instanci();\n};\n\n#endif"
        },
        {
          "label": "Vector For Each",
          "language": "c_cpp",
          "value": "bool existsInvoicePastDueDate(const vector<Invoice>& invoices) {\n    auto now = chrono::system_clock::now();\n    for (const Invoice& invoice : invoices) {\n        if (invoice.dueDate > now)\n            return true;\n    }\n    return false;\n}"
        },
        {
          "label": "Vector Kolekce",
          "language": "c_cpp",
          "value": "vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n// Odstraní všechna lichá čísla\nnumbers.erase(remove_if(numbers.begin(), numbers.end(), [](int number) {\n    return number % 2 != 0;\n}), numbers.end());"
        }
      ],
      "id": "UImMwiFi",
      "createdAt": 1710277842191,
      "updatedAt": 1710915433599
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Na velka",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\nusing namespace std;\n\nchar na_velka(char c)\n{\n\tif ((c >= 'a') && (c <= 'z'))\n\t{\n\t\tc = c - 'a' + 'A';\n\t}\n\treturn c;\n}\n\nint main()\n{\n\tchar z1 = 'f', z2 = 'G', z3 = 'ž', z4 = '1';\n\tcout << z3 << endl;\n\tcout << na_velka(z1) << \" \" << na_velka(z2) << \" \"\n\t     << na_velka(z3) << \" \" << na_velka(z4) << endl;\n\treturn 0;\n}"
        }
      ],
      "id": "7GwseSe_",
      "createdAt": 1710277918378,
      "updatedAt": 1710704981066
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Zaokrouhleni",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <limits>\n// #include \"konzola.h\" // Pro Windows\n\nusing namespace std;\n\nint main()\n{\n\t// nastav_konzolu_pro_cp1250(); // Pro Windows\n\tcout << \"Výpis čísel od 0 do 0,9 po jedné desetině: \" << endl;\n\tconst double delta = 0.1;\n\tdouble x = 0.0;\n\twhile (x < 1/* - numeric_limits<double>::epsilon()*/)\n\t{\n\t\tcout << x << endl;\n\t\tx += delta;\n\t}\n}"
        }
      ],
      "id": "I5xNsRJG",
      "createdAt": 1710277933172,
      "updatedAt": 1710704974217
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Binar Binarizuj",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\n\nstring binarizuj(int m)\n{\n\tif (m == 0)\n\t{\n\t\treturn \"0\";\n\t}\n\tstring vysledek;\n\tbool zaporne = m < 0;\n\tm = abs(m);\n\tchar znak[2]{ '0', '1' };\n\twhile (m)\n\t{\n\t\tvysledek = znak[m % 2] + vysledek;\n\t\tm /= 2;\n\t}\n\tif (zaporne)\n\t{\n\t\tvysledek = '-' + vysledek;\n\t}\n\treturn vysledek;\n}\n\nint main()\n{\n\tcout << binarizuj(-65535) << endl;\n}\n"
        }
      ],
      "id": "QghlOZ20",
      "createdAt": 1710277953872,
      "updatedAt": 1710704974202
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Plocha trojuhelnika",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <math.h>\n//#include \"konzola.h\" // Pro Windows\nusing namespace std;\n\n\nclass bod\n{\npublic:\n\tdouble x, y;\n\tbod(double _x, double _y)\n\t{\n\t\tx = _x; y = _y;\n\t}\n};\n\ndouble sqr(double x)\n{\n\treturn x*x;\n}\n\ndouble vzdalenost(bod A, bod B)\n{\n\treturn sqrt(sqr(A.x - B.x) + sqr(A.y + B.y));\n}\n\ndouble plocha_trojuhelnika(bod A, bod B, bod C)\n{\n\tdouble a = vzdalenost(A, B);\n\tdouble b = vzdalenost(B, C);\n\tdouble c = vzdalenost(C, A);\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\nint main()\n{\n\t//nastav_konzolu_pro_cp1250(); // Pro Windows\n\tbod A{ 0,0 }, B{ 0,1 }, C{ 1,0 };\n\tcout << \"Plocha daného trojúhelníka je \" << plocha_trojuhelnika(A, B, C) << endl;\n\treturn 0;\n}"
        }
      ],
      "id": "lG50KZ2Y",
      "createdAt": 1710278052985,
      "updatedAt": 1710704974170
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "For container kontejner",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include \"konzola.h\" // Jen Windows\n\nusing namespace std;\n\nint main()\n{\n\tconst int N = 10;\n\tint A[N]{ 1,2,3,4,5,6,7,8,9,10 };\n\tfor (int i : A)\n\t{\n\t\tcout << i << \" \";\n\t}\n\tcout << endl;\n\tfor (int &i : A)\n\t{\n\t\ti++;\n\t}\n\tfor (int i : A)\n\t{\n\t\tcout << i << \" \";\n\t}\n\tcout << endl;\n}"
        }
      ],
      "id": "JR6ad66u",
      "createdAt": 1710278101676,
      "updatedAt": 1710704987772
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "otoc swap",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string.h>\n#include \"konzola.h\" // Jen Windows\nusing namespace std;\n\nchar *otoc(char *zadano, char* otoceno)\n{\n\tsize_t delka = strlen(zadano);\n\tfor (size_t i = 0, j = delka - 1; i < delka; i++, j--)\n\t{\n\t\totoceno[j] = zadano[i];\n\t}\n\totoceno[delka] = 0;\n\treturn otoceno;\n}\n\n\n\nint main()\n{\n\tnastav_konzolu_pro_cp1250();\n\tchar text[] = \"Nazdar\";\n\tchar otoceny[100];\n\tcout << \"P�vodn� text: \" << text << endl;\n\tcout << \"Oto�en� text: \" << otoc(text, otoceny) << endl;\n}"
        }
      ],
      "id": "lVjpW_jp",
      "createdAt": 1710278271485,
      "updatedAt": 1710704981036
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Adresova aritmetika Otoc",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include \"konzola.h\" // Jen Windows\nusing namespace std;\n\nsize_t delka(char *text)\n{\n\tchar *pom = text;\n\twhile (*pom++)\n\t\t;\n\treturn pom - text - 1;\n}\n\nsize_t delka3(char* txt)\n{\n\tchar *pom; \n\tfor (pom = txt; *pom; pom++)\n\t\t;\n\treturn pom - txt;\n}\n\nchar *otoc_na_miste(char * txt)\n{\n\tfor (char *p = txt, *q = p + (strlen(txt) - 1); p < q; p++, q--)\n\t{\n\t\tchar pom = *p;\n\t\t*p = *q;\n\t\t*q = pom;\n\t}\n\treturn txt;\n}\n\nint main()\n{\n\tnastav_konzolu_pro_cp1250();\n\tchar text[] = \"nazdar\";\n\tcout << delka3(text) << endl;\n\tcout << otoc_na_miste(text) << endl;\n}"
        }
      ],
      "id": "r3bt2x49",
      "createdAt": 1710278310632,
      "updatedAt": 1710278350431
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Adresova aritmetika Prohozeni R",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\n//#include \"konzola.h\" // Jen Windows\nusing namespace std;\n\nvoid prohod(int *a, int *b)\n{\n\tint c = *a;\n\t*a = *b;\n\t*b = c;\n}\n\nvoid prohod_n(int a, int b)\n{\n\tint c = a;\n\ta = b;\n\tb = c;\n}\n\nvoid prohod_r(int &a, int &b)\n{\n\tint c = a;\n\ta = b;\n\tb = c;\n}\n\n\nvoid vypis(string text, int a, int b)\n{\n\tcout << text;\n\tcout << \" a = \" << a << \", b = \" << b << endl;\n}\n\n\nint main()\n{\n\t//nastav_konzolu_pro_cp1250();\n\tint a = 7, b = 9;\n\tvypis(\"Na po��tku: \", a, b);\n\tprohod_n(a, b);\n\tvypis(\"Po vol�n� prohod_n(): \", a, b);\n\tprohod(&a, &b);\n\tvypis(\"Po vol�n� prohod():\", a, b);\n\tprohod_r(a, b);\n\tvypis(\"Po vol�n� prohod_r():\", a, b);\n}"
        }
      ],
      "id": "-7WsUDVg",
      "createdAt": 1710278352105,
      "updatedAt": 1710278429529
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "reference r hodnotu",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\nvoid f(int &n)\n{\n\tcout << \"&\" << n << endl;\n}\n\nvoid f(int &&n)\n{\n\tcout << \"&&\" << n << endl;\n}\n\nint main()\n{\n\tint i = 8;\n\tf(i);\n\tf(+i);\n\tf(move(i));\n}\n"
        }
      ],
      "id": "j-KlFJ7T",
      "createdAt": 1710278408567,
      "updatedAt": 1710278418835
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Dnes je zavrano enum",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include \"konzola.h\" // Jen Windows\n#include <math.h>\n\nusing namespace std;\n\nenum den { pondeli = 1, utery = 2, streda = 4, ctvrtek = 8,\n           patek = 16, sobota = 32, nedele = 64 };\n\n\nint main()\n{\n\tnastav_konzolu_pro_cp1250();  // jen Windows\n\tden zavreno = (den)(pondeli | patek);\n\tden dnes = utery;\n\tcout << \"Dnes je \" << ((dnes & zavreno) ? \"zav�eno\" : \"otev�eno\")  << endl;\n}\n"
        }
      ],
      "id": "odbuIg23",
      "createdAt": 1710278613526,
      "updatedAt": 1710705059390
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Kontakt enum",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\n\nusing namespace std;\n\nenum class typ_kontaktu {soukromy, pracovni, jiny};\n\nstruct kontakt\n{\n\tint id;\n\tchar jmeno[30];\n\tchar prijmeni[30];\n\tchar telefon[20];\n\ttyp_kontaktu typ;\n};\n\nchar typy[][10]{ \"soukromý\", \"pracovní\", \"jiný\" };\n\nvoid vypis(const kontakt *pk)\n{\n\tcout << pk->id << \": \" << pk->jmeno << \" \" << pk->prijmeni << \" (tel. \" << pk->telefon << \", \" << typy[(int)(pk->typ)] << \")\" << endl;\n}\n\n\nint main()\n{\n\tkontakt k1 = { 1, \"Ivo\", \"Klepáč\", \"321 543 765\", typ_kontaktu::pracovni };\n\tkontakt *pk = new kontakt{ 1, \"Ivo\", \"Klepáč\", \"321 543 765\", typ_kontaktu::pracovni };\n\n\tkontakt k2 = { 2, \"Jan\", \"Brhel\", \"436 761 989\", typ_kontaktu::soukromy };\n\tvypis(&k2);\n\tk2.prijmeni[3] = 'a';\n\tvypis(&k2);\n}"
        }
      ],
      "id": "yAITgzCc",
      "createdAt": 1710278660441,
      "updatedAt": 1710705059369
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Endian",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <stdint.h>\n#include \"konzola.h\"  // Jen Windows\n\nusing namespace std;\n\nunion dekoder\n{\n\tuint32_t cislo;\n\tuint8_t bajty[4];\n};\n\n\nint main()\n{\n\tnastav_konzolu_pro_cp1250();  // Jen Windows\n\tdekoder info{ 0x12345678 };\n\tif (info.bajty[0] == 0x12)\n\t{\n\t\tcout << \"Velký endián\" << endl;\n\t}\n\telse if(info.bajty[0] == 0x78)\n\t{\n\t\tcout << \"Malý endián\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Tohle by nemělo nastat nikdy\" << endl;\n\t}\n}\n\n#include <iostream>\n#include <stdint.h>\n#include \"konzola.h\"\n\nusing namespace std;\n\nint main()\n{\n\tnastav_konzolu_pro_cp1250();\n\tunion\n\t{\n\t\tuint32_t cislo;\n\t\tuint8_t bajty[4];\n\t};\n\tcislo =  0x12345678 ;\n\tif (bajty[0] == 0x12)\n\t{\n\t\tcout << \"Velký endián\" << endl;\n\t}\n\telse if(bajty[0] == 0x78)\n\t{\n\t\tcout << \"Malý endián\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Tohle by nemělo nastat nikdy\" << endl;\n\t}\n}"
        }
      ],
      "id": "s1Kt4LUK",
      "createdAt": 1710278708155,
      "updatedAt": 1710704987742
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Zastínění funkcí Shadowing",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\nint pomoc()                                          // 1\n{\n    cout << \"pomocná funkce\" << endl;\n    return 6;\n}\n\nint main()                                           // 2\n{\n\tint i = pomoc(), pomoc = 86;                   // 3\n\tcout << pomoc << \"  \" << ::pomoc() << endl;    // 4\n\t{                                              // 5\n\t    int i = pomoc;                             // 6 \n\t    int pomoc = 97;                            // 7 \n\t    cout << pomoc << \"  \" << ::pomoc() << endl;// 8\n\t}                                              // 9\n\tcout << pomoc << endl;                         // 10\n}                                                    \n"
        }
      ],
      "id": "qjAxQ3Qm",
      "createdAt": 1710278817200,
      "updatedAt": 1710925126858
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Nepojmenovaný snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\nvoid sledovano()\n{\n\tstatic int pocet = 1;\n\tcout << \"Vol�n� �. \" << pocet++ << endl;\n\t// ... a dal�� p��kazy ve funkci sledovano()\n}\n\nint main()\n{\n\tsledovano(); // Vyp�e 1\n\tsledovano(); // vyp�e 2\n}"
        }
      ],
      "id": "jBoXhv_M",
      "createdAt": 1710279662913,
      "updatedAt": 1710705065030
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "0RzxMo7F",
      "tagsIds": [],
      "description": null,
      "name": "Convert Ansi files to UTF8 in recurse",
      "content": [
        {
          "label": "Fragment 1",
          "language": "powershell",
          "value": "Get-ChildItem \"c:\\Projects\\_CppProjects\\zdrojarna\\knihovnaProgramatora\\_utf\\\" -Filter *.* -Recurse | \n    ForEach-Object {\n        Write-Host (Get-Date).ToString() $_.FullName\n        $newFileName = \"{0}utf8{1}\" -f $_.BaseName, $_.Extension\n        $newFilePath = Join-Path $_.DirectoryName $newFileName\n        Get-Content $_.FullName | Set-Content -Encoding utf8 -Path $newFilePath\n    }\n"
        }
      ],
      "id": "E4ysJN2z",
      "createdAt": 1710279734512,
      "updatedAt": 1710916985520
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "constexpr",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Ve specifikaci rozsahu – tedy počtu prvků – pole, jako jsou skutečné parametry šablon, v návěštích case příkazu switch, ve výrazu uvedeném v příkazu static_assert a v některých dalších situacích vyžaduje jazyk C++ výraz, který představuje celočíselnou konstantu. Celočíselný konstantní výraz smí obsahovat pouze celočíselné literály, výčtové konstanty, proměnné deklarované s modifikátorem const a inicializované konstantním výrazem, proměnné deklarované s modifikátorem constexpr a hodnoty získané pomocí operátoru sizeof. Smíme tam také použít volání funkce deklarované s modifikátorem constexpr a vracející celočíselnou hodnotu, jestliže ji voláme se skutečným parametrem představovaným konstantním výrazem\n\n#include <iostream>\nusing namespace std;\n\nconstexpr int moc3(int n)\n{\n    return n*n*n;\n}\n\nint main()\n{\n    int A[moc3(2)]{1,2,3,4,5,6,7,8};  // Pole o 8 prvcích\n    for(int i: A)\n    {\n        cout << i << \" \";\n    }\n}"
        }
      ],
      "id": "MaMwvxG3",
      "createdAt": 1710280037087,
      "updatedAt": 1710916949743
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "main params print",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include \"konzola.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[], char* env[])\n{\n    cout << \"Parametry příkazové řádky programu při spuštění: \" << endl;\n    for(int i = 0; i < argc; i++)\n    {\n        cout << argv[i] << endl;\n    }\n    return 0;\n}\n\n\n"
        },
        {
          "label": "Ziskani 1. parametru",
          "language": "c_cpp",
          "value": "\ntry\n    {\n        if (argc == 2)\n        {\n            if (argv[1][0] == 's')\n                isServer = true;\n        }\n    }\n    catch(exception &e) {};\n"
        }
      ],
      "id": "USAWJcYc",
      "createdAt": 1710280231977,
      "updatedAt": 1710704996032
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "env variables",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <stdlib.h>\n#include \"konzola.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[], char* env[])\n{\n    nastav_konzolu_pro_cp1250();\n    cout << \"Obsah systémové proměnné PATH:\" << endl;\n    cout << getenv(\"PATH\") << endl;\n\n    cout << \"Aktuální systémové proměnné: \" << endl;\n\n    for(int i = 0; env[i]; i++)\n    {\n        cout << env[i] << endl;\n    }\n}\n"
        }
      ],
      "id": "7lhSwVAb",
      "createdAt": 1710280263679,
      "updatedAt": 1710704996126
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "atexit",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\nvoid fce1()\n{\n    cout << \"fce1\" << endl;\n}\n\nvoid fce2()\n{\n    cout << \"fce2\" << endl;\n}\n\nint main(int argc, char *argv[], char* env[])\n{\n    atexit(fce1);\n    atexit(fce2);\n    cout << \"program\" << endl;\n}\n\n\nTento program obsahuje dvě funkce typu void bez parametrů. Ve funkci main() je obě zaregistrujeme pomocí \nfunkce atexit(), pak vypíšeme zprávu askončíme. Výstup tohoto programu bude:\nprogram\nfce2\nfce1\nProgram po ukončení funkce main() provedl obě zaregistrované funkce."
        }
      ],
      "id": "rBaA7zB9",
      "createdAt": 1710280376574,
      "updatedAt": 1710705065003
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Makra Makro",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <stdlib.h>\n\n\n#define N 10\n#define SQR(x) ((x)*(x))\n\nusing namespace std;\n\n#if defined LADIM\n#define TISK(x) cout << #x << \" = \" << x << endl\n#else\n#define TISK(x) void(0)\n#endif\n\n\nint main(int argc, char *argv[], char* env[])\n{\n    int A[N]{1,3,6,8,2}; // Použití manifestační konstanty\n    for(int j = 0; j < N; j++)\n    {\n        cout << A[j] << \" \" ;\n    }\n    cout << endl;\n    int i = 8;\n    TISK(i);\n\tdouble x = 8.1;\n\tTISK(x);\n\tcout << SQR(x + 1) << endl;\n}\n\n#define N 10\n#define SQR(x) ((x)*(x))\n\nusing namespace std;\n\n#define TISK(x) cout << #x << \" = \" << x << endl\n//#define TISK(x) void(0)\n\nint main(int argc, char *argv[], char* env[])\n{\n    int A[N]{1,3,6,8,2}; // Použití manifestační konstanty\n    for(int j = 0; j < N; j++)\n    {\n        cout << A[j] << \" \" ;\n    }\n    cout << endl;\n    int i = 8;\n    TISK(i);\n    double x = 8.1;\n    TISK(x);\n    cout << SQR(x + 1) << endl;\n}"
        }
      ],
      "id": "p9mBV9dq",
      "createdAt": 1710280434014,
      "updatedAt": 1710704981002
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Safe numeric operations Bezpecne operace s cisly",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <stdexcept>\n#include <limits>\n#include <stdlib.h>\n\nusing namespace std;\n\nint bezpecny_soucet(int a, int b)\n{\n\tif ((a > 0) && (b > numeric_limits<int>::max() - a))\n\t{\n\t\tthrow overflow_error(\"Výsledek sčítání > INT_MAX\");\n\t}\n\tif ((a < 0) && (b < numeric_limits<int>::min() + a))\n\t{\n\t\tthrow overflow_error(\"Výsledek sčítání < INT_MIN\");\n\t}\n\treturn a + b;\n}\n\nint bezpecny_rozdil(int a, int b)\n{\n\tif ((b < 0) && (a > numeric_limits<int>::max() + b))\n\t{\n\t\tthrow overflow_error(\"Výsledek odešítání > INT_MAX\");\n\t}\n\tif ((b > 0) && (a < numeric_limits<int>::min() + b))\n\t{\n\t\tthrow overflow_error(\"Výsledek odečítání < INT_MIN\");\n\t}\n\treturn a - b;\n}\n\nint bezpecny_soucin(int a, int b)\n{\n\tif (b == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (a > numeric_limits<int>::max() / b)\n\t{\n\t\tthrow overflow_error(\"Výsledek násobení > INT_MAX\");\n\t}\n\tif (a < numeric_limits<int>::min() / b)\n\t{\n\t\tthrow overflow_error(\"Výsledek < INT_MIN\");\n\t}\n\treturn a * b;\n}\n\nint bezpecny_podil(int a, int b)\n{\n\tif (b == 0)\n\t{\n\t\tthrow domain_error(\"Dělení nulou\");\n\t}\n\tif ((a == numeric_limits<int>::min()) && (b == -1))\n\t{\n\t\tthrow overflow_error(\"Výsledek dělení mimo rozsah\");\n\t}\n\treturn a / b;\n}\n\n\nint max = numeric_limits<int>::max();\nint min = numeric_limits<int>::min();\n\nvoid bezpecny_vypis(int a, int b, int(*operace)(int, int))\n{\n\ttry\n\t{\n\t\tcout << operace(a, b) << endl;\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tcout << e.what() << endl;\n\t}\n}\n\nint main()\n{\n\tsystem(\"CHCP 1250 > NUL\");\n\tfor (int i = -1; i < 2; i++)\n\t{\n\t\tcout << max << \" + \" << i << \" = \";\n\t\tbezpecny_vypis(max, i, bezpecny_soucet);\n\t\tcout << min << \" - \" << i << \" = \";\n\t\tbezpecny_vypis(min, i, bezpecny_rozdil);\n\t\tcout << max << \" * \" << i << \" = \";\n\t\tbezpecny_vypis(max, i, bezpecny_soucin);\n\t\tcout << min << \" / \" << i << \" = \";\n\t\tbezpecny_vypis(min, i, bezpecny_podil);\n\t}\n\t\n}"
        },
        {
          "label": "Fragment 2",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <iomanip>\n#include <stdexcept>\n#include <limits>\n#include <stdlib.h>\n\nusing namespace std;\n\nint bezpecny_soucet(int a, int b)\n{\n\tif ((a > 0) && (b > numeric_limits<int>::max() - a))\n\t{\n\t\tthrow overflow_error(\"Výsledek sčítání > INT_MAX\");\n\t}\n\tif ((a < 0) && (b < numeric_limits<int>::min() + a))\n\t{\n\t\tthrow overflow_error(\"Výsledek sčítání < INT_MIN\");\n\t}\n\treturn a + b;\n}\n\nint bezpecny_rozdil(int a, int b)\n{\n\tif ((b < 0) && (a > numeric_limits<int>::max() + b))\n\t{\n\t\tthrow overflow_error(\"Výsledek odešítání > INT_MAX\");\n\t}\n\tif ((b > 0) && (a < numeric_limits<int>::min() + b))\n\t{\n\t\tthrow overflow_error(\"Výsledek odečítání < INT_MIN\");\n\t}\n\treturn a - b;\n}\n\nint bezpecny_soucin(int a, int b)\n{\n\tif (b == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (a > numeric_limits<int>::max() / b)\n\t{\n\t\tthrow overflow_error(\"Výsledek násobení > INT_MAX\");\n\t}\n\tif (a < numeric_limits<int>::min() / b)\n\t{\n\t\tthrow overflow_error(\"Výsledek < INT_MIN\");\n\t}\n\treturn a * b;\n}\n\nint bezpecny_podil(int a, int b)\n{\n\tif (b == 0)\n\t{\n\t\tthrow domain_error(\"Dělení nulou\");\n\t}\n\tif ((a == numeric_limits<int>::min()) && (b == -1))\n\t{\n\t\tthrow overflow_error(\"Výsledek dělení mimo rozsah\");\n\t}\n\treturn a / b;\n}\n\n\nint max = numeric_limits<int>::max();\nint min = numeric_limits<int>::min();\n\nvoid bezpecny_vypis(int a, int b, int(*operace)(int, int))\n{\n\ttry\n\t{\n\t\tcout << operace(a, b) << endl;\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tcout << e.what() << endl;\n\t}\n}\n\nint faktorial(int n)\n{\n\tif (n < 0)\n\t{\n\t\tthrow invalid_argument(\"Záporný parametr faktoriálu\");\n\t}\n\tint vysledek = 1;\n\twhile (n > 1)\n\t{\n\t\tvysledek = bezpecny_soucin(n, vysledek);\n\t\tn--;\n\t}\n\treturn vysledek;\n}\n\nvoid vypis(int od, int po)\n{\n\tfor (int i = od; i < po + 1; i++)\n\t{\n\t\ttry {\n\t\t\tcout << setw(3) << i << \": \";\n\t\t\tcout << setw(11) << faktorial(i);\n\t\t\tcout << \";\" << endl;\n\t\t}\n\t\tcatch (exception &e)\n\t\t{\n\t\t\tcout << e.what() << endl;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tsystem(\"CHCP 1250 > NUL\");\n\tvypis(-1, 13);\n}\n"
        }
      ],
      "id": "LJF_g2hv",
      "createdAt": 1710280730256,
      "updatedAt": 1710704974097
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Read Write File",
      "content": [
        {
          "label": "FILE fwrite fread",
          "language": "c_cpp",
          "value": "#define  _CRT_SECURE_NO_WARNINGS // pro Visual C++\n#include <iostream>\n#include <stdio.h>\n#include <stdexcept>\n\n\nusing namespace std;\n\nvoid kontrola(FILE *proud, char *jmeno)\n{\n\tif (!proud)\n\t{\n\t\tthrow runtime_error(string(\"Nepodařilo se otevřít soubor \") + jmeno);\n\t}\n}\n\nvoid zapis(char *jmeno)\n{\n\tFILE *proud = fopen(jmeno, \"wb\");\n\tkontrola(proud, jmeno);\n\tfor (int i = 1; i <= 10; i++)\n\t{\n\t\tfwrite(&i, sizeof(i), 1, proud);\n\t}\n\tfclose(proud);\n}\n\nvoid cteni(char *jmeno)\n{\n\tFILE *proud = fopen(jmeno, \"rb\");\n\tkontrola(proud, jmeno);\n\tint i;\n\twhile (fread(&i, sizeof(int), 1, proud))\n\t{\n\t\tcout << i << endl;\n\t}\n\tfclose(proud);\n}\n\nvoid pripojeni(char *jmeno, int *co, int kolik)\n{\n\tFILE *proud = fopen(jmeno, \"ab\");\n\tkontrola(proud, jmeno);\n\tfwrite(co, sizeof(int), kolik, proud);\n\tfclose(proud);\n}\n\nvoid predposledni_hodnota(char *jmeno)\n{\n\tFILE*proud = fopen(jmeno, \"rb\");\n\tkontrola(proud, jmeno);\n\tfseek(proud, -2*(long)sizeof(int), SEEK_END);\n\tint i;\n\tfread(&i, sizeof(i), 1, proud);\n\tcout << i << endl;\n}\n\nvoid aktualizace(char *jmeno)\n{\n\tFILE *proud = fopen(jmeno, \"rb+\");\n\tkontrola(proud, jmeno);\n\tint i;\n\twhile (fread(&i, sizeof(int), 1, proud))\n\t{\n\t\tif (i % 2 == 0)\t\t\t\t\n\t\t{\n\t\t\ti = i / 2;\n\t\t\tfseek(proud, -(long)sizeof(int), SEEK_CUR); \n\t\t\tfwrite(&i, sizeof(int), 1, proud);\n\t\t\tfseek(proud, 0, SEEK_CUR);\n\t\t}\n\t}\n\tfclose(proud);\n}\n\nint main()\n{\n\tint A[]{ 11,12,13,14,15,16 };\n\ttry\n\t{\n\t\tzapis(\"data.dta\");\n\t\t//pripojeni(\"data.dta\", A, sizeof(A) / sizeof(int));\n\t\t//predposledni_hodnota(\"data.dta\");\n\t\taktualizace(\"data.dta\");\n\t\tcteni(\"data.dta\");\n\t}\n\tcatch (exception &e)\n\t{\n\t\tcerr << e.what() << endl;\n\t}\n}\n\n\n"
        },
        {
          "label": "FILE fwrite fscanf_s",
          "language": "c_cpp",
          "value": "#include <stdio.h>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nvoid zapis(char * jmeno)\n{\n\tFILE *proud = nullptr;\n\terrno_t kod = fopen_s(&proud, jmeno, \"w\");\n\tif (kod != 0)\n\t{\n\t\tthrow runtime_error(\n\t\t\tstring(\"Nepodařilo se otevřít soubor \") + jmeno);\n\t}\n\tfor (int i = 1; i <= 10; i++)\n\t{\n\t\tfwrite(&i, sizeof(i), 1, proud);\n\t}\n\tfclose(proud);\n\n}\n\nconst int kolik = 50;\n\nvoid cteni_s(char *jmeno)\n{\n\tFILE *proud;\n\tint kód = fopen_s(&proud, jmeno, \"r\");\n\tif (kód)\n\t{\n\t\tthrow runtime_error(\"Nepodařilo se načíst vstupní soubor\");\n\t}\n\tint i;\n\twhile (fscanf_s(proud, \" %i\", &i) > 0)\n\t{\n\t\tprintf_s(\"%d \", i);\n\t}\n\tprintf_s(\"\\n\");\n\tchar text[kolik]{};\n\tfscanf_s(proud, \"%s\", text, kolik);\n\tprintf_s(\"%s\\n\", text);\n\tfclose(proud);\n}\n\n\n\nint main()\n{\n\tzapis(\"data.dta\");\n\tcteni_s(\"data.txt\");\n}"
        },
        {
          "label": "FILE fgets fscanf",
          "language": "c_cpp",
          "value": "#define  _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <stdio.h>\n#include <stdexcept>\n#include <string.h>\n\nusing namespace std;\n\nconst int kolik = 50;\n\nvoid cteni(char *jmeno)\n{\n\tFILE *proud = fopen(jmeno, \"r\");\n\tif(!proud)\n\t{\n\t\tthrow runtime_error(\"Nepodařilo se načíst vstupní soubor\");\n\t}\n\tint i;\n\twhile (fscanf(proud, \" %i\", &i) > 0)\n\t{\n\t\tprintf(\"%d \", i);\n\t}\n\tprintf(\"\\n\");\n\tchar text[kolik + 1]{};\n\tfscanf(proud, \"%s\", text);\n\tprintf(\"%s\\n\", text);\n\tfclose(proud);\n}\n\nvoid cteni1(char *jmeno)\n{\n\tFILE *proud = fopen(jmeno, \"r\");\n\tif (!proud)\n\t{\n\t\tthrow runtime_error(\"Nepodařilo se načíst vstupní soubor\");\n\t}\n\tint i;\n\twhile (fscanf(proud, \" %i\", &i) > 0)\n\t{\n\t\tprintf(\"%d \", i);\n\t}\n\tprintf(\"\\n\");\n\tchar text[kolik+1]{};\n\tfgets(text, kolik, proud);\n\tprintf(\"%s\\n\", text);\n\tfclose(proud);\n}\n\nint main()\n{\n\tsystem(\"CHCP 1250 > NUL\");\n\t//cteni(\"data.txt\");\n\tcteni1(\"data.txt\");\n}\n\n"
        }
      ],
      "id": "qGwJoCeL",
      "createdAt": 1710280797988,
      "updatedAt": 1718437771397
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Komparator",
      "content": [
        {
          "label": "Abecedni",
          "language": "c_cpp",
          "value": "#include \"abecedni_komparator.h\"\n#include \"inicializace.h\"\n\nabecedni_komparator::abecedni_komparator()\n{\n\tinicializator.inicializace_abecedniho_razeni(mala_na_velka, slozena_pismena, uprava);\n}\n\nbool abecedni_komparator::operator()(string lajna1, string lajna2)\n{\n\treturn zastup(lajna1) < zastup(lajna2);\n}\n\nchar abecedni_komparator::velke(char znak)\n{\n\tif ((znak >= 'a') && (znak <= 'z'))\n\t{\n\t\treturn znak - 'a' + 'A';\n\t}\n\tif (mala_na_velka.find(znak) != mala_na_velka.end())\n\t{\n\t\treturn mala_na_velka[znak];\n\t}\n\treturn znak;\n}\n\nstring abecedni_komparator::velke(string text)\n{\n\tstring vysledek;\n\tfor (char p : text)\n\t{\n\t\tvysledek += velke(p);\n\t}\n\treturn vysledek;\n}\n\nstring abecedni_komparator::zastup(string text)\n{\n\tstring primarni, sekundarni, pismeno;\n\tstring TEXT = velke(text);\n\tfor (unsigned i = 0; i < TEXT.length(); i++)\n\t{\n\t\tpismeno.clear();\n\t\tpismeno += TEXT[i];\n\t\tif ((slozena_pismena.find(TEXT[i]) != slozena_pismena.end()) &&\n\t\t\t(i + 1 < TEXT.length()) &&\n\t\t\t(TEXT[i + 1] == slozena_pismena[TEXT[i]]))\n\t\t{\n\t\t\tpismeno += slozena_pismena[TEXT[i]];\n\t\t\ti++;\n\t\t}\n\t\tprimarni += uprava[pismeno].first;\n\t\tsekundarni += uprava[pismeno].second;\n\t}\n\treturn primarni + ' ' + sekundarni;\n}\n\n\n\n#ifndef __ABECEDNI_KOMPARATOR_H__\n#define __ABECEDNI_KOMPARATOR_H__\n\n#include <string>\n#include <unordered_map>\n#include <map>\n#include <utility>\n\n#include \"komparator.h\"\n\nusing namespace std;\n\nclass abecedni_komparator : public komparator\n{\n\tunordered_map<char, char> mala_na_velka;\n\tunordered_map< string, pair<string, char>> uprava;\n\tunordered_map<char, char> slozena_pismena;\n\n\tchar velke(char znak);\n\tstring velke(string text);\n\tstring zastup(string text);\npublic:\n\tabecedni_komparator();\n\tvirtual bool operator()(string lajna1, string lajna2);\n};\n\n#endif // __ABECEDNI_KOMPARATOR_H__\n"
        },
        {
          "label": "Lexikograficky",
          "language": "c_cpp",
          "value": "#include \"lexikograficky_komparator.h\"\n\nlexikograficky_komparator::lexikograficky_komparator()\n{\n}\n\nusing u_komp = komparator *(*)();\n\nbool lexikograficky_komparator::operator()(string lajna1, string lajna2)\n{\n\tu_komp ux = lexikograficky_komparator::vytvor_komparator;\n\treturn lajna1 < lajna2;\n}\n\n#ifndef __LEXIKOGRAFICKY_KOMPARATOR_H__\n#define __LEXIKOGRAFICKY_KOMPARATOR_H__\n\n#include \"komparator.h\"\n\nclass lexikograficky_komparator : public komparator\n{\npublic:\n\tlexikograficky_komparator();\n\tvirtual bool operator()(string lajna1, string lajna2) override;\n\tstatic komparator *vytvor_komparator()\n\t{\n\t\treturn new lexikograficky_komparator;\n\t}\n};\n\n#endif // __LEXIKOGRAFICKY_KOMPARATOR_H__\n\n"
        },
        {
          "label": "Numericky",
          "language": "c_cpp",
          "value": "#include <sstream>\n#include \"numericky_komparator.h\"\nusing namespace std;\n\nnumericky_komparator::numericky_komparator()\n{\n}\n\nbool numericky_komparator::operator()(string lajna1, string lajna2)\n{\n\tistringstream vstup1(lajna1), vstup2(lajna2);\n\tint n1, n2;\n\tvstup1 >> n1;\n\tvstup2 >> n2;\n\treturn n1 < n2;\n}\n\n\n#ifndef __NUMERICKY_KOMPARATOR_H__\n#define __NUMERICKY_KOMPARATOR_H__\n\n#include \"komparator.h\"\nclass numericky_komparator : public komparator\n{\npublic:\n\tnumericky_komparator();\n\tvirtual bool operator()(string lajna1, string lajna2) override;\n};\n\n\n#endif // __NUMERCKY_KOMPARATOR_H__\n\n"
        }
      ],
      "id": "IE7oTuLf",
      "createdAt": 1710281374846,
      "updatedAt": 1710705075009
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Ascii tree for path ",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "/**************************************************************************\n  TREE\n  ~~~~\n\n    Program, ktery v ASCII grafice zobrazi strom adresaru pod zadanym\n    adresarem.\n    (3.semestralni uloha z OSY, uloha c.3)\n\n    Petr Kadlec (cviceni z OSY ve ctvrtek od 11:00)\n **************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include <dirent.h>\n\n#define NDEBUG\n#include <assert.h>\n\n#include \"platform.h\"\n\n/* -- Definice ASCII znaku pro vykresleni -- */\n\n/* pri definovanem FULL_ASCII se vyuziva znaku horni poloviny ASCII tabulky,\n   jinak pouze tech dolnich */\n/*#define FULL_ASCII*/\n\n#ifdef FULL_ASCII\n#ifdef DOUBLE_FRAMES\n#define C_SPACE  ' '\n#define C_VERT   '\\272'\n#define C_BRANCH '\\314'\n#define C_LAST   '\\310'\n#define C_ENTRY  '\\315'\n#else\n#define C_SPACE  ' '\n#define C_VERT   '\\263'\n#define C_BRANCH '\\303'\n#define C_LAST   '\\300'\n#define C_ENTRY  '\\304'\n#endif\n#else\n#define C_SPACE  ' '\n#define C_VERT   '|'\n#define C_BRANCH '+'\n#define C_LAST   '`'\n#define C_ENTRY  '-'\n#endif\n\n/* pomocna funkce - ukonceni s chybou */\nvoid fail(char *msg)\n{\n  fflush(stdout);\n  perror(msg);\n  exit(EXIT_FAILURE);\n}\n\n/* prave prochazeny adresar */\nchar current_dir[PATH_MAX] = \".\" PATH_STR;\nchar terminate_ = '\\0';\t\t/* \"hack\", ochranujici proti preteceni cesty */\n\nint depth = 0;\nstruct dirent *ent[MAXRECURSION];\n\nchar show_hidden = 0; \t/* konfiguracni promenna: prochazet skryte adresare? */\n\n/* funkce pro \"detekci\" \".\" a \"..\" */\n#define no_dots(d_name) ((d_name)[0] != '.' || \t\t\t\t\\\n\t\t\t ((d_name)[1] != '\\0' && \t\t\t\\\n\t\t\t  ((d_name)[1] != '.' || (d_name)[2] != '\\0') \t\\\n\t\t\t ) \t\t\t\t\t\t\\\n\t\t\t)\n\nchar not_hidden(char *fname)\t/* adresar/soubor fname neni hidden */\n{\n#if (defined(PLATFORM_UNIX))\n  assert(fname != NULL);\n\n  return (fname[0] != '.');\n#elif (defined(PLATFORM_DOS))\n  unsigned attr;\n\n  assert(fname != NULL);\n\n  if (_dos_getfileattr(fname, &attr)) fail(\"Error getting file attributes\");\n\n  return !(attr & FA_HIDDEN);\n#else\n  return (fname != NULL);\n#endif\n}\n\n/* Pomocna funkce pro nalezeni dalsiho podadresare adresare dir */\nstruct dirent *find_next_subdir(DIR *dir)\n{\n  struct dirent *ent;\n  struct stat fst;\n  char this_file[PATH_MAX];\n\n  strcpy(this_file, current_dir);\n\n  while ((ent = readdir(dir)) != NULL) {\n    /* preskoc \".\" a \"..\" */\n    if (no_dots(ent->d_name)) {\n\n      /* vytvor plne jmeno souboru */\n      strcat(this_file, ent->d_name);\n\n      /* preskoc pripadne i skryte adresare */\n      if (show_hidden || not_hidden(this_file)) {\n\tif (get_stat(this_file, &fst)) fail(\"Error getting file information\");\n\n\t/* nalezen adresar? */\n\tif (fst.st_mode & S_IFDIR) return ent;\n      }\n\n      /* Odstran posledni soubor z current_dir */\n      assert(strrchr(this_file, PATH_CHAR) != NULL);\n      strrchr(this_file, PATH_CHAR)[1] = '\\0';\n\n    } /* if no_dots */\n  } /* while ent != NULL */\n\n  return NULL;\n}\n\n/* Pomocna funkce pro ziskani dalsiho podadresare */\nvoid get_next_ent(DIR *dir, struct dirent **ent)\n{\n  char old_name[PATH_MAX] = \"\";\n\n  assert(ent != NULL);\n  assert(dir != NULL);\n\n  /* Uschovej puvodni hodnotu ent->d_name */\n  if (*ent != NULL)\n     strcpy(old_name, (*ent)->d_name);\n\n  /* Priprav dalsi podadresar (nebo NULL) */\n  *ent = find_next_subdir(dir);\n\n  if (old_name[0] != '\\0') {\n    /* Vytvor plne jmeno adresare */\n    strcat(current_dir, old_name);\n\n    /* Pridej '/' na konec current_dir */\n    strcat(current_dir, PATH_STR);\n  }\n}\n\n/* Hlavni rekurzivni funkce, ktera prochazi adresarovy strom */\nvoid recurse_directory(void)\n{\n  DIR *dir;\n\n  /* zobraz \"vetve\" stromu pod soucasnym adresarem */\n  register int i;\n  for (i=0; i<depth-1; i++) {\n\tputchar(ent[i] != NULL ? C_VERT : C_SPACE);\n\tputchar(C_SPACE);\n  }\n\n  /* pokud toto neni korenovy adresar, zobraz jeho jmeno, spolu s odbockou */\n  if (depth) {\n    register char *slash;\n\n    /* zobraz odbocku */\n    putchar(ent[depth-1] != NULL ? C_BRANCH : C_LAST);\n    putchar(C_ENTRY);\n\n    /* odstran koncove '/' */\n    slash = current_dir + strlen(current_dir) - 1;\n    assert(*slash == PATH_CHAR);\n    *slash = '\\0';\n\n    /* zobraz jenom posledni jmeno */\n    fputs(strrchr(current_dir, PATH_CHAR)+1, stdout);\n\n    /* obnov koncove '/' */\n    *slash = PATH_CHAR;\n\n    /* zkontroluj opravneni (poznamka - toto se pro korenovy adresar nedela,\n       jelikoz se to kontroluje jiz ve funkci main()) */\n    if (check_access(current_dir)) {\n      /* nemame opravneni prochazet tento adresar, ukazeme to znakem '/' a skoncime s timto adresarem */\n      puts(PATH_STR);\n      /* printf(PATH_STR\"\\t(%s)\\n\",strerror(errno)); <-- alternativni indikace neuspechu */\n      return;\n    } else putchar('\\n');\n  }\n\n  /* otevri adresar */\n  if ((dir = opendir(current_dir)) == NULL) fail(\"Cannot open directory\");\n\n  /* Hlavni smycka:\n\tv ent[depth] je vzdy DALSI nalezeny adresar,\n\tv current_dir je prave zpracovavany adresar\n   */\n  ent[depth] = find_next_subdir(dir);\n  while (ent[depth] != NULL) {\n    /* Nastav do current_dir adresar z ent[depth] a do ent[depth] dej\n       dalsi nalezeny (nebo NULL) */\n    get_next_ent(dir, &ent[depth]);\n\n    depth++;\n    assert(depth <= MAXRECURSION);\n\n    /* Rekurzivne vykresli podstrom */\n    recurse_directory();\n\n    /* Odstran '/' pridany na konec current_dir */\n    assert(current_dir[strlen(current_dir)-1] == PATH_CHAR);\n    current_dir[strlen(current_dir)-1] = '\\0';\n\n    /* Odstran posledni podadresar z current_dir */\n    assert(strrchr(current_dir, PATH_CHAR) != NULL);\n    strrchr(current_dir, PATH_CHAR)[1] = '\\0';\n\n    depth--;\n    assert(depth <= MAXRECURSION);\n  }\n\n  /* konec prace s adresarem */\n  if (closedir(dir)) fail(\"Error closing directory\");\n}\n\nvoid process_args(int argc, char *argv[])\n{\n  int i;\n\n  for (i=1; i<argc; i++) {\n    assert(argv[i] != NULL);\n\n    if (*(argv[i]) == OPTIONCHAR) {\n      /* Parametr \"option\" */\n\n      if (!stricmp(argv[i]+1, \"h\") || !strcmp(argv[i]+1, \"?\")) {\n\tprintf(\"Tento program zobrazi strom adresarove struktury od daneho adresare\\n\"\n\t       \"Pouziti: tree [\" OPTION_STR \"a] [adresar]\\n\"\n\t       \"\\tadresar popisuje koren zobrazovaneho stromu (pokud neni zadan,\\n\"\n\t       \"\\t\\tzobrazuje se od aktualniho adresare)\\n\"\n\t       \"\\t\" OPTION_STR \"a Zpusobi zobrazovani i skrytych adresaru\\n\");\n\texit(EXIT_FAILURE);\n      } else if (!stricmp(argv[i]+1, \"a\")) {\n\t       show_hidden = 1;\n\t     } else {\n\t       fprintf(stderr, \"Unknown option\\n\");\n\t       exit(EXIT_FAILURE);\n\t     }\n    } else {\n      /* Parametr \"pocatecni adresar\" */\n      if (strlen(argv[i]) > PATH_MAX-1) {\n\tfprintf(stderr, \"Too long pathname\\n\");\n\texit(EXIT_FAILURE);\n      }\n\n      /* Toto musi byt posledni parametr */\n      if (i<argc-1) {\n\tfprintf(stderr, \"Too many arguments\\n\");\n\texit(EXIT_FAILURE);\n      }\n\n      /* zkopiruj argv[i] do current_dir a pripadne pridej '/' */\n      if (current_dir[strxfrm(current_dir, argv[i], PATH_MAX)-1] != PATH_CHAR)\n\t  strcat(current_dir, PATH_STR);\n\n      /* zjisti, zda se od zadaneho adresare skutecne da prochazet */\n      if (check_access(current_dir)) fail(\"Cannot display directory tree\");\n    }\n  }\n}\n\nint main(int argc, char *argv[])\n{\n /* Zpracuj parametry prikazove radky */\n process_args(argc, argv);\n\n /* a jedem! */\n recurse_directory();\n\n /* To je vse, pratele! */\n return EXIT_SUCCESS;\n}\n\n\n#ifndef __PLATFORM_H\n#define __PLATFORM_H\n\n/**************************************************************************\n  Hlavickovy soubor pro platform-dependent definice.\n  (soucast programu TREE)\n\n    Petr Kadlec (cviceni z OSY ve ctvrtek od 11:00)\n **************************************************************************/\n\n/* ---- \"detekce\" platformy, na ktere se preklada ---- */\n#ifdef __BORLANDC__\n#define PLATFORM_DOS\n#endif\n\n#if (!defined(PLATFORM_DOS))\n#define PLATFORM_UNIX\n#endif\n\n#if (defined(PLATFORM_DOS) && defined(PLATFORM_UNIX))\n#error Unable to decide the target platform\n#endif\n/* --------------------------------------------------- */\n\n\n#include <sys/stat.h>\n#include <limits.h>\n\n/* maximalni mozna delka cesty */\n#if (!defined(PATH_MAX))\n#define PATH_MAX 512\n#endif\n\n/* maximalni uroven rekurze, ktera je mozna */\n#define MAXRECURSION (PATH_MAX/2)\n\n/* oddelovac cesty a optionu */\n#if (defined(PLATFORM_DOS))\n#define PATH_CHAR '\\\\'\n#define PATH_STR  \"\\\\\"\n#define OPTION_CHAR '/'\n#define OPTION_STR \"/\"\n#elif (defined(PLATFORM_UNIX))\n#define PATH_CHAR '/'\n#define PATH_STR  \"/\"\n#define OPTIONCHAR '-'\n#define OPTION_STR \"-\"\n#endif\n\n/* funkce pro zjisteni informaci o souboru */\n#ifdef PLATFORM_UNIX\n#define get_stat(path,buf) stat((path),(buf))\n#elif (defined(PLATFORM_DOS))\n#define get_stat(path,buf) stat((path),(buf))\n#endif\n\n#ifdef PLATFORM_DOS\n#include <dos.h>\n#endif\n\n/* Pro non-DOS platformy se nepouziva case-insensitive strcmp */\n#ifndef PLATFORM_DOS\n#define stricmp(s1,s2) strcmp(s1,s2)\n#endif\n\n/* kontrola pristupovych prav */\n#if (defined(PLATFORM_DOS))\n/* vzdy vraci nulu */\n#define check_access(path) ((path) != (path))\n#elif (defined(PLATFORM_UNIX))\n#include <unistd.h>\n#define check_access(path) access((path), R_OK | X_OK)\n#endif\n\n#endif /* __PLATFORM_H */\n"
        }
      ],
      "id": "Ws-Rr6GJ",
      "createdAt": 1710281686418,
      "updatedAt": 1710704996063
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Porovnat bod ve ctverci",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "if (mouse.x >= button.x && mouse.x < button.x + button.width && mouse.y >= button.y && mouse.y < button.y + button.height)\n     clicked = true;"
        }
      ],
      "id": "9QDtRxQ_",
      "createdAt": 1710282144832,
      "updatedAt": 1710704987681
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Singleton",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\n\n#define DB_HOST (std::string) \"localhost\"\n#define DB_USER (std::string) \"user\"\n#define DB_PASS (std::string) \"pass\"\n\nclass Databaze\n{\npublic:\n    Databaze(const std::string& host, const std::string& jmeno, const std::string& heslo)\n    {\n        // Inicializace databaze (pro ilustracni ucely vypise informace)\n        std::cout << \"Inicializace databaze s parametry: \" << std::endl << host << \", \" << jmeno << \", \" << heslo << std::endl;\n    }\n\n};\n\nclass Singleton\n{\n\nprivate:\n    static Singleton* instance;\n\n    Databaze databaze = Databaze(DB_HOST, DB_USER, DB_PASS);;\n\n    Singleton()\n    {\n        // Soukromý konstruktor\n    }\n\npublic:\n    static Singleton* VratInstanci()\n    {\n        if (!instance)\n        {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n};\n\n// Inicializace staticke promenne instance\nSingleton* Singleton::instance = nullptr;\n\nint main()\n{\n    // Ziskani instance Singletonu\n    Singleton* singleton1 = Singleton::VratInstanci();\n    Singleton* singleton2 = Singleton::VratInstanci();\n\n    // Porovnani dvou instanci (mely by byt stejne)\n    if (singleton1 == singleton2)\n    {\n        std::cout << \"Obe instance Singletonu jsou stejne.\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Chyba: Instance Singletonu nejsou stejne.\" << std::endl;\n    }\n\n    return 0;\n}\n"
        }
      ],
      "id": "h55HV71L",
      "createdAt": 1710282239570,
      "updatedAt": 1710705041780
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Sachovnice",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\n// Sachovnice\nint main()\n{\n    const int velikost_ctverce = 8;\n    string sachovnice[velikost_ctverce][velikost_ctverce];\n    bool barva_bila = true;\n\n    for (int i = 0; i < velikost_ctverce; i++)\n    {\n        for (int x = 0; x < velikost_ctverce; x++)\n        {\n            if (barva_bila)\n            {\n                sachovnice[i][x] = \" \";\n                cout << sachovnice[i][x];\n                barva_bila = false;\n            }\n            else\n            {\n                sachovnice[i][x] = \"#\";\n                cout << sachovnice[i][x];\n                barva_bila = true;\n            }\n\n        }\n        if (barva_bila)\n            barva_bila = false;\n        else\n            barva_bila = true;\n\n        cout << endl;\n    }\nreturn 0;\n}\n"
        }
      ],
      "id": "g3pU3LiH",
      "createdAt": 1710282265402,
      "updatedAt": 1710704987653
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Friends",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#ifndef CHRANENATRIDA_H_INCLUDED\n#define CHRANENATRIDA_H_INCLUDED\n\n\n#include <iostream>\n#include <string>\n#include \"PratelskaTrida.h\"\n#include \"TridaSPratelskouMetodou.h\"\nusing namespace std;\n\nclass ChranenaTrida\n{\nprivate:\n    int atribut = 5;\n\n    // abychom mohli třídy deklarovat jako přátelské, musí již být deklarované\n    friend void funkce(ChranenaTrida t); // deklarace přátelské funkce, tato funkce nemusí být deklarovaná\n    friend void TridaSPratelskouMetodou::metoda(ChranenaTrida t); // deklarace přátelské metody, třída již musí být deklarovaná\n    friend PratelskaTrida; // deklarace přátelské třídy, třída musí být deklarovaná\n};\n\n\nvoid funkce(ChranenaTrida t)\n{\n    cout << \"Privatni atribut z pratelske funkce: \" << t.atribut << endl;\n}\n\nvoid TridaSPratelskouMetodou::metoda(ChranenaTrida t)\n{\n    cout << \"Privatni atribut z pratelske metody: \" << t.atribut << endl;\n}\n\nvoid PratelskaTrida::metoda(ChranenaTrida t)\n{\n    cout << \"Privatni atribut z pratelske tridy: \" << t.atribut << endl;\n}\n\n\n#endif // CHRANENATRIDA_H_INCLUDED\n\n#ifndef PRATELSKATRIDA_H_INCLUDED\n#define PRATELSKATRIDA_H_INCLUDED\n\n#include <iostream>\n#include <string>\n#include \"ChranenaTrida.h\"\n#include \"TridaSPratelskouMetodou.h\"\nusing namespace std;\n// deklarace třídy, jinak by přátelské třídy nemohly použít parametr tohoto typu\nclass ChranenaTrida;\n\nclass PratelskaTrida\n{\npublic:\n    void metoda(ChranenaTrida t);\n    // stejný případ jako předchozí, implementace zde být nemůže\n};\n\n\n#endif // PRATELSKATRIDA_H_INCLUDED\n\n\n#ifndef TRIDASPRATELSKOUMETODOU_H_INCLUDED\n#define TRIDASPRATELSKOUMETODOU_H_INCLUDED\n\n #include <iostream>\n#include <string>\n#include \"ChranenaTrida.h\"\n#include \"PratelskaTrida.h\"\nusing namespace std;\n// deklarace třídy, jinak by přátelské třídy nemohly použít parametr tohoto typu\nclass ChranenaTrida;\n\nclass TridaSPratelskouMetodou\n{\npublic:\n    void metoda(ChranenaTrida t);\n    // implementaci sem dát nemůžeme, protože nevíme nic o ChranenaTrida\n};\n\n#endif // TRIDASPRATELSKOUMETODOU_H_INCLUDED\n\n#include <iostream>\n#include <string>\n#include \"ChranenaTrida.h\"\n#include \"TridaSPratelskouMetodou.h\"\n#include \"PratelskaTrida.h\"\n\nusing namespace std;\n\nint main()\n{\n    ChranenaTrida chranena;\n    funkce(chranena);\n    TridaSPratelskouMetodou s_metodou;\n    s_metodou.metoda(chranena);\n    PratelskaTrida pratelska;\n    pratelska.metoda(chranena);\n}\n\n"
        }
      ],
      "id": "eiSqNVoT",
      "createdAt": 1710282308871,
      "updatedAt": 1710705041765
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "While po urcitou dobu cycle timeout ",
      "content": [
        {
          "label": "Milisekundy",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <chrono>\n#include <thread>\n\nint main() {\n    // Nastav čas, po který chceš cyklovat v milisekundách\n    const int durationMs = 5000; // například 5000 ms (5 sekund)\n\n    // Získání aktuálního času\n    auto startTime = std::chrono::high_resolution_clock::now();\n\n    while (true) {\n        // Tělo cyklu\n\n        // Získání aktuálního času\n        auto currentTime = std::chrono::high_resolution_clock::now();\n\n        // Výpočet rozdílu časů v milisekundách\n        auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - startTime).count();\n\n        // Podmínka pro ukončení cyklu po uplynutí dané doby\n        if (elapsedTime >= durationMs) {\n            break;\n        }\n\n        // Případné další akce v těle cyklu\n\n        // Uspání vlákna na krátkou dobu (například 10 ms), aby se snížila zátěž procesoru\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n\n    // Konec programu\n    std::cout << \"Cyklus dokončen.\" << std::endl;\n\n    return 0;\n}\n"
        },
        {
          "label": "Sekundy - nejlepší",
          "language": "c_cpp",
          "value": "cout << endl << \"Waiting for other players 10 sec...\" << endl;\nconst time_t startTime = time(nullptr);\nwhile (time(nullptr) - startTime < 10)\n{\n\tif (net.hostService() == 1)\n\tnetworkPlayers++;\n}\n"
        },
        {
          "label": "Jednořádkový chrono",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <chrono>\n#include <thread>\n\nint main() {\n    const auto start = std::chrono::high_resolution_clock::now();\n    while (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now() - start).count() < 5000)\n {\n    \t/* Tělo cyklu */ std::this_thread::sleep_for(std::chrono::milliseconds(10));\n }\n    std::cout << \"Cyklus dokončen.\" << std::endl;\n    return 0;\n}\n"
        }
      ],
      "id": "qmKw3yJ4",
      "createdAt": 1710339637979,
      "updatedAt": 1710705015334
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Přetypování šablony -  Type Cast Templates",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "V jazyce C++ můžete použít několik různých technik pro přetypování objektů. Zde jsou tři základní metody:\n\n    Statické přetypování (static_cast): Tato šablona se používá k přetypování mezi typy, které jsou kompatibilní a mají nějaký vztah mezi sebou, například přetypování mezi odvozeným a základním typem v hierarchii dědičnosti. Při statickém přetypování kompilátor zkontroluje, zda je přetypování možné na základě znalosti typů v čase kompilace.\n\ncpp\n// Přetypování ukazatele odvozeného typu na ukazatel základního typu.\nDerived* derivedPtr = new Derived();\nBase* basePtr = static_cast<Base*>(derivedPtr);\n\n    Dynamické přetypování (dynamic_cast): Tato šablona se používá v případech, kdy je nutné provést bezpečné přetypování ukazatelů nebo referencí na objekty polymorfních typů (tj. typy s virtuálními funkcemi). Dynamické přetypování provádí kontrolu za běhu a vrací nullptr, pokud je přetypování neplatné.\n\ncpp\n\n// Dynamické přetypování ukazatele odvozeného typu na ukazatel základního typu.\nDerived* derivedPtr = new Derived();\nBase* basePtr = dynamic_cast<Base*>(derivedPtr);\nif (basePtr) {\n    // Úspěšné přetypování.\n} else {\n    // Neúspěšné přetypování.\n}\n\n    Reinterpretace (reinterpret_cast): Tato šablona umožňuje přetypování mezi jakýmikoli dvěma ukazateli na objekty či jiné typy, ale není prováděna žádná kontrola kompatibility typů. Reinterpretace je obecně považována za nebezpečnou a měla by být používána opatrně.\n\ncpp\n\n// Reinterpretace ukazatele na integer.\nint* intptr;\nchar* charptr = reinterpret_cast<char*>(intptr);\n\nJe důležité používat tyto šablony opatrně a podle potřeby, přičemž je nutné brát v úvahu bezpečnost a správnost přetypování. Používání nesprávného typu přetypování může vést k chybám za běhu programu."
        }
      ],
      "id": "7_BrAqtL",
      "createdAt": 1710605142017,
      "updatedAt": 1710925150792
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Předání reference na typ &Vector<int>",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "    // call\n    // vector<int> bufToReceive = {};\n    // int res = net.serverHostService(bufToReceive);\n    int serverHostService(vector<int>& data)\n    {\n        data.clear();\n        while (enet_host_service (server, &event, 50) > 0)\n        {\n            switch (event.type)\n            {\n            case ENET_EVENT_TYPE_NONE:\n                return 0;\n\n            case ENET_EVENT_TYPE_CONNECT:\n                return 1;\n\n            case ENET_EVENT_TYPE_DISCONNECT:\n                sprintf ((char*)stream, \"%s disconnected.\\n\", (void*)event.peer -> data);\n                cout << stream << endl;\n                /* Reset the peer's client information. */\n                event.peer -> data = NULL;\n                return 2;\n\n            case ENET_EVENT_TYPE_RECEIVE:\n                cout << \"size: \" << event.packet->dataLength << endl;\n                data.insert(data.end(),\n                                    reinterpret_cast<int*>(event.packet->data),\n                                    reinterpret_cast<int*>(event.packet->data) + event.packet->dataLength / sizeof(int));\n\n                /* Clean up the packet now that we're done using it. */\n                enet_packet_destroy (event.packet);\n                return 3;\n            }\n        }\n        return 4; // no event\n    }"
        }
      ],
      "id": "06t1170_",
      "createdAt": 1710605516121,
      "updatedAt": 1710704987621
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Zjištění délky pole / get array length",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Ruční sledování délky pole:\n\n#include <iostream>\n\nint main() {\n    int bufferToSendInt[] = {22, 23, 24, 25, 26, 27};\n    int length = sizeof(bufferToSendInt) / sizeof(bufferToSendInt[0]);\n    std::cout << \"Pocet prvku v poli je: \" << length << std::endl;\n    return 0;\n}\n\nPoužití standardní knihovny <array>:\n#include <iostream>\n#include <array>\n\nint main() {\n    std::array<int, 6> bufferToSendInt = {22, 23, 24, 25, 26, 27};\n    std::cout << \"Pocet prvku v poli je: \" << bufferToSendInt.size() << std::endl;\n    return 0;\n}\n\n"
        }
      ],
      "id": "WWEclW-h",
      "createdAt": 1710605610222,
      "updatedAt": 1710705155166
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "memcpy vector",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "V tomto příkladu vec.data() vrací ukazatel na data uložená v vector. vec.size() poskytuje počet prvků v vector. sizeof(int) je velikost jednoho prvku typu int. Celková velikost paměti, která se má zkopírovat, je tedy počet prvků vector násobený velikostí jednoho prvku.\n\n#include <iostream>\n#include <vector>\n#include <cstring>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4, 5};\n    \n    // Vytvoření pole pro kopírování dat z vektoru\n    int *data = new int[vec.size()];\n    \n    // Kopírování dat z vektoru do pole pomocí memcpy\n    std::memcpy(data, vec.data(), vec.size() * sizeof(int));\n    \n    // Vypíše hodnoty vytvořeného pole\n    for (size_t i = 0; i < vec.size(); ++i) {\n        std::cout << data[i] << \" \";\n    }\n    std::cout << std::endl;\n    \n    // Uvolnění paměti alokované pro pole\n    delete[] data;\n    \n    return 0;\n}\n\n\nV tomto kódu jsou použity tři kroky:\n\n    Získání délky pole bufferToSendInt.\n    Vytvoření vektoru vec s předpokládanou délkou.\n    Kopírování dat z pole do vektoru pomocí memcpy.\n    \n#include <iostream>\n#include <vector>\n#include <cstring>\n\nint main() {\n    int bufferToSendInt[] = {22, 23, 24, 25, 26, 27};\n    size_t length = sizeof(bufferToSendInt) / sizeof(bufferToSendInt[0]); // zjistíme délku pole\n\n    // Vytvoření vektoru s předpokládanou velikostí\n    std::vector<int> vec(length);\n    \n    // Kopírování dat z pole do vektoru pomocí memcpy\n    std::memcpy(vec.data(), bufferToSendInt, length * sizeof(int));\n    \n    // Vypíše hodnoty vytvořeného vektoru\n    for (size_t i = 0; i < vec.size(); ++i) {\n        std::cout << vec[i] << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n"
        }
      ],
      "id": "n4f75fSp",
      "createdAt": 1710605720663,
      "updatedAt": 1710704987591
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "unsigned char* na int",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Jednoduchý převod hodnoty:\nPokud chcete převést jednotlivé hodnoty v poli unsigned char* na int, můžete použít aritmetický operátor k převodu hodnoty na int. Například:\n\ncpp\n\nunsigned char* data = /* adresa pole */;\nint value = static_cast<int>(*data);\n\nPřevod na celý blok:\nPokud máte pole unsigned char*, které obsahuje více bytů a chcete je převést na jedno celé číslo (např. předpokládejme, že první 4 byty tvoří int), můžete použít ukazatelové typy:\n\ncpp\n\nunsigned char* data = /* adresa pole */;\nint* intValue = reinterpret_cast<int*>(data);\n\nTento přístup předpokládá, že data jsou zarovnána tak, aby odpovídala typu int. Pokud data nejsou zarovnána správně, můžete narazit na chování dle implementace.\n\nPoužití bitových posunů a logických operací:\nPokud máte pole unsigned char* obsahující více bytů reprezentujících jedno číslo, můžete použít bitové posuny a logické operace k sestavení čísla int:\n\ncpp\n\n    unsigned char* data = /* adresa pole */;\n    int value = 0;\n    for (int i = 0; i < sizeof(int); ++i) {\n        value |= static_cast<int>(data[i]) << (i * 8);\n    }\n\n    Tento kód předpokládá, že každý byte v poli reprezentuje jeden byte v celém čísle int.\n\nPamatujte, že při použití druhého a třetího přístupu musíte být opatrní na správné zarovnání dat a na pořadí bytů (endianness) vašeho systému."
        }
      ],
      "id": "BMcyUfdg",
      "createdAt": 1710606116836,
      "updatedAt": 1710705321731
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Sleep in ms",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Můžete použít plný název pro `150ms` bez použití `using namespace std::chrono_literals`. Místo toho můžete použít `std::chrono::milliseconds(150)`. Zde je ukázkový kód:\n\n```cpp\n#include <chrono>\n#include <thread>\n\nint main() {\n    std::this_thread::sleep_for(std::chrono::milliseconds(150));\n    return 0;\n}\n```\n\nTímto způsobem se vyhnete použití `using namespace std::chrono_literals` a stále můžete použít `std::this_thread::sleep_for` s délkou zadanou v milisekundách."
        }
      ],
      "id": "ApDYqHDb",
      "createdAt": 1710606732686,
      "updatedAt": 1710705015314
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "char vs wchar",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Používání `char` a `wchar_t` (a tedy `char` a `wchar_t` řetězců) v C++ závisí na několika faktorech, zejména na potřebách vaší aplikace a prostředí, ve kterém pracujete. Zde je několik věcí, které můžete zvážit:\n\n1. **Standardní řetězce (`char`):**\n   - Pokud pracujete v prostředí, které používá standardní ASCII nebo UTF-8 kódování, můžete bez problémů používat standardní `char` řetězce. To je běžný případ pro většinu moderních aplikací.\n   - Standardní řetězce jsou efektivní v paměti a bývají jednodušší na manipulaci a práci s nimi.\n\n   ```cpp\n   const char* text = \"Hello, World!\";\n   ```\n\n2. **Wide řetězce (`wchar_t`):**\n   - Pokud pracujete s nějakým prostředím, které podporuje široké znaky nebo Unicode, můžete zvážit použití wide řetězců. Například, pokud vyvíjíte aplikaci v prostředí Windows, kde je běžné používání širokých znaků (`wchar_t`).\n   - Wide řetězce jsou užitečné pro práci s jazyky, které vyžadují rozšířenou sadu znaků než ASCII, jako je čínština nebo japonština.\n\n   ```cpp\n   const wchar_t* wideText = L\"Hello, World!\";\n   ```\n\n3. **Zvažte multibytové nebo Unicode řetězce:**\n   - Pro mnoho aplikací je vhodné zvažovat práci s multibytovými nebo Unicode řetězci, aby byla zajištěna správná podpora různých jazyků a znakových sad.\n\n   ```cpp\n   #include <codecvt>\n   #include <locale>\n\n   // Použití std::wstring_convert pro převod mezi std::string a std::wstring\n   std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;\n   std::wstring wideText = converter.from_bytes(\"Hello, World!\");\n   std::string text = converter.to_bytes(L\"Hello, World!\");\n   ```\n\nCelkově vzato, rozhodnutí o použití `char` nebo `wchar_t` by mělo být založeno na potřebách vaší aplikace a požadované znakové sadě. Většina moderních aplikací využívá standardní řetězce (`char`) a pracuje s Unicode pomocí různých knihoven pro manipulaci s řetězci.\n\nPro deklarační a implementační soubory v jazyce C++ se obvykle používá UTF-8 kódování. UTF-8 je standardní kódování, které umožňuje reprezentovat širokou škálu znaků, včetně těch z různých jazyků. Používání UTF-8 má několik výhod:\n\n1. **Univerzálnost:** UTF-8 je schopné reprezentovat prakticky veškeré znaky z Unicode, což znamená, že je vhodné pro mezinárodní projekty a projekty pracující s různými jazyky.\n\n2. **Zpětná kompatibilita:** UTF-8 je zpětně kompatibilní s ASCII. To znamená, že soubory napsané v ASCII jsou také validní UTF-8 soubory, což usnadňuje přechod a integrování nových znaků do existujících souborů.\n\n3. **Podpora většiny nástrojů:** Většina moderních vývojových nástrojů a editorů podporuje UTF-8, což zjednodušuje práci s kódem napsaným v tomto kódování.\n\nPři používání UTF-8 kódování je však důležité zajistit, že všechny nástroje a prostředí, která s kódem pracují (včetně kompilátorů, editorů a verzovacích systémů), jsou správně nakonfigurovány tak, aby rozpoznávaly a správně zpracovávaly UTF-8 kódování. To je obzvláště důležité v prostředí, kde se pracuje s víceplatformovými a mezinárodními projekty."
        }
      ],
      "id": "IRmn9BXq",
      "createdAt": 1710607355401,
      "updatedAt": 1710704980965
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "std::setlocale vs std::locale",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "V jazyce C++ existují dvě věci, které mohou být zaměňovány: třída `std::locale` a funkce `std::setlocale`.\n\n1. **Třída `std::locale`:**\n   - Třída `std::locale` je součástí standardní knihovny C++ a představuje lokalizaci, což znamená sadu konvencí, které ovlivňují formátování dat a některé další aspekty, jako je kódování znaků.\n   - Pomocí třídy `std::locale` můžete nastavit lokalizaci objektu `std::iostream` (nebo jiných tříd, které používají lokalizaci) a tím ovlivnit formátování vstupu a výstupu. Například můžete nastavit lokalizaci pro práci s číselnými formáty, datumy, měnami atd.\n\n   Příklad použití třídy `std::locale`:\n\n   ```cpp\n   #include <iostream>\n   #include <locale>\n\n   int main() {\n       std::locale mylocale(\"Czech_CzechRepublic.1250\");\n       std::wcout.imbue(mylocale);\n       \n       // Použití std::wcout s lokalizací\n       std::wcout << 12345.6789 << std::endl;\n\n       return 0;\n   }\n   ```\n\n2. **Funkce `std::setlocale`:**\n   - Funkce `std::setlocale` slouží k nastavení celkové kultury pro celý program. Může ovlivnit všechny operace formátování, nejen ty, které souvisejí s vstupem a výstupem.\n   - Tato funkce se často používá pro nastavení kultury pro operace s řetězci, datumy, časy atd.\n\n   Příklad použití funkce `std::setlocale`:\n\n   ```cpp\n   #include <iostream>\n   #include <clocale>\n\n   int main() {\n       // Nastavení celkové kultury na českou\n       std::setlocale(LC_ALL, \"Czech_CzechRepublic.1250\");\n\n       // Použití std::cout s nastavenou kulturou\n       std::cout << 12345.6789 << std::endl;\n\n       return 0;\n   }\n   ```\n\nJe důležité rozlišovat mezi těmito dvěma přístupy, protože `std::locale` je zaměřena na objekty, zatímco `std::setlocale` ovlivňuje celý program. Použití jednoho nebo druhého závisí na konkrétních požadavcích a potřebách aplikace."
        }
      ],
      "id": "MccqSsh2",
      "createdAt": 1710607419186,
      "updatedAt": 1710705313386
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "C/C++ vs C#",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++ a C# jsou oba programovací jazyky, ale existuje několik zásadních rozdílů mezi nimi. Zde jsou některé klíčové rozdíly:\n\n1. **Typy jazyků:**\n   - **C++:** Je to multiparadigmatický jazyk, což znamená, že umožňuje programování ve stylu procedurálním, objektově orientovaném a generickém.\n   - **C#:** Je navržený jako objektově orientovaný jazyk, který podporuje i některé funkcionální prvky.\n\n2. **Správa paměti:**\n   - **C++:** Vyžaduje ruční správu paměti. Programátor je zodpovědný za alokaci a dealokaci paměti.\n   - **C#:** Používá správu paměti s automatickým sběračem odpadu (garbage collector), což zjednodušuje práci s pamětí a snižuje riziko úniku paměti.\n\n3. **Platformní závislost:**\n   - **C++:** Kód může být kompilován a spuštěn na různých platformách bez potřeby velkých úprav (pokud se dodržují určité zásady).\n   - **C#:** Původně byl vyvinut společností Microsoft a primárně bývá používán na platformách, které podporují .NET Framework nebo .NET Core (např. Windows). Existují však i projekty jako Mono a .NET Core (nyní .NET 5 a vyšší), které umožňují běh C# na jiných platformách.\n\n4. **Kompilace vs. interpretace:**\n   - **C++:** Je kompilovaný jazyk, což znamená, že zdrojový kód je přeložen do strojového kódu před spuštěním.\n   - **C#:** Kód je kompilován do mezijazyka (Common Intermediate Language - CIL) a poté interpretován nebo převeden na strojový kód Just-In-Time (JIT) během běhu programu.\n\n5. **Syntaxe a paradigma:**\n   - **C++:** Podporuje nízkoúrovňové operace a umožňuje přímý přístup k paměti. Je vhodný pro systémové programování.\n   - **C#:** Má modernější syntaxi a je často považován za snazší na naučení. Je často používán pro vývoj desktopových a webových aplikací.\n\n6. **Standardní knihovny:**\n   - **C++:** Má rozsáhlou standardní knihovnu obsahující mnoho funkcí a tříd pro různé účely.\n   - **C#:** Využívá .NET Framework nebo .NET Core, které poskytují širokou škálu knihoven pro různé účely.\n\nCelkově lze říci, že výběr mezi C++ a C# závisí na konkrétních požadavcích projektu, preferencích programátora a cílové platformě. C++ se často používá v oblastech, kde je kritická rychlost a úroveň kontroly nad hardwarem, zatímco C# bývá oblíbený pro vývoj aplikací na platformách Microsoft a v obecnějších softwarových projektech."
        }
      ],
      "id": "pg9hF05W",
      "createdAt": 1710607802920,
      "updatedAt": 1710705293722
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "variadicka funkce",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Variadická funkce je funkce v programování, která umožňuje přijímat různý počet argumentů. To znamená, že při volání této funkce můžete předat libovolný počet hodnot, a funkce bude schopna s nimi pracovat.\n\nV mnoha programovacích jazycích jsou pro implementaci variadických funkcí speciální konstrukce. Například v jazyce C je pro vytvoření variadických funkcí používána knihovna <stdarg.h> a makra jako va_list, va_start a va_arg.\n\nVe funkci addNumbers můžete předat libovolný počet čísel jako argumenty a funkce je zpracuje a sečte. Variadické funkce jsou užitečné například v situacích, kdy není předem známo, kolik argumentů bude funkce potřebovat.\n\n#include <stdio.h>\n#include <stdarg.h>\n\n// Variadická funkce, která sčítá libovolný počet čísel\nint addNumbers(int count, ...) {\n    int sum = 0;\n    \n    va_list args;\n    va_start(args, count);\n\n    for (int i = 0; i < count; i++) {\n        sum += va_arg(args, int);\n    }\n\n    va_end(args);\n\n    return sum;\n}\n\nint main() {\n    printf(\"Součet: %d\\n\", addNumbers(3, 10, 20, 30)); // můžete předat více než tři čísla\n    return 0;\n}\n"
        }
      ],
      "id": "pouq2tzp",
      "createdAt": 1710608026475,
      "updatedAt": 1710705064976
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "lambda",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Můžeš mi popsat tuto funkci podrobně?\nauto shift = [&](unsigned val, int shift) {\n\treturn 1;\n};\n\nSamozřejmě, rád vám popíši tuto funkci.\n\nTato funkce je zapsána v jazyce C++ a využívá lambda výrazu (též nazývané anonymní funkce). Lambda výrazy umožňují vytvoření malých anonymních funkcí přímo v místě, kde jsou potřeba.\n\nZde je struktura lambda výrazu v této funkci:\n\n```cpp\nauto shift = [&](unsigned val, int shift) {\n    return 1;\n};\n```\n\n- `auto` umožňuje kompilátoru automaticky určit datový typ návratové hodnoty lambda funkce.\n- `shift` je název proměnné, která reprezentuje lambda funkci.\n- `[&]` je tzv. \"capture clause\" (část zachycení), která umožňuje lambda funkci přistupovat ke všem lokálním proměnným (včetně parametrů funkce) pomocí reference.\n- `(unsigned val, int shift)` jsou parametry lambda funkce. Parametry jsou předávány hodnotami, ale díky capture clause můžeme přistupovat i k lokálním proměnným funkcí.\n- `{ return 1; }` je tělo lambda funkce. V tomto případě vrací konstantní hodnotu 1.\n\nCelkově řečeno, tato lambda funkce s názvem `shift` bere dva parametry (`unsigned val` a `int shift`), ale bez ohledu na jejich hodnoty vrací vždy 1. Přístup k hodnotám parametrů i k dalším lokálním proměnným je umožněn díky capture clause `[&]`.\n\nA co tedy provádí tato funkce?\nauto shift = [&](unsigned val, int shift) {\n\treturn ((val & 0xff) << shift);\n};\n\nTato funkce, opět zapsaná v jazyce C++ s použitím lambda výrazu, se nazývá `shift` a má následující strukturu:\n\n```cpp\nauto shift = [&](unsigned val, int shift) {\n    return ((val & 0xff) << shift);\n};\n```\n\nPojďme rozebrat, co tato funkce provádí:\n\n1. `unsigned val` a `int shift` jsou parametry lambda funkce.\n2. Tělo lambda funkce je obsaženo mezi `{}`. V tomto těle se provádí bitová operace.\n\n   ```cpp\n   (val & 0xff)\n   ```\n\n   Tato část kódu provádí bitovou operaci AND mezi hodnotou `val` a číslem 0xff (hexadecimálně 255). Tímto se zajistí, že jsou zachovány pouze první 8 bitů (byte) z hodnoty `val`, zbytek je nulován.\n\n3. Poté se provede bitový posun vlevo o hodnotu `shift`:\n\n   ```cpp\n   << shift\n   ```\n\n   Tato část posouvá všechny bity výsledku bitové operace o `shift` pozic doleva.\n\n4. Celý výsledek je pak vrácen z lambda funkce.\n\nCelkově tato funkce tedy provádí bitovou operaci AND mezi hodnotou `val` a 0xff, a následně provede bitový posun vlevo o hodnotu `shift`. Tímto se obvykle dosahuje vytvoření masky na prvních 8 bitech a následný posun této masky o určitý počet pozic."
        }
      ],
      "id": "xo8zh7IC",
      "createdAt": 1710608226576,
      "updatedAt": 1710705064943
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Ukazatel na funkci",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "int (*isEven)(int) = (int(*)(int))code;\n\nTento kód v C++ vytváří ukazatel na funkci s názvem `isEven`, která přijímá jeden argument typu `int` a vrací hodnotu typu `int`. Tato funkce bude ukazovat na adresu paměti, kterou určuje proměnná `code`.\n\nPřepisujeme to do lidsky čitelnější podoby:\n\n```cpp\n// Definice typu funkce, která přijímá int a vrací int\ntypedef int (*IsEvenFunctionPointer)(int);\n\n// Vytvoření proměnné typu IsEvenFunctionPointer s názvem isEven\nIsEvenFunctionPointer isEven = (IsEvenFunctionPointer)code;\n```\n\nToto umožňuje dynamicky definovat funkci na základě adresy paměti, kterou určuje proměnná `code`. Tímto způsobem můžete vytvářet ukazatele na funkce za běhu programu, což poskytuje určitou flexibilitu a dynamiku v programování. Obvykle se tato technika používá v pokročilých scénářích, jako je manipulace s bajtovým kódem nebo interpretací kódu."
        }
      ],
      "id": "I7gLgypT",
      "createdAt": 1710608333250,
      "updatedAt": 1710705064916
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "what is an Alocator",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Samotný termín \"alokátor\" v C++ může mít několik významů, ale nejčastěji se odkazuje na třídu nebo objekt, který je zodpovědný za alokaci a dealokaci paměti pro objekty. Standardní knihovna C++ obsahuje několik výchozích alokátorů, ale také umožňuje vlastní implementaci alokátorů pro přizpůsobení chování alokace paměti podle specifických potřeb programu.\n\nZákladním principem alokátoru v C++ je oddělení procesu alokace paměti od samotného objektu. To znamená, že alokátor je zodpovědný za vyhrazení paměti a uvolnění paměti, zatímco samotný objekt má na starosti konstrukci a destrukci.\n\nPro práci s alokátory jsou ve standardní knihovně C++ definovány dvě základní třídy: `std::allocator` a `std::allocator_traits`. `std::allocator` je základní třídou alokátoru, která poskytuje metody pro alokaci a dealokaci paměti. `std::allocator_traits` pak poskytuje rozhraní pro obecné operace s alokátory.\n\nPři implementaci vlastního alokátoru je obvyklé předefinovat několik metod, jako jsou `allocate`, `deallocate`, `construct` a `destroy`. Tyto metody jsou volány při vytváření, mazání a rušení objektů.\n\nZde je jednoduchý příklad vlastního alokátoru v C++:\n\n```cpp\n#include <memory>\n\ntemplate <typename T>\nclass MyAllocator {\npublic:\n    using value_type = T;\n\n    MyAllocator() noexcept {}\n\n    template <typename U>\n    MyAllocator(const MyAllocator<U>&) noexcept {}\n\n    T* allocate(std::size_t n) {\n        return static_cast<T*>(::operator new(n * sizeof(T)));\n    }\n\n    void deallocate(T* p, std::size_t n) noexcept {\n        ::operator delete(p);\n    }\n\n    template <typename... Args>\n    void construct(T* p, Args&&... args) {\n        new (p) T(std::forward<Args>(args)...);\n    }\n\n    void destroy(T* p) {\n        p->~T();\n    }\n};\n\n// Příklad použití vlastního alokátoru:\nint main() {\n    using MyIntAllocator = MyAllocator<int>;\n    std::allocator<int> stdAllocator;\n\n    // Použití vlastního alokátoru\n    std::vector<int, MyIntAllocator> myVector(10, MyIntAllocator());\n\n    // Použití standardního alokátoru\n    std::vector<int, std::allocator<int>> stdVector(10, stdAllocator);\n\n    return 0;\n}\n```\n\nV tomto příkladu je definován jednoduchý `MyAllocator` pro alokaci a dealokaci paměti pro objekty typu `T`.\n\nDíky velmi přehledné. A pokud bych chtěl podobně zavolat vlastní použití alokátoru pro typ string?\n\nPokud chcete použít vlastní alokátor pro typ `std::string`, můžete postupovat podobně jako ve předchozím příkladu. Předefinujte třídu alokátoru a použijte ji jako šablonový parametr pro `std::basic_string`. Zde je příklad:\n\n```cpp\n#include <iostream>\n#include <memory>\n#include <string>\n\n// Definice vlastního alokátoru pro std::string\ntemplate <typename CharT, typename Alloc = std::allocator<CharT>>\nclass MyStringAllocator {\npublic:\n    using value_type = CharT;\n    using allocator_type = Alloc;\n\n    MyStringAllocator(const Alloc& alloc = Alloc()) noexcept : allocator(alloc) {}\n\n    CharT* allocate(std::size_t n) {\n        return allocator.allocate(n);\n    }\n\n    void deallocate(CharT* p, std::size_t n) noexcept {\n        allocator.deallocate(p, n);\n    }\n\n    template <typename... Args>\n    void construct(CharT* p, Args&&... args) {\n        allocator.construct(p, std::forward<Args>(args)...);\n    }\n\n    void destroy(CharT* p) {\n        allocator.destroy(p);\n    }\n\nprivate:\n    Alloc allocator;\n};\n\n// Definice vlastního typu string s vlastním alokátorem\nusing MyString = std::basic_string<char, std::char_traits<char>, MyStringAllocator<char>>;\n\nint main() {\n    // Použití vlastního alokátoru pro std::string\n    MyString myStr(\"Hello, Custom Allocator!\");\n\n    // Výpis řetězce\n    std::cout << myStr << std::endl;\n\n    return 0;\n}\n```\n\nV tomto příkladu je definována třída `MyStringAllocator`, která slouží jako alokátor pro `std::basic_string<char>`. Poté je vytvořen alias `MyString`, který používá tuto třídu alokátoru. Při vytváření objektu `MyString` je automaticky použit vlastní alokátor pro správu paměti pro řetězec.\n\n"
        }
      ],
      "id": "07uy9PRM",
      "createdAt": 1710608438532,
      "updatedAt": 1710705070669
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "MessageBox ",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <Windows.h>\n\nint main() {\n    MessageBox(NULL, \"Toto je upozorneni ve Windows!\", \"Upozorneni\", MB_OK | MB_ICONINFORMATION);\n    return 0;\n}\n"
        }
      ],
      "id": "FlyOnhaS",
      "createdAt": 1710608545720,
      "updatedAt": 1710704995988
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "získat počet elementů ukazatele string *jaky;",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Jak získám počet elementů ukazatele jaky?\n\nstring *jaky;\njaky = new string []\n    {\"Tlusty\",\"Maly\", \"Rychly\", \"Nejlepsi\", \"Nejhorsi\", \"Modry\", \"Automatizovany\"};\n    \n\n Pro získání počtu prvků v dynamickém poli v C++ nemůžete použít sizeof ukazatele, protože to vrátí pouze velikost ukazatele, ne celého pole.\n\nSprávným způsobem je využít operátoru sizeof v kombinaci s datovým typem pole, ale v tomto případě to bude komplikované, protože máte dynamické pole.\n\nJedním z řešení je přidat nějaký speciální prvek na konec pole (například prázdný řetězec) a následně iterovat přes pole, dokud nenarazíte na tento speciální prvek. Zde je příklad\n\n#include <iostream>\n#include <string>\nint main() {\n    std::string *jaky;\n    jaky = new std::string[]\n        {\"Tlusty\",\"Maly\", \"Rychly\", \"Nejlepsi\", \"Nejhorsi\", \"Modry\", \"Automatizovany\", \"\"};\n\n    int pocetPrvku = 0;\n\n    // Iterace přes pole, dokud nenarazíme na prázdný řetězec\n    while (!jaky[pocetPrvku].empty()) {\n        pocetPrvku++;\n    }\n\n    std::cout << \"Pocet prvku v poli: \" << pocetPrvku << std::endl;\n\n    // Uvolnění paměti alokované pro pole\n    delete[] jaky;\n\n    return 0;\n}\n"
        }
      ],
      "id": "iAsCCKvS",
      "createdAt": 1710608761063,
      "updatedAt": 1710704987570
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Simple Dynamic C++ Class as array of type int",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Vytvoření třídy v C++ pro dynamické pole typu `int` zahrnuje definici konstruktoru, destruktoru, a dalších potřebných metod. Následující příklad ukazuje jednoduchou třídu nazvanou `DynamicIntArray`, která simuluje chování dynamického pole `int`:\n\n```cpp\n#include <iostream>\n\nclass DynamicIntArray {\nprivate:\n    int* array;  // Ukazatel na dynamické pole\n    int size;    // Velikost pole\n\npublic:\n    // Konstruktor pro vytvoření pole s danou velikostí\n    DynamicIntArray(int s) : size(s) {\n        array = new int[size];\n        std::cout << \"Vytvoreno dynamicke pole s velikosti: \" << size << std::endl;\n    }\n\n    // Destruktor pro uvolnění alokované paměti\n    ~DynamicIntArray() {\n        delete[] array;\n        std::cout << \"Pamet uvolnena.\" << std::endl;\n    }\n\n    // Metoda pro přístup k prvkům pole\n    int& operator[](int index) {\n        if (index < 0 || index >= size) {\n            std::cerr << \"Index mimo rozsah!\" << std::endl;\n            // Můžete také vyvolat výjimku nebo přijmout jiný postup.\n        }\n        return array[index];\n    }\n\n    // Metoda pro získání velikosti pole\n    int getSize() const {\n        return size;\n    }\n};\n\nint main() {\n    // Vytvoření instance DynamicIntArray\n    DynamicIntArray myArray(5);\n\n    // Přístup k prvkům pole a jejich nastavení\n    for (int i = 0; i < myArray.getSize(); ++i) {\n        myArray[i] = i * 10;\n    }\n\n    // Výpis prvků pole\n    for (int i = 0; i < myArray.getSize(); ++i) {\n        std::cout << \"myArray[\" << i << \"] = \" << myArray[i] << std::endl;\n    }\n\n    return 0;\n}\n```\n\nV tomto příkladu třída `DynamicIntArray` obsahuje konstruktor, destruktor, metodu pro přístup k prvkům pole a metodu pro získání velikosti pole. Operátor `[]` je přetížen pro jednoduchý přístup k prvkům pole. Třída také obsahuje ukazatel na dynamické pole a velikost pole, a destruktor uvolňuje alokovanou paměť."
        }
      ],
      "id": "nHcIQpZs",
      "createdAt": 1710609010209,
      "updatedAt": 1710704987547
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Stiknete enter pro potvrzeni doporucenych",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\n\nint main() {\n    // Výchozí doporučené znaky\n    std::string doporuceneZnaky = \"default\";\n\n    // Zobrazení doporučených znaků a instrukce pro potvrzení\n    std::cout << \"Doporucene znaky: \" << doporuceneZnaky << std::endl;\n    std::cout << \"Potvrdte vstup stiskem Enteru (nechte prazdne pro pouziti doporucenych znaku): \";\n\n    // Čekání na potvrzení uživatelem stiskem Enteru\n    std::string potvrzeni;\n    std::getline(std::cin, potvrzeni);\n\n    // Pokud je vstup prázdný, použijte doporučené znaky\n    if (potvrzeni.empty()) {\n        std::cout << \"Zvolili jste pouziti doporucenych znaku.\" << std::endl;\n        potvrzeni = doporuceneZnaky;\n    } else {\n        std::cout << \"Zadali jste vlastni vstup.\" << std::endl;\n    }\n\n    // Použití vstupu\n    std::cout << \"Zadali jste: \" << potvrzeni << std::endl;\n\n    return 0;\n}\n"
        }
      ],
      "id": "UZzPrRZ7",
      "createdAt": 1710609755188,
      "updatedAt": 1710704995948
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ahtjgpcH",
      "tagsIds": [],
      "description": null,
      "name": "get all git repos",
      "content": [
        {
          "label": "Fragment 1",
          "language": "sh",
          "value": "find / -name .git -type d -exec dirname {} \\;"
        }
      ],
      "id": "vO9eTVKV",
      "createdAt": 1710705444638,
      "updatedAt": 1711618699599
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Seznam vs Slovnik",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Seznam:\n\nvector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nbool foundInNumbers(int number) {\n    return find(numbers.begin(), numbers.end(), number) != numbers.end();\n}\n\nSlovník:\nmap<int, string> numbers = {\n    {1, \"jedna\"},\n    {2, \"dva\"},\n    {3, \"tři\"},\n    {4, \"čtyři\"},\n    {5, \"pět\"},\n    {6, \"šest\"},\n    {7, \"sedm\"},\n    {8, \"osm\"},\n    {9, \"devět\"},\n    {10, \"deset\"}\n};\n\nbool foundInNumbers(int number) {\n    return numbers.find(number) != numbers.end();\n}\n"
        }
      ],
      "id": "9KGSIEHM",
      "createdAt": 1710915516490,
      "updatedAt": 1710915567107
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Method chaining",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": " Network& setRemoteHostName(string remoteHostName)\n    {\n        this->remoteHostName = remoteHostName;\n        return *this;\n    }\n    \n // server\n net.setBindHostName(\"192.168.79.101\") .setBindPort(7995)\n .setMaxClients(4).setChannels(2).setAmountIn(0).setAmountOut(0);\n\n// client\nnet.setRemoteHostName(\"192.168.79.101\").setRemotePort(7995)\n.setOutConnections(1);\n.initENet();    \n\n"
        }
      ],
      "id": "DDJOaO2c",
      "createdAt": 1710915624442,
      "updatedAt": 1710916870356
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Best Practice of OOP",
      "content": [
        {
          "label": "Fragment 1",
          "language": "markdown",
          "value": "### SOLID\n\tSingle responsibility principle\n\tOpen/closed principle\n\tLiskov substitution principle\n\tInterface Segregation Principle\n\tDependency Inversion Principle\t\n\n### STUPID\n\tSingleton\n\tTight coupling - těsné vazby\n\tUntestability\n\tPremature optimization\n\tIndescriptive naming\n\tDuplication\n    \n### KISS \n\tKeep It Simple,\tstupid!\n\n### SRP \n\tSingle Responsibility Principle.\nZkráceně SRP, říká, že každý kus kódu, např. třída, by měl být zodpovědný za jednu konkrétní věc.\nclass CustomerManager {...\nclass InvoiceManager {...\nclass WarehouseManager {...\n\n### SoC\n\tSeparation of Concerns.\nRozdělení zájmu, je princip podobný SRP. Hlavně pro aplikační logiku.\n\tkomunikace s uživatelem (vstup i výstup)\n\tlogické operace a práce s daty\n\tdefinice dat\n\n### Shy \n\tKeep it DRY, shy, and tell the other guy.\nJak je to se stydlivým kódem? Stydlivý kód se chová úplně stejně, jako stydliví lidé. Komunikuje s ostatním kódem tedy jen když je to nezbytně potřeba a nemá ani více informací o ostatních, než sám nezbytně potřebuje. SHY je vlastně jiné označení pro zákon Deméter, viz níže.\n\n### LoD \n\tLaw of Demeter.\nzákon Deméter, řecké Bohyně úrody, je v podstatě o low/loose coupling, tedy o udržování nejmenšího možného počtu vazeb mezi komponentami. Je definován třemi pravidly, kde zavádí pojem jednotka pro\nzapouzdřenou část kódu, tedy pro třídu:\n\n\tKaždá jednotka by měla mít omezenou znalost o ostatních jednotkách,\n\tpouze jednotkách, které jsou dané jednotce blízké.\n\tKaždá jednotka by měla \"mluvit\" pouze se svými \"přáteli\", nemluvte s\n\tcizími.\n\tMluvte pouze se svými přímými přáteli.\n\nZ pravidel je vidět, že každý objekt by měl být univerzální a\nnaprosto odstíněný od zbytku aplikace. Znát minimum informací o\ncelku a sdílet minimum informací o sobě celku.\nZdroj: https://www.itnetwork.cz/navrh/best-practices-pro-vyvoj-softwaru/zakladni-best-practices-pro-navrh-softwaru\n\n### IoC\nPrincip Inversion of Control byste měli dobře znát. Jedná se o skupinu návrhových vzorů, jejíž součástí je i populární Dependency Injection, jediný správný způsob, jak v objektových aplikacích závislosti předávat. IoC tvrdí, že objekty v aplikaci by měly být řízené nějakým vyšším mechanismem, který vytváří instance tříd a předává jim potřebné závislosti. To je opačný přístup ke staršímu způsobu práce se závislostmi, kdy si\ntříty své závislosti vytahovaly samy ze systému, např. přes Singleton\nnebo jiné antipatterny. Jelikož se jedná o extrémně důležitou problematiku, připravili jsme pro vás o DI samostatný kurz Softwarové architektury a depencency injection, kde je podrobně vysvětlena na reálných příkladech.\n\n"
        }
      ],
      "id": "CyjP_I7e",
      "createdAt": 1710916997355,
      "updatedAt": 1710920141155
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Adapter - Wrapper",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": ""
        }
      ],
      "id": "krkOmbhV",
      "createdAt": 1710918372276,
      "updatedAt": 1710918379253
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "vlastní implementace cout ostream",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "\nclass LogUserInterface\n{\npublic:\n    template<typename T>\n\t// pretizeni ktere zajisti pouziti tridy\n\tLogUserInterface& operator<<(const T& value)\n    {\n        std::cout << value;\n        return *this;\n    };\n    // Specialized method for manipulators of stream (ex. std::endl)\n    typedef std::ostream& (*Manipulator)(std::ostream&);\n    LogUserInterface& operator<<(Manipulator manip)\n    {\n        std::cout << manip; // manipulator application to standard output\n        return *this;\n    }\n};\n\nclass LogDebugInterface\n{\npublic:\n    template<typename T>\n    LogDebugInterface& operator<<(const T& value)\n    {\n        std::cout << value;\n        return *this;\n    };\n\n    // Specialized method for manipulators of stream (ex. std::endl)\n    typedef std::ostream& (*Manipulator)(std::ostream&);\n    LogDebugInterface& operator<<(Manipulator manip)\n    {\n        std::cout << manip; // manipulator application to standard output\n        return *this;\n    }\n};"
        }
      ],
      "id": "FyN9dJKz",
      "createdAt": 1710924205385,
      "updatedAt": 1710939160467
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "Vlastnosti algoritmů",
      "content": [
        {
          "label": "Fragment 1",
          "language": "markdown",
          "value": "\tElementární\nAlgoritmus se musí skládat z konečného počtu jednoduchých\na snadno srozumitelných kroků, tedy příkazů.\n\tDeterminované\nDalší důležitou vlastností algoritmu je, že musí být determinovaný. V každém kroku musí jít určit, zda proces\nskončil a pokud ne, lze jednoznačně říci, jak bude pokračovat.\n\tObecné a Konečné\nAlgoritmus by měl také skončit se správným výsledkem a pokrýt tedy všechny vstupy. V našem jednoduchém případě by měl prohodit proměnné tehdy, zda bude a = 10; b = 20; a i tehdy, zda bude a = 999; b = 102. Hovoříme zde o tom, že algoritmus je obecný. Algoritmus musí být také\nkonečný. Nemůže si dovolit se někde zacyklit, vždy musí\nskončit s konečným počtem kroků.\n\tStabilní\nO stabilním algoritmu hovoříme v případě, kdy zachovává předchozí pořadí takových prvků, které si jsou podle porovnávacího kritéria rovny. Pokud třídíme pole čísel, nemá to pro nás žádný užitek. Ale ve chvíli, kdy třídíme např. objekty nebo nějaké další kontejnerové struktury, může se nám to velmi hodit.\n\nDejme tomu, že máme zaměstnance seřazené v poli podle\nabecedy. A my je chceme seřadit podle věku. Pokud řadící\nalgoritmus není stabilní, může se nám stát, že dva stejně staří zaměstnanci (Adam a Zdeněk) budou v pořadí: Zdeněk, Adam. Stabilní algoritmus naopak v případě rovnosti zachová původní pořadí prvků, tedy Adam, Zdeněk. Zaměstnanci se stejným věkem tedy budou ještě seřazeni podle abecedy.\n\tNa místě\nTřídíme na místě tehdy, pokud nepotřebujeme kromě vstupního pole žádnou dodatečnou paměť. Pokud ano, vzniká nebezpečí, zda budeme mít paměti vždy dostatek. Za tento paměťový handicap někdy můžeme dostat lepší časovou složitost nebo jiné výhody. V anglické\nliteratuře se setkáme s termínem \"In place\". \n\n"
        }
      ],
      "id": "JEL9dK1Y",
      "createdAt": 1711007782221,
      "updatedAt": 1711618650123
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "Časová složitost O(n2)",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": ""
        }
      ],
      "id": "V6rYhA2u",
      "createdAt": 1711008920027,
      "updatedAt": 1711618650124
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "Binární vyhledávání - vyhledavaci strom",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Recepty z programátorské kuchařky\nBinární vyhledávání\nZobraz historii verzí\nAktuální verze kuchařky: prosinec 2017\n\nBinární vyhledávání je mocná technika, která se objevuje ve všemožných algoritmech a úlohách. Obecně spočívá ve využívání monotónnosti nějakého pole nebo funkce k rychlejšímu prohledávání. To zní pravděpodobně velmi nejasně; začneme proto konkrétnějšími příklady a budeme postupně zobecňovat.\n\nVe své nejjednodušší podobě je binární vyhledávání technika, která nám umožní rychle prohledávat seřazené pole. Řekněme, že máme vzestupně setříděné pole A, o kterém víme, že obsahuje číslo k. Chceme zjistit, jaký má k index v poli, čili pro jaké i platí A[i] = k. Budeme v podstatě hádat, který index to je, a zpřesňovat náš odhad. Napřed odhadneme index v polovině pole (ten označíme mid jako middle, čili střed).\n\n    Pokud A[mid] = k, je hotovo.\n    Pokud A[mid] < k, všechny prvky A nalevo od mid musí být také menší než k. Proto vyhledávání spustíme znovu, ale pouze na prvcích napravo od mid (samozřejmě už bez mid).\n    Pokud A[mid] > k, analogicky spustíme vyhledávání na levé polovině.\n\nPokud pole nemá přesný střed (má sudou délku), zvolíme za mid a libovolný ze dvou prostředních indexů.\n\nŘekněme například, že chceme v poli [1, 4, 5, 7, 11, 16, 20] zjistit index čísla 11. Vyhledávání bude postupovat takto:\nPostup binárního vyhledávání na příkladu\n\nVýsledek je tedy 4. Stačilo nám podívat se na tři prvky, takže výrazně méně než 7 v naivním prohledávání.\n\nProtože délka intervalu, na kterém hledáme, se v každé iteraci zmenší alespoň na polovinu, po i-té iteraci bude mít interval délku nejvýše N / 2i (kde N je délka pole). Celkem proto provedeme maximálně log2 N iterací, než se dostaneme na délku 1. Časová složitost je proto O(log N).\n\nNejintuitivnější je asi rekurzivní představa, která v kódu vypadá takto:\n\nint A[n]; // dané pole\n// Vyhledávání čísla k, pokud víme, že se\n// nachází někde v intervalu <l, r>.\n// Při použití voláme indexPrvku(0, n-1, k),\n// abychom prohledávali celé pole.\nint indexPrvku(int l, int r, int k) {\n    if (l > r)  // voláme se na prázdný úsek\n        return -1;  // zde hledané k určitě není\n\n    int mid = (l + r) / 2;  // průměr hranic\n    if (A[mid] == k) {  // hotovo\n        return mid;  // mid je hledaný index\n    } else if (A[mid] < k) {  // chceme víc\n        // spusť na pravé půlce (ale už bez mid)\n        return indexPrvku(mid + 1, r, k);\n    } else {  // poslední možnost: chceme méně\n        // spusť na levé polovině\n        return indexPrvku(l, mid - 1, k);\n    }\n}\n\n    C\n    Python 3\n\nMůže se nám stát, že hledané k v poli neleží. To při vyhledávání poznáme tak, že se nám interval, kde k ještě může být, zmenší na prázdný. Komentáře kód značně prodlužují, ale v praxi je to opravdu jen pár řádků. Častěji se však používá implementace, kde místo rekurze použijeme cyklus. Převod je jednoduchý, uvedeme si tedy i tuto verzi:\n\nint A[n];  // dané pole\nint indexPrvku(int k, int n) {\n    // Po celou dobu platí, že k se musí\n    // nacházet někde v intervalu <l, r>.\n    int l = 0, r = n - 1;\n    while (l <= r) {\n        // dokud je interval <l, r> neprázdný\n        int mid = (l + r) / 2;\n        if (A[mid] == k) {\n            return mid;\n        } else if (A[mid] < k) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return -1;\n    // Pole neobsahuje k,\n    // jinak bychom ho už našli.\n}\n\n    C\n    Python 3\n\nBinární vyhledávání přes funkce\n\nUvažme, jak by se kód změnil, kdybychom pole A neměli uložené v paměti, ale načítali bychom ho například z disku nebo po síti. Pak bychom nejspíš měli nějakou funkci f, které bychom se mohli ptát na jednotlivé indexy a ona by nám vracela příslušné hodnoty. Jediná změna by pak byla v tom, že bychom se místo přistupování k prvkům pole ptali této funkce na odpovídající indexy.\n\nBinární vyhledávání je totiž mnohem mocnější než prosté vyhledávání v poli. Naše funkce pro binární vyhledávání nyní vlastně nepracuje s žádným polem, jen s nějakou funkcí f. Za tu ale můžeme dosadit něco úplně jiného než jen prvky pole. Musíme však dodržet vlastnost, že f je neklesající, aby mohlo vyhledávání fungovat (stejně tak by mohla být nerostoucí, ale tento připad je analogický, takže se budeme zabývat pouze neklesajícími funkcemi).\n\nZkusíme tedy za f dosadit něco jiného. Řekněme, že chceme pomocí binárního vyhledávání umět počítat třeba druhou odmocninu čísla: máme dané číslo x a chceme najít číslo mid ≥ 0 takové, že mid je odmocnina z x. Jinak řečeno, mid2 = x. Binárním vyhledáváním úlohu vyřešíme tak, že budeme hádat čísla mid a vždy srovnáme f(mid) = mid2 s x. Pokud je mid2 větší než x, mid je větší, než chceme. Horní hranici proto nastavíme na toto mid. A naopak, pokud je mid2 menší, nastavíme spodní hranici na toto mid. Důležité je, že pro kladná mid je funkce f neklesající, jinak bychom na ní binárně vyhledávat nemohli.\n\nNa obrázku je případ, kdy hledáme odmocninu ze dvou. V první iteraci jsme mid odhadli na 1 a f(mid) je proto taky 1, takže méně než x (které je 2). Zahodíme proto levou polovinu.\nObrázek binárního vyhledávání na kvadratické funkci\n\nProtože odmocnina může být iracionální, nemůžeme předpokládat, že ji dokážeme spočítat přesně, tzn. že by nastal případ mid2 = x. Odmocninu tedy jen aproximujeme. Pro takovéto aproximační úlohy stačí cyklus zopakovat dostatečněkrát, abychom získali rozumnou přesnost. Přesnost se velmi rychle zvyšuje (s každou iterací se velikost intervalu, kde se může nacházet výsledek, zmenší na polovinu), a proto většinou stačí třeba 100 iterací.\n\nDrobný, ale podstatný detail je volba intervalu ⟨ℓ, r⟩, ve kterém vyhledávání začínáme – pokud hledané mid leží mimo tento interval (tj. neplatí, že f(ℓ) ≤ f(mid) ≤ f(r)), algoritmus samozřejmě nemůže fungovat. Pro náš příklad s f(x) = x2 jsme zvolili ℓ= 0, r = max(1, x), rozmyslete si, proč tato volba funguje.\n\nV kódu:\n\ndouble f(double a) {\n    return a * a;\n}\ndouble odmocnina(double x) {\n    double l = 0, r = max(x, 1);\n    for (int it = 0; it < 100; it++) {\n        double mid = (l + r) / 2;\n        if (f(mid) < x) l = mid;  // chceme víc\n        else r = mid;  // chceme míň\n    }\n    return l;\n    // l a r jsou dostatečně blízko,\n    // je jedno, ktere vrátíme\n}\n\n    C\n    Python 3\n\nKód je velmi podobný předchozímu, přestože dělá něco docela jiného. Oproti minule nepracujeme s celými čísly, ale s čísly reálnými. Z toho plynou změny, které jsme vysvětlili výše. Případ f(mid) == x přeskakujeme proto, že chceme jen dostatečně dobrý odhad a v naprosto přesný výsledek nedoufáme.\n\nFunkce f je nyní úplně jiná než předtím, ale vyhledávání funguje analogicky. Důležité je, že hodnotu f zjišťujeme tolikrát, kolik proběhne iterací cyklu (zde stokrát, v celočíselném případě O(log N)-krát), takže jen málokrát. Její výpočet tak může být i poměrně pomalý a celý program poběží pořád rychle – samozřejmě jen v porovnání s tím, kdybychom si počítali všechny funkční hodnoty; bude-li nás výpočet jedné hodnoty stát třeba O(2N) času, ani binární vyhledávání nás nespasí.\nJak se vypořádat se stejnými hodnotami\n\nPřesuňme se zpět do celých čísel. Hned v příkladu s vyhledáváním v poli jsme opomenuli případ, kdy se nějaké číslo v poli vyskytuje víckrát. V takových případech chceme zpravidla najít první nebo poslední pozici prvku. Takto můžeme například najít v seřazeném poli poslední prvek, který má hodnotu maximálně k. Pokusme se k tomuto účelu binární vyhledávání upravit.\n\nExistuje několik způsobů, jak se s tím vypořádat, ale často bývají náchylné na chyby, zejména na plus-minus-jedničkové. Nejjednodušší je pamatovat si nejvyšší index pole, který podmínku splňuje, a ve vyhledávání pokračovat jako obvykle, dokud se nám interval nezmenší na nulový nebo záporný. Může to vypadat takto:\n\n\nint A[n];  // dané pole\nbool neniVetsiNezK(int x, int k) {\n    // není větší než k, takže je možným řešením\n    return A[x] <= k;\n}\nint nejvetsiPrvekNeVetsiNezK(int n, int k) {\n    int l = 0, r = n - 1;\n    int nejlepsi = -1;\n    while (l <= r) {\n        // dokud není interval prázdný\n        int mid = (l + r) / 2;\n        if (neniVetsiNezK(mid, k)) {\n            nejlepsi = mid;\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return nejlepsi;\n    // Pokud žádný prvek nesplňuje podmínku,\n    // vrátí se -1\n}\n\n    C\n    Python 3\n\nVšimněme si, že když najdeme prvek, který podmínku splňuje, zmenšíme interval na pravou polovinu. To znamená, že když pak najdeme další prvek, který také podmínku splňuje, bude nutně lepší. Proto můžeme nejlepsi nastavit rovnou na mid bez jakýchkoli srovnání.\nVyhledávání podle predikátu\n\nSchválně používáme frázi „prvek, který splňuje podmínku“ místo něčeho jako „prvek, který není větší než k“. Můžeme totiž udělat další abstrakci – při vyhledávání nám nezáleží na porovnávání nějakých čísel, jen na tom, jestli prostřední hodnota splňuje nějakou podmínku, čili predikát. Důležité je, že tento predikát je „nerostoucí“, čili na začátku je na nějakém úseku vždy splněný (vrátí true) a dále už nikdy. My hledáme právě hranici mezi těmito částmi: nejvyšší hodnotu, pro kterou funkce vrátí true.\n\nFormálně, predikát p(x) musí splňovat:\np(x) = false ⇒ (y > x ⇒ p(y) = false).\n\nTo znamená, že když někde predikát není splněn, dále už nebude splněn nikde.\n\nPredikát je v tomto případě f(mid) >= hledany, ale klidně by to mohlo být něco jako „je možné vyskládat x koní na šachovnici tak, aby se neohrožovali?“ Tímto způsobem můžeme řešit úlohy typu „najděte největší k, pro které ještě platí podmínka“. Někdy se totiž stává, že původní problém není možné jednoduše zodpovědět, ale dokážeme rychle (řekněme v O(N) nebo O(N log N)) odpovědět na dotazy typu: „Platí ještě pro dané k podmínka?“ Pak stačí implementovat tyto dotazy a binární vyhledávání nám dá odpověď. Například úlohu „Kolik nejvíce koní je možné umístit na šachovnici tak, aby se neohrožovali?“ můžeme redukovat na „Je možné vyskládat x koní na šachovnici tak, aby se neohrožovali?“ za použití binárního vyhledávání.\n\nUveďme příklad (zjednodušení P-I-1 z MO-P 2015): Máme hotel, který má N (max. 106) pater. V každém patře je jeden pokoj. Postupně se do hotelů ubytovává H hostů (H ≤ N), z nichž i-tý může být ubytován maximálně v patře ai (protože se bojí výšek). Kolik hostů dokážeme ubytovat, než budeme muset nějakého odmítnout, protože se nikam nevejde?\n\nŘešení: Dokážeme jednoduše zjistit, zda dokážeme ubytovat prvních K hostů. Stačí vzít prvních K, tuto posloupnost seřadit a pak zabírat patra odspoda – host s největším strachem z výšek do prvního patra a tak dále. To zabere O(N log N) času. S touto podmínkou už spustíme binární vyhledávání a dostaneme odpověď za O(N log 2 N) času.\n\nNe vždy je predikátová forma úlohy jednodušší než původní úloha, třeba při hledání nejkratší cesty nedokážeme rychle zjistit, zda existuje cesta dlouhá maximálně x. Vždy je ale dobré se zamyslet, zda by binární vyhledávání mohlo pomoci.\nPříklady\nPapír\n\n(Těžší verze této úlohy byla zadána jako úloha D na ACM ICPC World Finals 2015.)\n\nMáme obdélníkový papír, ve kterém jsou vystřihnuté díry ve tvaru kruhu. Všechny díry jsou celé uvnitř papíru a nepřekrývají se. Kde máme vést řez papírem rovnoběžný s osou x tak, aby byl papír rozdělen na dvě části o stejném obsahu? Děr může být až 100 000.\nVzducholoď\n\n(Převzata z Codeforces, úloha 590B.)\n\nLetíme vzducholodí a chceme se dostat z bodu A do bodu B (body jsou zadané souřadnicemi), ale situace je komplikovaná větrem. Otáčení vzducholodi netrvá žádný čas, ale vzducholoď má maximální rychlost v (oproti vzduchu). Prvních t sekund vane vítr s vektorem (wx, wy), po t sekundách se změní na vektor (ux, uy) a v tomto směru už zůstane.\n\nFormálně, pokud má vzducholoď oproti větru nulovou rychlost a je na [x, y] a vane vítr (ux, uy), po τ sekundách bude vzducholoď na [x + τ·ux, y + τ·uy]. Maximální rychlost vzducholodi je vždy větší než velikost vektoru větru.\n\nZa jak dlouho se nejrychleji dostaneme z A do B? (Maximální povolená odchylka je 10-6.)"
        }
      ],
      "id": "yw_s4_qp",
      "createdAt": 1711009813680,
      "updatedAt": 1711618650124
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Efektivní Selection Short",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n\nusing namespace std;\n\n\nint* selectionSort(int * numbers, int length) {\n  for (int i = 0; i < (length - 1); i++) {\n    int indexMin = i;\n    for (int j = i + 1; j < length; j++) {\n      if (numbers[j] < numbers[indexMin]) {\n        indexMin = j;\n      }\n    }\n    int next = numbers[i];\n    numbers[i] = numbers[indexMin];\n    numbers[indexMin] = next;\n  }\n  return numbers;\n}\n\nint main()\n{\n    cout << \"Hello world!\" << endl;\n\n    int setridit[] {9,8,7,6,5,4435,7,56,74476,554,54,58,4,3};\n    int* setrizeno; // ukazatel na setridene pole\n\n    for (auto index: setridit)\n        cout << index << \" \";\n\n    cout << endl;\n    setrizeno = selectionSort(setridit, 14);\n\n    for (auto index: setridit)\n        cout << index << \" \";\n\n    return 0;\n}\n"
        }
      ],
      "id": "wVOJVRED",
      "createdAt": 1711016794731,
      "updatedAt": 1711618647293
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Benchmark sort",
      "content": [
        {
          "label": "Fragment 1",
          "language": "markdown",
          "value": "# Benchmark řadících algoritmů \n\nPro názornost jsme pro vás připravili aplikaci, která porovná 6\nnejznámějších řadících algoritmů, můžete si ji stáhnout v příloze v\njazyce Java. Její výsledek vypadá na mém počítači takto:\n\nKonzolová aplikace\n| Algoritmus/Prvků      | 1000  | 5000  | 10000 | 20000\n|-----------------------|-------|-------|-------|-------\n| Selection sort        | 6ms   | 30ms  | 51ms  | 197ms\n| Bubblesort            | 10ms  | 60ms  | 151ms | 781ms\n| Insertion sort        | 3ms   | 19ms  | 24ms  | 93ms\n| Heapsort              | 1ms   | 1ms   | 2ms   | 4ms\n| Merge sort            | 1ms   | 1ms   | 3ms   | 8ms\n| Quick sort            | 0ms   | 0ms   | 1ms   | 4ms\n\nPokud se budete dívat na zdrojový kód, není v něm nic, co\nbyste ještě neznali.\n\nNa výstupu benchmarku vidíme, za jak dlouho daný algoritmus seřadil pole\no 1000, 5000, 10000 a 20000\nprvcích. Vidíme zde krásně, jak asymptotická složitost opravdu funguje v\npraxi. Zatímco u 1000 prvků je úplně jedno, jaký algoritmus\npoužijeme, u 10000 prvků je algoritmus Bubblesort již\nnepoužitelný a když počet prvků zdvojnásobíme, není jeho čas také\ndvojnásobný, ale více než trojnásobný. Pro více prvků se benchmark již\nani nezkoušel, protože by na něm Bubblesort trval desítky vteřin. Určitě\nmá tedy smysl přemýšlet nad tím, jaký algoritmus pro jaký účel\npoužíváme a od špatné volby nás nezachrání ani rychlý počítač. Zde\nstroj s frekvencí několika GHz nedokáže rychle Bubblesortem seřadit 10\ntisíc čísel, i když Quick sortem to trvá 1 milisekundu.\n\nNa detailní popis i implementaci řadících algoritmů se můžete podívat\nv kurzu Řadící algoritmy. Kód\nna benchmark je přiložený pod lekcí ke stažení.\n\nNyní už mi nezbývá, než ti popřát hodně zdaru se světě algoritmů.\nAneb co dělá programátor? Řeší problémy, které by normálního člověka\nnenapadly. Ale o tom to přeci je, že?\nV příští lekci, Best practices pro vývoj softwaru - Vývoj webových aplikací, se naučíme využívat hotových softwarových\nřešení a užitečných nástrojů.\nZdroj: https://www.itnetwork.cz/navrh/best-practices-pro-vyvoj-softwaru/nejcastejsi-chyby-programatoru-k-cemu-jsou-algoritmy"
        }
      ],
      "id": "xFcht-jG",
      "createdAt": 1711016851907,
      "updatedAt": 1711618647316
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "sha256_hash",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Zatim mi neni jasne presne pouziti\n\n#include <windows.h>\n#include \"bcrypt.h\"\n#include <iostream>\n#include <string>\n#include <cstdint>\n\nusing namespace std;\n\nint sha256_hash(uint8_t *hash, uint8_t *data, size_t len)\n{\n    int res = 0;\n    NTSTATUS    status;\n    BCRYPT_ALG_HANDLE   sha = NULL;\n    BCRYPT_HASH_HANDLE  ctx = NULL;\n\n    status = BCryptOpenAlgorithmProvider(\n                 &sha,\n                 BCRYPT_SHA256_ALGORITHM,\n                 NULL,\n                 BCRYPT_HASH_REUSABLE_FLAG);\n\n    status = BCryptCreateHash(\n                 sha,\n                 &ctx,\n                 NULL,\n                 0,\n                 NULL,\n                 0,\n                 0);\n\n    status = BCryptHashData(\n                 ctx,\n                 (PBYTE)data,\n                 len,\n                 0);\n\n    status = BCryptFinishHash(\n                 ctx,\n                 hash,\n                 32,\n                 0);\n\ncleanup:\n\n    if (NULL != ctx)\n    {\n        BCryptDestroyHash(ctx);\n    }\n\n    if( NULL != sha )\n    {\n        BCryptCloseAlgorithmProvider(\n            sha,\n            0);\n    }\n\n    return res;\n\n}\n\nint main()\n{\n\n    uint8_t hash[256];\n        uint8_t data[256];\n    int status = sha256_hash(hash, data, 256);\n\n\n    return 0;\n}\n"
        }
      ],
      "id": "G0eVRdim",
      "createdAt": 1711028108295,
      "updatedAt": 1711618647306
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Abseil Library Framework",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "CodeBlocks linker lib musi byt nastavena\n..\\..\\..\\..\\tools\\msys64\\ucrt64\\lib\\libabsl_str_format_internal.dll.a\n\nhttps://abseil.io/docs/cpp/guides/format\n\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n\n//#include \"absl/flags/flag.h\"\n//#include \"absl/flags/parse.h\"\n#include \"absl/strings/str_format.h\"\n\nusing namespace std;\n\nint main()\n{\n    cout << \"Hello world!\" << endl;\n    int port = 7999;\n    std::string server_address = absl::StrFormat(\"0.0.0.0:%d\", port);\n    cout << server_address;\n    return 0;\n}"
        }
      ],
      "id": "wtFJe0Hc",
      "createdAt": 1711147987686,
      "updatedAt": 1711190990502
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Catch2 Test Library Framework",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <catch2/catch_test_macros.hpp>\n\nusing namespace std;\n\nunsigned int Factorial( unsigned int number )\n{\n    return number <= 1 ? number : Factorial(number-1)*number;\n}\n\nTEST_CASE( \"Factorials are computed\", \"[factorial]\" )\n{\n    REQUIRE( Factorial(1)  == 1 );\n    REQUIRE( Factorial(2)  == 2 );\n    REQUIRE( Factorial(3)  == 6 );\n    REQUIRE( Factorial(10) == 3628800 );\n}"
        }
      ],
      "id": "ScuM-cHC",
      "createdAt": 1711190952632,
      "updatedAt": 1711191001358
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Vector Size Resize Capacity Reserve",
      "content": [
        {
          "label": "",
          "language": "c_cpp",
          "value": "TEST_CASE( \"vectors can be sized and resized\", \"[vector]\" ) {\n    // This setup will be done 4 times in total, once for each section\n    std::vector<int> v( 5 );\n\n    REQUIRE( v.size() == 5 );\n    REQUIRE( v.capacity() >= 5 );\n\n    SECTION( \"resizing bigger changes size and capacity\" ) {\n        v.resize( 10 );\n\n        REQUIRE( v.size() == 10 );\n        REQUIRE( v.capacity() >= 10 );\n    }\n    SECTION( \"resizing smaller changes size but not capacity\" ) {\n        v.resize( 0 );\n\n        REQUIRE( v.size() == 0 );\n        REQUIRE( v.capacity() >= 5 );\n    }\n    SECTION( \"reserving bigger changes capacity but not size\" ) {\n        v.reserve( 10 );\n\n        REQUIRE( v.size() == 5 );\n        REQUIRE( v.capacity() >= 10 );\n    }\n    SECTION( \"reserving smaller does not change size or capacity\" ) {\n        v.reserve( 0 );\n\n        REQUIRE( v.size() == 5 );\n        REQUIRE( v.capacity() >= 5 );\n    }\n}"
        },
        {
          "label": "",
          "language": "c_cpp",
          "value": "int main() {\n    std::vector<int> vec;\n\n    std::cout << \"Size: \" << vec.size() << std::endl;        // Vypíše: Size: 0\n    std::cout << \"Capacity: \" << vec.capacity() << std::endl;// Vypíše: Capacity: 0\n\n    vec.reserve(10); // Rezervuje paměť pro 10 prvků, ale size() zůstává 0\n\n    std::cout << \"Size: \" << vec.size() << std::endl;        // Vypíše: Size: 0\n    std::cout << \"Capacity: \" << vec.capacity() << std::endl;// Vypíše: Capacity: 10\n\n    vec.push_back(5);\n    vec.push_back(10);\n\n    std::cout << \"Size: \" << vec.size() << std::endl;        // Vypíše: Size: 2\n    std::cout << \"Capacity: \" << vec.capacity() << std::endl;// Vypíše: Capacity: 10\n\n    return 0;\n}"
        }
      ],
      "id": "XuiqafXU",
      "createdAt": 1711191917619,
      "updatedAt": 1711192179861
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "ncurses",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <ncurses.h>\n\nusing namespace std;\n\nint main()\n{\n    initscr(); /* Start curses mode  */\n    curs_set(0); /* Makes the cursor invisible */\n    printw(\"Hello World !!!\"); /* Print Hello World */\n    refresh(); /* Print it on to the real screen */\n    getch(); /* Wait for user input */\n    endwin(); /* End curses mode */\n\n    initscr();\n    start_color(); /* Be sure not to forget this, it will enable colors */\n    init_pair(1, COLOR_RED, COLOR_CYAN); /* You can make as much color pairs as you want, be sure to change the ID number */\n    init_pair(2, COLOR_YELLOW, COLOR_GREEN);\n    attron(A_UNDERLINE | COLOR_PAIR(1)); /* This turns on the underlined text and color pair 1 */\n    printw(\"This is underlined red text with cyan background\\n\");\n    attroff(A_UNDERLINE | COLOR_PAIR(1));\n    attron(A_BOLD | COLOR_PAIR(2));\n    printw(\"This is bold yellow text with green background\");\n    attroff(A_BOLD | COLOR_PAIR(2));\n    refresh();\n    getch();\n    endwin();\n\n    int x = 5;\n    int y = 5;\n    int ch; /* Key input variable */\n    initscr();\n    curs_set(0);\n    keypad(stdscr, TRUE);     /* We get key input    from the main window */\n    noecho(); /* Don't echo() while we do getch */\n    while (1)\n    {\n        mvprintw(y, x, \"X\");\n        ch = getch();\n        if (ch == KEY_DOWN)\n        {\n            y++;\n            clear();\n        }\n        if (ch == KEY_UP)\n        {\n            y--;\n            clear();\n        }\n        if (ch == KEY_LEFT)\n        {\n            x--;\n            clear();\n        }\n        if (ch == KEY_RIGHT)\n        {\n            x++;\n            clear();\n        }\n        refresh();\n    }\n    endwin();\n    return 0;\n\n\n}\n"
        }
      ],
      "id": "FhmoB-Iv",
      "createdAt": 1711208695113,
      "updatedAt": 1711208704034
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "tinycolormap",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <tinycolormap.hpp>\n\nusing namespace std;\n\n// https://github.com/yuki-koyama/tinycolormap\n\nint main()\n{\n  // Define a target value. This value should be in [0, 1]; otherwise, it will be cropped to 0 or 1.\n  const double value = 0.5;\n\n  // Get the mapped color. Here, Viridis is specified as the colormap.\n  const tinycolormap::Color color = tinycolormap::GetColor(value, tinycolormap::ColormapType::Viridis);\n\n  // Print the RGB values. Each value is in [0, 1].\n  std::cout << \"r = \" << color.r() << \", g = \" << color.g() << \", b = \" << color.b() << std::endl;\n\n  return 0;\n}"
        }
      ],
      "id": "TCGhYu4y",
      "createdAt": 1711235056981,
      "updatedAt": 1711618647277
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "ahtjgpcH",
      "tagsIds": [],
      "description": null,
      "name": "Raid",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "mdadm --assemble --run /dev/md0 /dev/sdc1"
        }
      ],
      "id": "gp2-W6VZ",
      "createdAt": 1711300442812,
      "updatedAt": 1711618683693
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "ahtjgpcH",
      "tagsIds": [],
      "description": null,
      "name": "Raid",
      "content": [
        {
          "label": "Fragment 1",
          "language": "sh",
          "value": "mount:\nmdadm --assemble --run /dev/md0 /dev/sdc1\n"
        }
      ],
      "id": "Hw1OW1ew",
      "createdAt": 1711300464227,
      "updatedAt": 1711618682002
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": "Ten nejlepší hello world co sjem zatím našel",
      "name": "Hello World",
      "content": [
        {
          "label": "C++ Console App EN",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main(int argc, char *argv[], char* env[])\n{\n    vector<string> msg {\"Hello\", \"C++\", \"World\", \"from\", \"VS Code\", \"and the C++ extension!\"};\n\n    for (const string& word : msg)\n    {\n        cout << word << \" \";\n    }\n    cout << endl;\n\n\treturn 0;\n}"
        },
        {
          "label": "C++ Console App CZ support",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const unsigned char tranform_table_for_cz[]\n{\n    129, 130, 131, 132, 133, 134, 135, 136, 137, 230, 139, 140,\n    155, 166, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152,\n    153, 231, 155, 156, 156, 167, 159, 160, 161, 162, 163, 164,\n    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,\n    177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 149,\n    189, 150, 191, 232, 181, 194, 195, 142, 145, 198, 199, 172,\n    144, 202, 203, 183, 214, 206, 210, 208, 209, 213, 224, 226,\n    213, 214, 215, 252, 222, 233, 219, 220, 237, 222, 223, 234,\n    160, 226, 227, 132, 146, 230, 231, 159, 130, 234, 235, 216,\n    161, 238, 212, 240, 241, 229, 162, 147, 245, 246, 247, 253,\n    133, 163, 251, 252, 236, 254, 255\n};\n\nchar c_Cp1250_to_Cp852(unsigned char c)\n{\n    if (c < 128)\n        return c;\n    else\n        return tranform_table_for_cz[c - 129];\n}\n\nstring char_Cp1250_to_string_Cp852(const char* charCp1250)\n{\n    string result;\n    for (const char *p = charCp1250; *p; p++)\n        result += c_Cp1250_to_Cp852(*p);\n    return result;\n}\n\nstring string_Cp1250_to_string_Cp852(string textCp1250)\n{\n    string result(textCp1250.size(), ' ');\n    transform(textCp1250.begin(), textCp1250.end(), // <algoritmh>\n              result.begin(), c_Cp1250_to_Cp852);\n    return result;\n}\n\nint main(int argc, char *argv[], char* env[])\n{\n    string textCp1250 = \"přílišžluťoučkýkůňúpělďábelskéódy\";\n        cout << textCp1250 << endl;\n    string textCp852;\n    textCp852 = string_Cp1250_to_string_Cp852(textCp1250);\n    cout << textCp852 << endl;\n\n    const char *charCp1250 = \"přílišžluťoučkýkůňúpělďábelskéódy\";\n        cout << charCp1250 << endl;\n    string charCp852;\n    charCp852 = char_Cp1250_to_string_Cp852(charCp1250);\n    cout << charCp852 << endl;\n\t\n\treturn 0;\n}\n"
        },
        {
          "label": "C++ Simple Hello",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main(int argc, char *argv[], char* env[])\n{\n\treturn 0;\n}"
        }
      ],
      "id": "AxCoKSc9",
      "createdAt": 1711532196343,
      "updatedAt": 1718437910097
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "max",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": ""
        }
      ],
      "id": "wXJmxACA",
      "createdAt": 1711544199160,
      "updatedAt": 1711952713545
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "tasks.json new project",
      "content": [
        {
          "label": "Fragment 1",
          "language": "json",
          "value": "{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"Win64 Debug\",\n            \"command\": \"C:\\\\tools\\\\msys64\\\\ucrt64\\\\bin\\\\g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"-g\",\n                //\"${file}\",\n                \"${workspaceFolder}/*.cpp\",\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}-d.exe\",\n                \"-I${workspaceRoot}\\\\\",\n                \"-lcurl\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:\\\\tools\\\\msys64\\\\ucrt64\\\\bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                //\"isDefault\": true\n            },\n            \"detail\": \"Include debuging symbols\"\n        },\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"Win64 Release\",\n            \"command\": \"C:/tools/msys64/ucrt64/bin/g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                //\"${file}\",\n                \"${workspaceFolder}/*.cpp\",\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",\n                \"-I${workspaceRoot}\\\\\",\n                \"-lcurl\",\n                \"-static-libgcc\",\n                \"-static-libstdc++\",\n                \"-static\",\n                \"-O3\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:/tools/msys64/ucrt64/bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\"\n            },\n            \"detail\": \"Static linking & Speed optimalisation\"\n        }\n        \n    ],\n    \"version\": \"2.0.0\"\n}"
        }
      ],
      "id": "1cTELtVQ",
      "createdAt": 1711613817368,
      "updatedAt": 1711987007532
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "snake 2 jsons",
      "content": [
        {
          "label": "Fragment 1",
          "language": "json",
          "value": "{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"Win64 Debug\",\n            \"command\": \"C:\\\\tools\\\\msys64\\\\ucrt64\\\\bin\\\\g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"-g\",\n                \"${workspaceFolder}/*.cpp\",\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}-deb.exe\",\n                \"-I${workspaceRoot}\\\\\",\n                \"-IC:\\\\Projects\\\\_CppProjects\\\\Apps\\\\ServerClient\\\\include\",\n                \"-IC:\\\\Projects\\\\_Dep\\\\enet\\\\include\",\n                \"C:\\\\Projects\\\\_Dep\\\\enet\\\\bin\\\\Debug\\\\libenet.a\",\n                \"-lws2_32\",\n                \"-lWinmm\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:\\\\tools\\\\msys64\\\\ucrt64\\\\bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                //\"isDefault\": true\n            },\n            \"detail\": \"Include debuging symbols\"\n        },\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"Win64 Release\",\n            \"command\": \"C:/tools/msys64/ucrt64/bin/g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"${workspaceFolder}/*.cpp\",\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}-rel.exe\",\n                \"-I${workspaceRoot}\\\\\",\n                \"-IC:\\\\Projects\\\\_CppProjects\\\\Apps\\\\ServerClient\\\\include\",\n                \"-IC:\\\\Projects\\\\_Dep\\\\enet\\\\include\",\n                \"C:\\\\Projects\\\\_Dep\\\\enet\\\\bin\\\\Release\\\\libenet.a\",\n                \"-lws2_32\",\n                \"-lWinmm\",\n                \"-static-libgcc\",\n                \"-static-libstdc++\",\n                \"-static\",\n                \"-O3\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:/tools/msys64/ucrt64/bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\"\n            },\n            \"detail\": \"Static linking & Speed optimalisation\"\n        }\n        \n    ],\n    \"version\": \"2.0.0\"\n}"
        },
        {
          "label": "c_cpp_properties.json",
          "language": "json",
          "value": "{\n    \"configurations\": [\n        {\n            \"name\": \"Win32\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\",\n                \"C:\\\\Projects\\\\_CppProjects\\\\Apps\\\\ServerClient\\\\include\",\n                \"C:\\\\Projects\\\\_Dep\\\\enet\\\\include\"\n            ],\n            \"defines\": [\n                \"_DEBUG\",\n                \"UNICODE\",\n                \"_UNICODE\"\n            ],\n            \"windowsSdkVersion\": \"10.0.22621.0\",\n            \"cStandard\": \"c17\",\n            \"cppStandard\": \"c++17\",\n            \"intelliSenseMode\": \"gcc-x64\",\n            \"compilerPath\": \"C:/tools/msys64/ucrt64/bin/g++.exe\"\n        }\n    ],\n    \"version\": 4\n}"
        }
      ],
      "id": "HH-4dent",
      "createdAt": 1711613865072,
      "updatedAt": 1711615326322
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "tasks.json - new project - default: Win64 Debug - single CPP file",
      "content": [
        {
          "label": "Fragment 1",
          "language": "json",
          "value": "{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"Win64 Debug\",\n            \"command\": \"C:\\\\tools\\\\msys64\\\\ucrt64\\\\bin\\\\g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${workspaceFolder}\\\\Snake2-Debug.exe\",\n                \"-I${workspaceRoot}\\\\\",\n                \"-IC:\\\\Projects\\\\_CppProjects\\\\Apps\\\\ServerClient\\\\include\",\n                \"-IC:\\\\Projects\\\\_Dep\\\\enet\\\\include\",\n                \"C:\\\\Projects\\\\_Dep\\\\enet\\\\bin\\\\Debug\\\\libenet.a\",\n                \"-lws2_32\",\n                \"-lWinmm\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:\\\\tools\\\\msys64\\\\ucrt64\\\\bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\"\n            },\n            \"detail\": \"Include debuging symbols\"\n        },\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"Win64 Release\",\n            \"command\": \"C:/tools/msys64/ucrt64/bin/g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"${file}\",\n                \"-o\",\n                \"${workspaceFolder}\\\\Snake2-Release.exe\",\n                \"-I${workspaceRoot}\\\\\",\n                \"-IC:\\\\Projects\\\\_CppProjects\\\\Apps\\\\ServerClient\\\\include\",\n                \"-IC:\\\\Projects\\\\_Dep\\\\enet\\\\include\",\n                \"C:\\\\Projects\\\\_Dep\\\\enet\\\\bin\\\\Release\\\\libenet.a\",\n                \"-lws2_32\",\n                \"-lWinmm\",\n                \"-static-libgcc\",\n                \"-static-libstdc++\",\n                \"-static\",\n                \"-O3\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:/tools/msys64/ucrt64/bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\"\n            },\n            \"detail\": \"Static linking & Speed optimalisation\"\n        }\n        \n    ],\n    \"version\": \"2.0.0\"\n}"
        }
      ],
      "id": "11qDhQzW",
      "createdAt": 1711614357934,
      "updatedAt": 1711614416008,
      "folder": {
        "name": "VSCode",
        "parentId": null,
        "isOpen": false,
        "isSystem": false,
        "defaultLanguage": "json",
        "id": "u6rnxgPx",
        "createdAt": 1711613794649,
        "updatedAt": 1711613813693
      }
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "tasks.json single cpp",
      "content": [
        {
          "label": "Fragment 1",
          "language": "json",
          "value": "{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"Win64 Debug\",\n            \"command\": \"C:\\\\tools\\\\msys64\\\\ucrt64\\\\bin\\\\g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}-deb.exe\",\n                \"-I${workspaceRoot}\\\\\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:\\\\tools\\\\msys64\\\\ucrt64\\\\bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                //\"isDefault\": true\n            },\n            \"detail\": \"Include debuging symbols\"\n        },\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"Win64 Release\",\n            \"command\": \"C:/tools/msys64/ucrt64/bin/g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}-rel.exe\",\n                \"-I${workspaceRoot}\\\\\",\n                \"-static-libgcc\",\n                \"-static-libstdc++\",\n                \"-static\",\n                \"-O3\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:/tools/msys64/ucrt64/bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\"\n            },\n            \"detail\": \"Static linking & Speed optimalisation\"\n        }\n        \n    ],\n    \"version\": \"2.0.0\"\n}"
        }
      ],
      "id": "vLmNUM39",
      "createdAt": 1711614418043,
      "updatedAt": 1711986886991,
      "folder": {
        "name": "VSCode",
        "parentId": null,
        "isOpen": false,
        "isSystem": false,
        "defaultLanguage": "json",
        "id": "u6rnxgPx",
        "createdAt": 1711613794649,
        "updatedAt": 1711613813693
      }
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "RAII",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": ""
        },
        {
          "label": "Invariantí třída",
          "language": "c_cpp",
          "value": ""
        }
      ],
      "id": "Ld-kTr_i",
      "createdAt": 1711863025458,
      "updatedAt": 1711863719339
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": " pacman -S mingw-w64-ucrt-x86_64-gtest",
      "name": "gtest tasks.json",
      "content": [
        {
          "label": "Fragment 1",
          "language": "json",
          "value": "{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"C/C++: g++.exe build active file\",\n            \"command\": \"C:/tools/msys64/ucrt64/bin/g++.exe\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",\n                \"c:\\\\tools\\\\msys64\\\\ucrt64\\\\lib\\\\libgtest.a\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:/tools/msys64/ucrt64/bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            },\n            \"detail\": \"Task generated by Debugger.\"\n        }\n    ],\n    \"version\": \"2.0.0\"\n}"
        }
      ],
      "id": "oSNGqat5",
      "createdAt": 1711872542327,
      "updatedAt": 1711872855876
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "Read File - ifstream",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <list>\n#include <random>\n\n#define COUNT_OF_NICK_NAMES 100\n\nstd::string getAppPathFromMain(char *exePath[])\n{\n    std::string exePathString = static_cast<std::string>(exePath[0]);\n    size_t index = exePathString.find_last_of(\"\\\\/\") + 1;\n    return exePathString.substr(0, index);\n}\n\nint main(int argc, char *argv[], char *env[])\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    std::vector<std::string> adjectives;\n    std::string adjsPath = getAppPathFromMain(argv) + \"top_english_adjs_lower_100000.txt\";\n    std::vector<std::string> nouncess;\n    std::string nounsPath = getAppPathFromMain(argv) + \"top_english_nouns_lower_100000.txt\";\n\n    std::ifstream adjsIStream(adjsPath, std::ios::binary);\n    std::ifstream nounsIStream(nounsPath, std::ios::binary);\n    std::string word;\n\n    int totalAdjectives = 0;\n    int totalNouncess = 0;\n    int totalWords = 0;\n    std::string line;\n\n    // adjectives\n    if (!adjsIStream.is_open())\n    {\n        std::cout << \"failed to open \" << adjsPath << '\\n';\n        return 1;\n    }\n    else\n    {\n        while (adjsIStream >> line)\n        {\n            adjectives.push_back(line);\n        }\n        totalAdjectives = adjectives.size();\n        std::cout << \"total adjectives: \" << totalAdjectives << '\\n';\n    }\n\n    // anounces\n    if (!nounsIStream.is_open())\n    {\n        std::cout << \"failed to open \" << nounsPath << '\\n';\n        return 1;\n    }\n    else\n    {\n        while (nounsIStream >> line)\n        {\n            nouncess.push_back(line);\n        }\n        totalNouncess = nouncess.size();\n        std::cout << \"total nounsess: \" << totalNouncess << '\\n';\n    }\n\n    // combine nick name\n    for (int i = 0; i < COUNT_OF_NICK_NAMES; i++)\n    {\n        std::uniform_int_distribution<> disAdj(1, totalAdjectives);\n        int selectedAdjective = disAdj(gen);\n\n        std::uniform_int_distribution<> disNou(1, totalNouncess);\n        int selectedNouncess = disNou(gen);\n\n        std::string NickName = adjectives[selectedAdjective] + \" \" + nouncess[selectedNouncess];\n        std::cout << NickName << std::endl;\n    }\n    return 0;\n}"
        }
      ],
      "id": "DLoDPNdV",
      "createdAt": 1711948945185,
      "updatedAt": 1711951744013
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "AppPath from Main",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <list>\n\nusing namespace std;\n\nint main(int argc, char *argv[], char *env[])\n{\n    list<string> adjectives;\n    string exePath = static_cast<string>(argv[0]);\n    size_t index = exePath.find_last_of(\"\\\\/\") + 1;\n    string adjPath = exePath.substr(0, index);\n    adjPath += \"top_english_adjs_lower_100000.txt\";\n\n    std::ifstream istrm(adjPath, std::ios::binary);\n    string word;\n    if (!istrm.is_open())\n    {\n        std::cout << \"failed to open \" << adjPath << '\\n';\n        return 1;\n    }\n    else\n    {\n        string line;\n        while (istrm >> line)\n        {\n            adjectives.push_back(line);\n        }\n    }\n\n    return 0;\n}"
        }
      ],
      "id": "xoS5BFso",
      "createdAt": 1711949012676,
      "updatedAt": 1711949042446
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "getAppFromMain",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::string getAppPathFromMain(char* exePath[])\n{\n    string exePathString = static_cast<string>(exePath[0]);\n    size_t index = exePathString.find_last_of(\"\\\\/\") + 1;\n    return exePathString.substr(0, index);\n}"
        }
      ],
      "id": "skWhWe0W",
      "createdAt": 1711949504751,
      "updatedAt": 1714749108007
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3vpCAP33",
      "tagsIds": [],
      "description": null,
      "name": "C++ Data Structures CheatSheet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "vectors\nIn C++, a vector is a data structure that stores a sequence of elements that can be accessed by index. Unlike arrays, vectors can dynamically shrink and grow in size.\nThe standard <vector> library provide methods for vector operations:\n\n    .push_back(): add element to the end of the vector.\n    .pop_back(): remove element from the end of the vector.\n    .size(): return the size of the vector.\n    .empty(): return whether the vector is empty.\n\n#include <iostream>\n#include <vector>\n\nint main () {\n  std::vector <int> primes = {2, 3, 5, 7, 11};\n  std::cout << primes[2];\t// Outputs: 5\n  primes.push_back(13);\n  primes.push_back(17);\n  primes.pop_back();\n  for (int i = 0; i < primes.size(); i++) {\n      std::cout << primes[i] << \" \";\n  }\n  // Outputs: 2 3 5 7 11 13\n  return 0;\n}\n\nStacks and Queues\nIn C++, stacks and queues are data structures for storing data in specific orders.\nStacks are designed to operate in a Last-In-First-Out context (LIFO), where elements are inserted and extracted only from one end of the container.\n    .push() add an element at the top of the stack.\n    .pop() remove the element at the top of the stack.\nQueues are designed to operate in a First-In-First-Out context (FIFO), where elements are inserted into one end of the container and extracted from the other.\n    .push() add an element at the end of the queue.\n    .pop() remove the element at the front of the queue.\n\n#include <iostream>\n#include <stack>\n#include <queue>\n\nint main()\n{\n  std::stack<int> tower;\n  tower.push(3);\n  tower.push(2);\n  tower.push(1);\n  \n  while(!tower.empty()) {\n    std::cout << tower.top() << \" \";\n    tower.pop();\n  }\n  // Outputs: 1 2 3\n  \n  std::queue<int> order;\n  order.push(10);\n  order.push(9);\n  order.push(8);\n  \n  while(!order.empty()) {\n    std::cout << order.front() << \" \";\n    order.pop();\n  }\n  // Outputs: 10 9 8\n\n  return 0;\n}\n\nSets\n\nIn C++, a set is a data structure that contains a collection of unique elements. Elements of a set are index by their own values, or keys.\nA set cannot contain duplicate elements. Once an element has been added to a set, that element cannot be modified.\nThe following methods apply to both unordered_set and set:\n    .insert(): add an element to the set.\n    .erase(): removes an element from the set.\n    .count(): check whether an element exists in the set.\n    .size(): return the size of the set.\n#include <iostream>\n#include <unordered_set>\n#include <set>\n\nint main()\n{\n  std::unordered_set<int> primes({2, 3, 5, 7});\n  \n  primes.insert(11);\n  primes.insert(13);\n  primes.insert(11);  // Duplicates are not inserted\n  \n  primes.erase(2);\n  primes.erase(13);\n  \n  // Outputs: primes does not contain 2.\n  if(primes.count(2))\n    std::cout << \"primes contains 2.\\n\";\n  else\n    std::cout << \"primes does not contain 2.\\n\";\n  \n  // Outputs: Size of primes: 4\n  std::cout << \"Size of primes: \" << primes.size() << \"\\n\";\n  \n  return 0;\n}\n\narrays\n\nArrays in C++ are used to store a collection of values of the same type. The size of an array is specified when it is declared and cannot change afterward.\nUse [] and an integer index to access an array element. Keep in mind: array indices start with 0, not 1!.\nA multidimensional array is an “array of arrays” and is declared by adding extra sets of indices to the array name.\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n  char vowels[5] = {'a', 'e', 'i', 'o', 'u'};\n  \n  std::cout << vowels[2];\t// Outputs: i\n \n  char game[3][3] = {\n    {'x', 'o', 'o'} , \n    {'o', 'x', 'x'} , \n    {'o', 'o', 'x'}  \n  };\n  \n\tstd::cout << game[0][2];\t// Outputs: o\n  \n  return 0;\n}\n\nHash Maps\n\nIn C++, a hash map is a data structure that contains a collection of unique elements in the form of key-value pairs. Elements of a hash map are identified by key values, while the mapped values are the content associated with the keys.\nEach element of a map or unordered_map is an object of type pair. A pair object has two member variables:\n    .first is the value of the key\n    .second is the mapped value\nThe following methods apply to both unordered_map and map:\n    .insert(): add an element to the map.\n    .erase(): removes an element from the map.\n    .count(): check whether an element exists in the map.\n    .size(): return the size of the map.\n    [] operater:\n        If the specified key matches an element in the map, then access the mapped value associated with that key.\n        If the specified key doesn’t match any element in the map, add a new element to the map with that key.\n\n#include <iostream>\n#include <unordered_map>\n#include <map>\n\nint main() {\n  std::unordered_map<std::string, int> country_codes;\n\n  country_codes.insert({\"Thailand\", 65});\n  country_codes.insert({\"Peru\", 51});\n  country_codes[\"Japan\"] = 81;\t\t// Add a new element\n  country_codes[\"Thailand\"] = 66; // Access an element\n  \n  country_codes.erase(\"Peru\");\n  \n  // Outputs: There isn't a code for Belgium\n  if (country_codes.count(\"Belgium\")) {\n    std::cout << \"There is a code for Belgium\\n\";\n  }\n  else {\n   std::cout << \"There isn't a code for Belgium\\n\";\n  }\n\n  // Outputs: 81\n  std::cout << country_codes[\"Japan\"] << \"\\n\";\n  \n  // Outputs: 2\n  std::cout << country_codes.size() << \"\\n\";\n  \n  // Outputs: Japan 81\n  //          Thailand 66\n  for(auto it: country_codes){\n    std::cout << it.first << \" \" << it.second << \"\\n\";\n  }\n  \n  return 0;\n}"
        }
      ],
      "id": "pcKqkGba",
      "createdAt": 1711950927344,
      "updatedAt": 1711951026820
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Dependency injection",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <vector>\n#include <ranges>\n#include <iomanip>\n#include <iostream>\n\nint main() {\n    std::vector<int> first{1,2,3,4,5};\n    std::vector<double> second{9,8,7,6};\n\n    // Iterate over the elements of the zip view\n    for (auto [a, b] : std::views::zip(first, second)) {\n        // {1,9}, {2,8}, {3,7}, {4,6}\n        std::cout << a << \" \" << b << \"\\n\";\n    }\n    std::cout << \"\\n\";\n\n    // Same as above, without structured binding\n    for (std::tuple<int&,double&> el : std::views::zip(first, second)) {\n        // {1,9}, {2,8}, {3,7}, {4,6}\n        std::cout << std::get<0>(el) << \" \" << std::get<1>(el) << \"\\n\";\n    }\n    std::cout << \"\\n\";\n    \n    std::vector<std::string> third{\"label1\", \"label2\", \"label3\"};\n\n    // The zip view can accept one or more arguments\n    for (auto [a, b, c] : std::views::zip(first, second, third)) {\n        // {1,9,\"label1\"}, {2,8,\"label2\"}, {3,7,\"label3\"}\n        std::cout << a << \" \" << b << \" \" << std::quoted(c) << \"\\n\";\n    }\n    std::cout << \"\\n\";\n\n    // We can also modify the original ranges through the tuple\n    for (auto [a, b, c] : std::views::zip(first, second, third)) {\n        a = a + b;\n        std::cout << a << \" \" << b << \" \" << std::quoted(c) << \"\\n\";\n    }\n    std::cout << \"\\n\";\n    // first == {10, 10, 10, 4, 5}\n\n    for (auto v : first)\n        std::cout << v << \" \";\n    std::cout << \"\\n\";\n}"
        }
      ],
      "id": "JmhQSYuQ",
      "createdAt": 1711970116424,
      "updatedAt": 1711970129654
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::equal_range",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::equal_range algorithm is a binary search algorithm (O(logn) comparisons) that operates on sorted ranges.\n\nIt returns the lower and upper bounds for the given value, effectively denoting the range of elements that equal the value.\n\nAs is typical with C++, an empty range is denoted by two iterators that equal each other.\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    std::vector<int> data{1, 2, 3, 4, 4, 4, 6, 7, 8, 9, 10};\n\n    {\n    auto [begin, end] = std::equal_range(data.begin(), data.end(), 4);\n    // [begin, end) == {4, 4, 4}\n    for (auto it = begin; it != end; ++it) {\n        std::cout << *it << \", \";\n    }\n    std::cout << \"\\n\";\n    }\n\n    {\n    auto [begin, end] = std::equal_range(data.begin(), data.end(), 5);\n    // begin == end (empty range)\n    for (auto it = begin; it != end; ++it) {\n        std::cout << *it << \", \";\n    }\n    std::cout << \"\\n\";\n    }\n}"
        }
      ],
      "id": "tnPoNbKd",
      "createdAt": 1711970156823,
      "updatedAt": 1711970199198
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "conditional operator ?:",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The conditional operator, also known as the ternary operator, is essentially an if statement in the form of an expression.\n\nThe operator is sequenced. The left side, with all its side effects, is evaluated first, followed by one of the right-side operands (depending on the boolean value of the first operand).\n\nIf the types of the two right-side arguments differ, conversions may be applied to arrive at a compatible common type, the resulting type of the expression.\n\nBefore C++17 introduced if constexpr, the ternary operator was also the primary way to inject logic into a constexpr expression.\n\nstruct A {};\nstruct B : A {};\n\nstruct MustBeInit {\n    MustBeInit(int v) : v(v) {}\n    int v;\n};\n\n// Simple logic:\nint x = 1;\nint y = 2;\nint abs_diff = x < y ? y - x : x - y;\n\n// Useful for initializing variables \n// that do not support default initialization:\nMustBeInit m = true ? 1 : 2;\n\n// Before C++17, conditional expression was \n// the main way to inject logic into constexpr code\nconstexpr bool has_many = true;\nstd::array<int, has_many ? 1024 : 8> arr;\n\n// When mixing types, standard conversions are permitted, ex:\nstatic_assert(std::is_same_v< // int->double\n    decltype(true ? 2.0 : 1), double        \n>);\nstatic_assert(std::is_same_v< // class to base\n    decltype(true ? A() : B()), A\n>);\n\n// Throw expressions are permitted, as they break flow:\nauto ptr = std::make_unique<std::string>(\"abc\");\nsize_t len = ptr ? ptr->length() : \n throw std::runtime_error(\"Null pointer dereference.\");\n\n// If both sides are throw expressions, the result is void\nstatic_assert(std::is_same_v<\n    decltype(true ? throw 1 : throw 2), void\n>);\n\n// When mixing cv-qualifiers, the arguments need to overlap,\n// but the result is then the most-qualified type.\nint a = 1;\nconst int& b = 2;\nint& c = a;\nstatic_assert(std::is_same_v<\n    decltype(true ? b : c), const int&\n>);"
        }
      ],
      "id": "ZIbBr-MI",
      "createdAt": 1711970229557,
      "updatedAt": 1711970243143
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::in_range",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::in_range is a simple C++20 utility that checks whether the given value is within the range of the given integral type.\n\nIt can be used as a guard to determine whether a runtime integral conversion would be value-changing.\n\n#include <utility>\n#include <concepts>\n#include <cstdint>\n\nbool v1 = std::in_range<int>(-1);\n// v1 == true\nbool v2 = std::in_range<unsigned>(-1);\n// v2 == false\n\n// Example of guarding a function with a limited domain.\nnamespace {\n// Actual implementation that needs to be guarded.\nvoid some_func_impl(uint16_t v) { }\n}\n\n// Interface function accepts any integral\n// guaranteeing no value-changing conversions.\nvoid some_func(std::integral auto v) {\n    if (!std::in_range<uint16_t>(v))\n        throw std::out_of_range(\"value out of range\");\n\n    // Safe implicit conversion\n    some_func_impl(v);\n}\n\n// int, not in range of uint16_t\nsome_func(-1); // throws\n\n// size_t literal, in range of uint16_t\nsome_func(2uz); // calls some_func_impl\n\n// int, not in range of uint16_t\nsome_func(UINT16_MAX+1); // throws"
        }
      ],
      "id": "Iurm8dAX",
      "createdAt": 1711970301576,
      "updatedAt": 1711970312913
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::jthread",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "In C++20, we have received a new version of the standard thread in the form std::jthread (joining thread).\n\nWith std::thread, the held thread must be joined or detached before the variable is destroyed (otherwise, the program will terminate).\n\nThe std::jthread addresses this by automatically joining in the destructor, removing the need for wrappers.\n\n#include <chrono>\n#include <thread>\n\n{\n// Spawn a thread:\nauto t = std::thread([]{\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(1s);\n});\n// Required join, will block until 1s sleep finishes.\nt.join();\n} // end of scope, t is destroyed\n\n{\n// Spawn a thread:\nauto t = std::jthread([]{\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(1s);\n});\n} // end of scope, t is destroyed\n  // and the thread is joined as part of that\n\n// Start a thread and immediately join,\n// as the temporary return value is destroyed.\nstd::jthread([]{});\n// Start a thread and (very likely) immediately terminate,\n// as the temporary return value is destroyed.\nstd::thread([]{});"
        }
      ],
      "id": "Bk5QIL1n",
      "createdAt": 1711970357796,
      "updatedAt": 1711970375196
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::stop_source, std::stop_token, std::stop_callback",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced new cooperative thread termination facilities through std::stop_source, std::stop_token and std::stop_callback that integrate with std::jthread and std::condition_variable_any.\n\nOnce started, a thread cannot be externally terminated. The only solution is introducing a communication side-channel that signals a termination request. This set of facilities offers a standard implementation of such a side channel with convenient integrations.\n\n#include <thread>\nusing namespace std::chrono_literals;\n\nauto t = std::jthread([](std::stop_token token){\n    // Run, until stop is requested:\n    while (!token.stop_requested()) {\n        std::this_thread::sleep_for(1s);\n    }\n});\n\nstd::this_thread::sleep_for(2s);\nt.request_stop(); // request stop\n\nOpen this example in Compiler Explorer.\n\nstd::jthread comes with integrated std::stop_source that will get automatically associated with a token if the callable passed to the std::jthread takes a std::stop_token as an argument.\n\nOptionally, if it is desirable to run code when a stop is requested, the stop token can be associated with stop callbacks. However, callbacks come with a caveat. The callback will either be run on the thread requesting the stop, or if the stop was already requested, the callback will be run immediately on the thread registering it.\n\n#include <thread>\nusing namespace std::chrono_literals;\n\nauto t = std::jthread([](std::stop_token token) {\n    std::atomic<bool> flag = false;\n    std::stop_callback callback(token, [&flag]{\n        flag = true;\n    });\n\n    // Run, until stop is requested:\n    while (!flag) {\n        std::this_thread::sleep_for(1s);\n    }\n});\n\nstd::this_thread::sleep_for(3s);\nt.request_stop(); // runs any associated callbacks on this thread\n\nOpen this example in Compiler Explorer.\n\nFinally, when relying on a conditional variable, we would want to stop the variable waiting on a condition if a stop was requested. This is why std::stop_token also integrates with std::condition_variable_any.\n\n#include <mutex>\n#include <condition_variable>\n#include <thread>\nusing namespace std::chrono_literals;\n\nstruct Resource {\n    std::mutex mux;\n    bool ready = false;\n};\n\nResource resource;\nauto t = std::jthread([&resource](std::stop_token token) {\n    // Wait until resource is ready, or stop was requested:\n    std::unique_lock lock(resource.mux);\n    std::condition_variable_any().wait(lock, token,\n      [&resource] { return resource.ready; });\n    if (resource.ready) {\n      // this path will be taken if stop is not requested\n    } else {\n      // this path will be taken if the stop is requested\n    }\n});\n\nt.request_stop(); // request stop\n{ // If we would comment out the previous line and do this instead,\n  // the if (resource.ready) path will be taken.\nstd::unique_lock lock(resource.mux);\nresource.ready = true;\n}"
        }
      ],
      "id": "cM4EnOsK",
      "createdAt": 1711970380745,
      "updatedAt": 1711970414255
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::partition_copy",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::partition_copy is a C++11 variant of std::partition that outputs each partition through the two provided iterators instead of operating inline.\n\nIn C++20, the algorithm received a ranges variant.\n\n#include <algorithm>\n#include <ranges>\n#include <vector>\n#include <string>\n#include <iostream>\n\nstd::vector<std::string> vowels, consonants;\n\nstd::ranges::partition_copy(\n  std::views::istream<std::string>(std::cin),\n  std::back_inserter(vowels), // iterator for condition == true\n  std::back_inserter(consonants), // iterator for condition == false\n  [](const std::string& s){\n      // Check if first character is a vowel:\n      char c = std::tolower(s.front()); // guaranteed non-empty\n      return (c == 'a' || c == 'e' || c == 'i' || \n              c == 'o' || c == 'u');\n  });\n// For input \"Hello, World! This is going to be a blast.\":\n// vowels == {\"is\", \"a\"}\n// consonants == {\"Hello,\", \"World!\", \"This\", \"going\", \n//                \"to\", \"be\", \"blast.\"}"
        }
      ],
      "id": "RWuNOb1B",
      "createdAt": 1711970429366,
      "updatedAt": 1711970444482
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::mutex",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::mutex is a mutual exclusion lock that permits only one owner to hold the lock. A successive attempt at obtaining the lock will block until the previous owner of the lock releases it.\n\nWhile the mutex can be locked and unlocked manually, it is desirable to use the RAII-based std::unique_lock instead, which will always correctly release a held lock, preventing accidental deadlocks.\n\n#include <mutex>\n#include <thread>\n#include <chrono>\nusing namespace std::chrono_literals;\n\nstruct Shared {\n    int value;\n    std::mutex mux;\n};\nShared shared{0,{}};\n\n{\nauto t1 = std::jthread([&shared]{\n  for (int i = 0; i < 10; i++) {\n    // obtain lock\n    std::unique_lock lock(shared.mux);\n    // modify shared state\n    shared.value += 10;\n  } // mutex unlocks as std::unique_lock is destroyed\n});\nauto t2 = std::jthread([&shared]{\n  for (int i = 0; i < 10; i++) {\n    // obtain lock\n    std::unique_lock lock(shared.mux);\n    // modify shared state\n    shared.value += 1;\n  } // mutex unlocks as std::unique_lock is destroyed\n});\n} // t1 && t2 a destroyed and joined\n\n// shared.value == 110"
        }
      ],
      "id": "H7DIlE7k",
      "createdAt": 1711970457772,
      "updatedAt": 1711970469581
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::recursive_mutex",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::recursive_mutex is a std::mutex variant that permits one thread to hold multiple locks. Only once all locks are released can other threads acquire this mutex.\n\nThis feature comes in handy when designing thread-safe data structures.\n\nstruct NonRecursive {\n    void push_back(int value) {\n        std::unique_lock lock(mux_);\n        // We already hold mux_, so we couldn't call reserve()\n        if (size_ == capacity_)\n            reserve_impl(capacity_ == 0 ? 64 : capacity_ * 2);\n        data_[size_++] = value;\n    }\n    void reserve(size_t cnt) {\n        std::unique_lock lock(mux_);\n        reserve_impl(cnt);\n    }\nprivate:\n    // reserve_impl expects mux_ to be held by the caller\n    void reserve_impl(size_t cnt) {\n        auto new_data = std::make_unique<int[]>(cnt);\n        std::ranges::copy(std::span(data_.get(), std::min(size_, cnt)),\n                          new_data.get());\n        data_ = std::move(new_data);\n        capacity_ = cnt;\n        size_ = std::min(size_, capacity_);\n    }\n    std::mutex mux_;\n    std::unique_ptr<int[]> data_;\n    size_t size_ = 0;\n    size_t capacity_ = 0;\n};\n\nstruct Recursive {\n    void push_back(int value) {\n        std::unique_lock lock(mux_);\n        // holding a recursive mutex multiple times is fine\n        if (size_ == capacity_)\n            reserve(capacity_ == 0 ? 64 : capacity_ * 2);\n        data_[size_++] = value;\n    }\n    void reserve(size_t cnt) {\n        std::unique_lock lock(mux_);\n        auto new_data = std::make_unique<int[]>(cnt);\n        std::ranges::copy(std::span(data_.get(), std::min(size_, cnt)),\n                          new_data.get());\n        data_ = std::move(new_data);\n        capacity_ = cnt;\n        size_ = std::min(size_, capacity_);\n    }\nprivate:\n    std::recursive_mutex mux_;\n    std::unique_ptr<int[]> data_;\n    size_t size_ = 0;\n    size_t capacity_ = 0;\n};"
        }
      ],
      "id": "OwH748nE",
      "createdAt": 1711970494751,
      "updatedAt": 1711970508578
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::shared_mutex",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::shared_mutex is a C++14 (C++17 for the non-timed version) std::mutex variant that supports two types of locks: an exclusive lock that can be held by only one thread and a shared lock that can be held by any number of threads (as long as the exclusive lock is not held).\n\nThese are the semantics generally required for read-write access, as read operations can run in parallel, while write operations require exclusive access.\n\n#include <mutex>\n#include <shared_mutex>\n#include <array>\n#include <optional>\n\nstruct Data {};\nstruct RecentSnapshots {\n    void push(const Data& data) {\n        // We are about to modify the data, grab a unique_lock\n        std::unique_lock lock(mux_);\n        buffer_[offset_ % 64] = data;\n        ++offset_;\n    }\n    std::optional<Data> get(size_t index) const {\n        // We only read, but need to prevent \n        // concurrent writes, grab a shared_lock\n        std::shared_lock lock(mux_);\n        if (index >= offset_)\n            return std::nullopt;\n        if (offset_ >= 64 && offset_-64 > index)\n            return std::nullopt;\n        return buffer_[index % 64];\n    }\n    size_t min_offset() const {\n        // We only read, but need to prevent \n        // concurrent writes, grab a shared_lock\n        std::shared_lock lock(mux_);\n        if (offset_ <= 64) return 0;\n        return offset_ - 64;\n    }\nprivate:\n    // We need mutable, since we mutate the state\n    // of this mutex (by grabbing a lock) in const methods.\n    mutable std::shared_mutex mux_;\n    std::array<Data,64> buffer_;\n    size_t offset_ = 0;\n};\n\n// Note: calling min_offset() followed by get(offset)\n// does NOT provide any transactionality, as a write can interject\n// itself between the two calls."
        }
      ],
      "id": "fbDx5_gc",
      "createdAt": 1711970551660,
      "updatedAt": 1711970564942
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::adjacent_find",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::adjacent_find is a simple algorithm that returns the iterator to the first pair of adjacent elements that satisfy the provided binary predicate.\n\nThe iterator will point to the first of the two elements.\n\nThe algorithm has both the C++17 parallel execution variants and C++20 ranges version.\n\n#include <string>\n#include <algorithm>\n\nstd::string delimited = \n  \"this is a string\\\"(with an embeded message)\\\" that continues\";\n\n// Find the sequence \"(\nauto start = std::adjacent_find(\n  delimited.begin(), delimited.end(), \n  [](char l, char r) {\n return l == '\"' && r == '(';\n  });\n\n// Find the sequence )\" that follows \"(\nauto end = std::adjacent_find(\n  start, delimited.end(), \n  [](char l, char r) {\n    return l == ')' && r == '\"';\n  });\n\nstd::string embeded(start+2, end); // skip over \"(\n// embeded == \"with an embeded message\"\n\ndelimited.erase(start, end+2); // also erase )\"\n// delimited == \"this is a string that continues\""
        }
      ],
      "id": "XOss4DFi",
      "createdAt": 1711970616843,
      "updatedAt": 1711970631404
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::timed_mutex, std::recursive_timed_mutex, std::shared_timed_mutex",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Timed mutex variants (std::timed_mutex, std::recursive_timed_mutex and std::shared_timed_mutex) offer support for timeouts when waiting on a lock. The timeout the be specified as either a time point or a duration.\n\nAdding timeouts to mutexes allows a program to give up waiting on a lock and potentially report an error instead of being stuck in a hard-to-detect state.\n\n#include <thread>\n#include <mutex>\n#include <chrono>\n#include <syncstream>\n#include <iostream>\n\nusing namespace std::chrono_literals;\n\nstd::timed_mutex mux;\n// This thread will hold the lock for 2 seconds\nauto t = std::jthread([&mux]{\n    std::unique_lock lock(mux);\n    std::this_thread::sleep_for(2s);\n});\n\nauto runner = [&mux]{\n    // Try to obtain the lock for 200ms\n    std::unique_lock lock(mux, 200ms);\n    if (!lock.owns_lock()) {\n        std::osyncstream(std::cerr) << \"Unable to obtain lock.\\n\";\n        return;\n    }\n    std::osyncstream(std::cerr) << \"Lock was obtained.\\n\";\n};\n\n// Generally, first two attempts will time out\n// the other two attempts should succeed.\nauto r1 = std::jthread(runner);\nstd::this_thread::sleep_for(1s);\nauto r2 = std::jthread(runner);\nstd::this_thread::sleep_for(1s);\nauto r3 = std::jthread(runner);\nstd::this_thread::sleep_for(1s);\nauto r4 = std::jthread(runner);"
        }
      ],
      "id": "nDf-hlhc",
      "createdAt": 1711970703886,
      "updatedAt": 1711970726499
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::condition_variable, std::condition_variable_any",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::condition_variable and std::condition_variable_any wrap the logic of a thread waiting on a precondition.\n\nNot uncommonly, a thread doesn’t just need to acquire a lock to progress; certain conditions also need to be satisfied. For example, the inputs need to be ready.\n\nCondition variables take an acquired lock and a condition and will:\n\n    release the lock and suspend the thread\n    when the thread is awakened, the condition variable will attempt to reacquire the lock; if that fails, the thread is suspended again, and we repeat 2.\n    if the lock is successfully acquired, the condition is checked; if it is still false, we repeat 1.\n    if the condition is true, the wait() call on the condition variable finishes, and the thread now holds the lock, and the checked condition is guaranteed true\n\nAside from the condition blocking, the condition variables also support waking one or all threads waiting on the condition through the notify_one() and notify_all() methods.\n\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <syncstream>\n#include <iostream>\nusing namespace std::chrono_literals;\n\nstruct Resource {\n    bool full = false;    \n    std::mutex mux;\n    // Note that std::condition_variable only works with\n    // std::unique_lock<std::mutex>, for other combinations\n    // use std::condition_variable_any which may be less efficient.\n    std::condition_variable cond;\n    void produce() {\n        {\n        std::unique_lock lock(mux);\n        // wait until the condition is true\n        // 1. the lock is released\n        // 2. when the thread is woken up, the lock is reacquired \n        //    and the condition checked\n        // 3. if the condition is still not true, the lock \n        //    is rereleased, and we go to step 2.\n        // 4. if the condition is true, the wait() call finishes\n        cond.wait(lock, [this]{ return !full; });\n        std::osyncstream(std::cout) << \n          \"Filling the resource and notifying the consumer.\\n\";\n        full = true;\n        std::this_thread::sleep_for(200ms);\n        }\n        // wake up one thread waiting on this condition variable\n        // note that we already released our lock, otherwise\n        // the notified thread would wake up and fail to acquire\n        // the lock and suspend itself again\n        cond.notify_one();\n    }\n    void consume() {\n        {\n        std::unique_lock lock(mux);\n        // same as above, but with opposite semantics\n        cond.wait(lock, [this]{ return full; });\n        std::osyncstream(std::cout) << \n          \"Consuming the resource and notifying the producer.\\n\";\n        full = false;\n        std::this_thread::sleep_for(200ms);\n        }\n        cond.notify_one();\n    }\n};\n\nint main() {\n    Resource resource;\n    auto t1 = std::jthread([&resource](std::stop_token token){\n        while (!token.stop_requested())\n            resource.produce();\n    });\n    auto t2 = std::jthread([&resource](std::stop_token token){\n        while (!token.stop_requested())\n            resource.consume();\n    });\n    std::this_thread::sleep_for(2s);\n    t1.request_stop();\n    t2.request_stop();\n    // Note: using request_stop here is unsafe.\n\n    // If we removed the sleep_for, the t2 thread could \n    // run an entire loop before it notices the stop request \n    // and considering that t1 no longer runs, the blocking\n    // condition would never be fulfilled.\n\n    // This can be prevented by using condition_variable_any, \n    // which supports a stop token, or a timeout.\n}"
        }
      ],
      "id": "pH_jvSen",
      "createdAt": 1711970741354,
      "updatedAt": 1711970761461
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::shift_left, std::shift_right",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::shift_left and std::shift_right algorithms move elements in the provided range by the specified amount of positions.\n\nBecause these algorithms internally move, they can be simulated by manually calling the std::move algorithm with the correct source and destination iterators. However, the std::shift_left and std::shift_right algorithms make it a lot less error-prone.\n\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n\n// For trivial types, moves behaves as a copy\nstd::vector<int> data{1,2,3,4,5,6,7,8,9};\nstd::shift_left(data.begin(), data.end(), 3);\n// data == {4, 5, 6, 7, 8, 9, 7, 8, 9}\n\ndata = {1,2,3,4,5,6,7,8,9};\nstd::shift_right(data.begin(), data.end(), 3);\n// data == {1, 2, 3, 1, 2, 3, 4, 5, 6}\n\n\n// Type that sets a special value when moved from\nstruct EmptyOnMove {\n    char value;\n    EmptyOnMove(char value) : value(value) {}\n    EmptyOnMove(EmptyOnMove&& src) \n      : value(std::exchange(src.value,'-')) {}\n    EmptyOnMove& operator=(EmptyOnMove&& src) {\n        value = std::exchange(src.value, '-');\n        return *this;\n    }\n    EmptyOnMove(const EmptyOnMove&) = default;\n    EmptyOnMove& operator=(const EmptyOnMove&) = default;\n};\n\nstd::vector<EmptyOnMove> nontrivial{\n  {'a'},{'b'},{'c'},{'d'},{'e'},{'f'},{'g'}};\nstd::shift_right(nontrivial.begin(), nontrivial.end(), 4);\n// nontrivial == {-,-,-,d,a,b,c}\n// abc were moved, hence source elements have value '-'\n// d wasn't moved"
        }
      ],
      "id": "3BXerMZg",
      "createdAt": 1711970785249,
      "updatedAt": 1711970794343
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::barrier",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::barrier is a C++20 synchronization primitive that enables the creation of synchronized phases of execution across multiple threads.\n\nSimilar to a std::latch, the barrier is initialized with a counter; however, unlike std::latch, the barrier is re-usable and, on top of that, will call an optional completion function before unblocking the waiting threads.\n\n#include <barrier>\n#include <syncstream>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <algorithm>\n\n// Barrier with a completion function that prints\n// the phase information:\nstd::barrier phase(4,[id = 1] mutable {\n    std::osyncstream(std::cout) << \"Phase \" << id << \" complete.\\n\"; \n    id++;\n});\n\nstd::vector<std::jthread> runners;\n// Start 4 threads:\nstd::generate_n(std::back_inserter(runners), 4, [&phase]{\n    return std::jthread([&phase]{\n        std::osyncstream(std::cout) << \"Running phase 1 for thread \" << \n            std::this_thread::get_id() << \"\\n\";\n        std::this_thread::yield();\n        // block until all threads arrive\n        phase.arrive_and_wait();\n\n        std::osyncstream(std::cout) << \"Running phase 2 for thread \" << \n            std::this_thread::get_id() << \"\\n\";\n        std::this_thread::yield();\n        // block until all threads arrive\n        phase.arrive_and_wait();\n    });\n});\n// This is guaranteed to print:\n// Running phase 1 for thread xxxxx (for each of the four threads)\n// Phase 1 complete.\n// Running phase 2 for thread xxxxx (for each of the four threads)\n// Phase 2 complete.\n\nOpen this example in Compiler Explorer.\n\nThreads can also decrease the global counter, thus removing themselves from the synchronization.\n\n#include <barrier>\n#include <syncstream>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <algorithm>\n#include <random>\n\n// Barrier without a custom completion function:\nstd::barrier other(5);\nstd::vector<std::jthread> runners2;\n// Start 5 threads:\nstd::generate_n(std::back_inserter(runners2), 5, [&other]{\n  return std::jthread([&other]{\n    std::mt19937 gen(\n      std::hash<std::thread::id>{}(std::this_thread::get_id()));\n    std::bernoulli_distribution d(0.3);\n\n    int id = 1;\n    while (true) {\n        std::osyncstream(std::cout) << \"Running phase \" << id << \n          \" for thread \" << std::this_thread::get_id() << \"\\n\";\n        std::this_thread::yield();\n        if (d(gen)) { // generate random boolean\n            // decrease the barrier initial counter\n            // so that it waits for n-1 threads\n            other.arrive_and_drop();\n            return;\n        }\n      \n        // Otherwise block until all (still running) threads arrive.\n        other.arrive_and_wait();\n        ++id;\n    }\n  });\n});\n// This will print consecutive phases, with the number of \n// threads in each phase randomly decreasing."
        }
      ],
      "id": "iWyqWpel",
      "createdAt": 1711970827457,
      "updatedAt": 1711970849680
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::unique, std::unique_copy",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::unique algorithm is typically used in conjunction with a sorted range to produce the list of unique values.\n\nHowever, the algorithm simply removes consecutive duplicate values (by shifting the elements in the range) and can work with any range. The std::unique_copy variant instead outputs the unique values through the provided iterator.\n\n#include <vector>\n#include <algorithm>\n#include <ranges>\n#include <iterator>\n#include <iostream>\n\nstd::vector<int> data{1, 2, 2, 3, 2, 3, 3, 1, 1, 1};\n\n// Remove duplicates, by shifting elements forward\n// returns an iterator to the new end\nauto it = std::unique(data.begin(), data.end());\n\nfor (auto v : std::ranges::subrange(data.begin(), it))\n    std::cout << v << \" \";\nstd::cout << \"\\n\";\n// prints: \"1 2 3 2 3 1\"\n\n// To actually remove the elements we need to call erase\ndata.erase(it, data.end());\nfor (auto v : data)\n    std::cout << v << \" \";\nstd::cout << \"\\n\";\n// prints: \"1 2 3 2 3 1\"\n\n// Copy variant outputs the unique elements through\n// the provided iterator: \n// - copy integers from stdin to stdout, filtering duplicates\nstd::ranges::unique_copy(std::views::istream<int>(std::cin), \n    std::ostream_iterator<int>(std::cout, \" \"));\nstd::cout << \"\\n\";\n// For input: \"1 2 2 3 2 3 3 1 1 1\"\n// prints: \"1 2 3 2 3 1\""
        }
      ],
      "id": "lekZPXL0",
      "createdAt": 1711970883216,
      "updatedAt": 1711970896370
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "| [[nodiscard]] constructors and types",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The typical use case for [[nodiscard]] is for marking functions whose returns should not be ignored. However, we can also apply [[nodiscard]] to constructors and entire types.\n\nWhen applied to a constructor, the constructor cannot be used to construct ephemeral temporaries, i.e., temporaries that are immediately destroyed.\n\nWhen applied to a type, results of that type will be considered [[nodiscard]] even when not marked as such by the function.\n\nstruct ResourceHandle {\n    // Nodiscard constructor\n    [[nodiscard]] ResourceHandle() { acquire_resource(); };\n    ~ResourceHandle() { release_resource(); }\n};\n\n// Nodiscard type\nstruct [[nodiscard]] Error {};\n\n// nodiscard not needed, since Error is a nodiscard type\nError function() {\n    return {};\n}\n\n\n// Warning, ignoring constructor declared with nodiscard\nResourceHandle{}; // resource acquired and immediately released\n\n// Warning, ignoring return value marked with nodiscard\nfunction(); // ignoring Error"
        }
      ],
      "id": "FfPtvD_Z",
      "createdAt": 1711972202107,
      "updatedAt": 1711972209531
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::reverse",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::views::reverse is a conceptually simple view that will produce a reversed view of the provided range.\n\nThe view requires a bidirectional range and will work even with uncommon ranges; however, remember that the view requires access to the end iterator, which can trigger eager evaluation.\n\n#include <ranges>\n#include <list>\n\nstd::list<int> data{1,2,3,4,5,6};\n\nfor (auto e : data | std::views::reverse) {\n    // iterate over {6,5,4,3,2,1}\n}\n\n// Reversing a views::reverse is guaranteed to be a noop\nauto noop = data | std::views::reverse | std::views::reverse;\n// noop.begin() == data.begin(), noop.end() == data.end()\n\n// v is bidirectional range, but is not common\n// the end() returns a sentinel not an iterator\nauto v = data | std::views::take_while([](int v) { \n    return v <= 3; \n});\n\n// OK, combining a bidirectional range with views::reverse\nauto w = v | std::views::reverse;\n\n// Linear operation, w.begin() forces v.end() to be calculated\n// to produce an iterator.\nauto value = *w.begin();\n// value == 3, w == {3,2,1}"
        }
      ],
      "id": "x1lfwojN",
      "createdAt": 1711972276794,
      "updatedAt": 1711972285016
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::addressof",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++11 std::addressof utility solves a very simple problem.\n\nHow do you obtain the actual address of an object when the built-in address-of operator can be overloaded?\n\n#include <memory>\n#include <cassert>\n\nstruct X {\n    X* operator&() {\n        return nullptr;\n    }\n};\n\n\nX x;\n\n// overload for operator& always returns nullptr\nassert(&x == nullptr);\n\n// actual address of the object\nassert(std::addressof(x) != nullptr);"
        }
      ],
      "id": "k18UYFDm",
      "createdAt": 1711972285846,
      "updatedAt": 1711972325494
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::rotate",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::rotate is a surprisingly useful yet very simple algorithm.\n\nThe algorithm left-rotates the elements of the given range so that the element under the iterator passed as the second argument ends up as the first element.\n\n#include <vector>\n#include <algorithm>\n\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7};\n\n// left-rotate the range by one element\nstd::rotate(data.begin(), std::next(data.begin()), data.end());\n// data = { 2, 3, 4, 5, 6, 7, 1 }\n\n// rotate by aditional 3 elements\nstd::rotate(data.begin(), std::next(data.begin(), 3), data.end());\n// data = { 5, 6, 7, 1, 2, 3, 4 }"
        }
      ],
      "id": "y8K7jHyx",
      "createdAt": 1711972346663,
      "updatedAt": 1711972358027
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Range-for loop",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The range-based loop was introduced in C++11; however, only with the introduction of C++20 views can it replace almost all instances for raw for-loops.\n\n#include <algorithm>\n#include <vector>\n#include <ranges>\n\n// C++11: iterate over values in an initializer list\nfor (auto v : {1, 1, 2, 3, 5, 8, 13}) {}\n\n// C++20: iterate over [1,10), values 1..9\nfor (auto v : std::views::iota(1, 10)) {}\n\n// C++20: downward iteration 5..-5\nfor (auto v : std::views::iota(-5, 6) | std::views::reverse) {}\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};\nauto it = std::ranges::lower_bound(data, 5);\n\n// C++20: iterating over sub-range, 1..4\nfor (auto v : std::ranges::subrange(data.begin(), it)) {}\n// C++20: iterating over sub-range, 5..9\nfor (auto v : std::ranges::subrange(it, data.end())) {}\n\n// C++23: nested loop replacement\n// iterate over i==[0,5), j==[0,5)\nfor (auto [i,j] : std::views::cartesian_product(\n                    std::views::iota(0,5),\n                    std::views::iota(0,5))) {}"
        }
      ],
      "id": "S1jjF4yx",
      "createdAt": 1711972368247,
      "updatedAt": 1711972401312
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "final specifier",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The final specifier can be applied to methods and classes.\n\nWhen a method is marked as final, it cannot be overridden in derived classes. When a class is marked as final, it cannot be derived from.\n\nNote that final is not a reserved keyword, meaning that you can create variables and types with the name final. Although, in the case of types, that may lead to some confusion.\n\nstruct A final {};\n\n// Would not compile, A is marked as final.\nstruct B : A {};\n\nstruct X {\n    virtual void method() = 0;\n};\nstruct Y : X {\n    void method() override final {} \n};\n\n// Would not compile, B::method is marked as final.\nstruct Z : Y {\n    void method() override {}\n};\n\n// final is not a reserved keyword\nstruct final final {}; // struct final, which cannot be derived from\n\nint main() {\n    final f; // OK\n}"
        }
      ],
      "id": "-c8M9N_k",
      "createdAt": 1711972402898,
      "updatedAt": 1711972413159
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Class Template Argument Deduction (CTAD)",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++17 Class Template Argument Deduction (CTAD) enables class template deduction from the constructor call.\n\nThis typically eliminates redundant type information, improving readability and removing the possibility of an accidental type mismatch.\n\n#include <mutex>\n#include <vector>\n\n// Simpler use of utility types\nstd::mutex m;\nauto g = std::lock_guard(m);\n// Same as: auto g = std::lock_guard<std::mutex>(m);\n\nstd::pair el{20, false};\n// Same as: std::pair<int, bool> el{20, false};\n\n\n// Simpler code inside of generic functions\nauto function(auto&& x) {\n    std::vector data(10, x);\n    // Same as:\n    // std::vector<std::remove_cvref_t<decltype(x)>> data(10, x);\n}\n\n// Since C++20 also works for aggregate initialization\ntemplate <typename A, typename B, typename C>\nstruct SimpleType : A{\n    B x;\n    C y;\n};\n\nstruct Base{};\n\nSimpleType a{Base{}, 10, 20};\n// Same as: SimpleType<Base,int,int> a{Base{}, 10, 20};"
        }
      ],
      "id": "_5vaXpe1",
      "createdAt": 1711972435335,
      "updatedAt": 1711972442403
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Deduction guides for CTAD",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Deduction guides are rules that instruct Class Template Argument Deduction.\n\nThe compiler automatically generates guides that map each constructor call argument to a template argument.\n\nHowever, we can also provide custom guides to modify the functionality or trigger CTAD when the constructor arguments don’t directly map to template arguments.\n\n#include <string>\n#include <vector>\n\ntemplate <typename T>\nstruct Storage {\n    Storage(T t) : t_(t) {}\n    template<typename It> Storage(It begin, It end) : t_(begin,end) {}\n    T t_;\n};\n\n// Constructor match -> Template instance\nStorage(const char*) -> Storage<std::string>;\n\n// Deduction guides can be templated\ntemplate<typename It>\nStorage(It,It) -> Storage<std::vector<typename It::value_type>>;\n\n\nStorage a{10};\n// Storage<int> - guide generated by compiler\n// deduced from Storage(T t)\n\nStorage b{\"Hello World!\"};\n// Storage<std::string> - follows the const char* guide\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6};\nStorage c{data.begin(), data.end()};\n// Storage<std::vector<int>> - follows the double iterator guide"
        }
      ],
      "id": "lhbgVZpl",
      "createdAt": 1711972473456,
      "updatedAt": 1711972480468
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::includes",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::includes algorithm determines whether the second range is a (not necessarily contiguous) subsequence of the first range.\n\nBoth ranges must be sorted with respect to the same strict weak ordering. However, because of the sorted requirement, the algorithm operates in O(n).\n\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> haystack{1,2,3,4,5,6,7,8,9,10};\nstd::vector<int> needle1{3,4,9};\n\nbool v1 = std::includes(haystack.begin(), haystack.end(),\n                        needle1.begin(), needle1.end());\n// v1 == true\n\nstd::vector<int> needle2{3,3};\nbool v2 = std::includes(haystack.begin(), haystack.end(),\n                        needle2.begin(), needle2.end());\n// v2 == false\n\n\nstruct Item {\n    int id;\n    std::string label;\n};\nstd::vector<Item> inventory{\n  {0,\"Banana\"},{3,\"Apple\"},{4,\"Cherry\"},{5,\"Melon\"}};\nstd::vector<Item> order{{3,\"Apple\"},{5,\"Melon\"}};\n\n// Check whether all items in the order are currently in the inventory.\n// Project both ranges so that we only compare IDs.\nbool all_in_stock = std::ranges::includes(inventory, order,\n                                          {}, &Item::id, &Item::id);\n// all_in_stock == true"
        }
      ],
      "id": "mvtnl8R2",
      "createdAt": 1711972481812,
      "updatedAt": 1711972499491
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Nested namespace syntax",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When working with large codebases, we often deal with deeply nested namespaces. This can be verbose and tedious.\n\nC++17 introduced a simplified syntax for nested namespaces that compresses the specification into a single statement.\n\n// Before C++17\nnamespace LibraryName {\n    namespace ComponentName {\n        namespace ModuleName {\n            struct SomeType {};\n        }\n    }\n}\n\n// Since C++17\nnamespace LibraryName::ComponentName::ModuleName {\n    struct SomeOtherType {};\n}"
        }
      ],
      "id": "6xMD2tZc",
      "createdAt": 1711972605855,
      "updatedAt": 1711972611436
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::filter",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 std::views::filter produces a view of elements from the underlying range that satisfy the provided predicate (skipping over those that do not).\n\nThe view models up to a bidirectional range (based on the underlying range’s properties) and supports a common range interface (if provided by the underlying range).\n\n#include <ranges>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> data{1,2,3,4,5,6,7};\n\nauto filtered = data | std::views::filter([](int v) {\n    return v % 2 == 0;\n});\n// filtered is a bidirectional common range\nstd::vector<int> out(filtered.begin(), filtered.end());\n// out == {2,4,6}\n\nauto uncommon = std::views::iota(1) | std::views::take(7) | \n    std::views::filter([](int v) {\n        return v % 2 == 0;\n    });\n// uncommon is a bidirectional uncommon range\n\n// Wouldn't compile (requires a common range)\n// std::vector<int> out2(uncommon.begin(), uncommon.end());\n\nstd::vector<int> out3;\nstd::ranges::copy(uncommon, std::back_inserter(out3));\n// out3 == {2,4,6}"
        }
      ],
      "id": "4dfj2VkI",
      "createdAt": 1711972658369,
      "updatedAt": 1711972670128
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::optional",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 standard introduced a monadic interface for std::optional<T>.\n\n    transform(f(T)->U)->std::optional<U>\n    If the source is not empty, it invokes a transformation function f(T)→U and wraps the result in std::optional<U>.\n    and_then(f(T)->std::optional<U>)->std::optional<U>\n    If the source is not empty, it invokes a transformation function f(T)→std::optional<U> and returns the result.\n    or_else(f()->std::optional<T>)->std::optional<T>\n    If the source is empty, it invokes the generation function f()→std::optional<T> and returns the result.\n\n#include <optional>\n#include <string>\n\nstd::string stringify(int v) {\n    return std::to_string(v);\n}\n\nint integerify(const std::string& s) {\n    return std::stoi(s);\n}\n\nstd::optional<int> fetch_from_db() {\n    return 42;\n}\n\n\n// std::optional<>::tranform() a wrapper for transformation functions\nstd::optional<int> x;\nauto r1 = x.transform(stringify)\n           // does not invoke stringify\n           // returns empty std::optional<std::string>\n           .transform(integerify); \n           // does not invoke integerify\n           // returns empty std::optional<int>\n// r1 == std::nullopt\n\n\nx = 42;\nauto r2 = x.transform(stringify)\n           // invokes stringify on int{42}\n           // returns std::optional{\"42\"};\n           .transform(integerify);\n           // invokes integerify on std::string{\"42\"}\n           // returns std::optional{42};\n// r2 == int{42}\n\n\n// std::optional<>::and_then() a wrapper for a transformation function\n// that returns an optional (i.e. can return an empty one)\n// Transformation is invoked only when the optional is not empty.\nauto r3 = x.and_then([](int& x) {\n    if (x == 42)\n        return std::optional<std::string>(\"Answer to the Ultimate Question of Life, the Universe, and Everything\");\n    else\n        return std::optional<std::string>{};\n});\n// r3 == std::string{\"Answer to the Ultimate Question of Life, the Universe, and Everything\"}\n\n\n// std::optional<>::or_else a wrapper for a generation function\n// that returns an optional.\n// The function is only invoked when the optional is empty.\nx = std::nullopt;\nauto r4 = x.or_else(fetch_from_db);\n// r4 == int{42}\n\n\n// More involved example:\nauto r5 = fetch_from_db().or_else([](){\n    // Invoked if fetch_from_db returns an empty optional\n    return std::optional<int>{42}; \n}).transform([](int x) -> double{\n    // Invoked on the result of fetch_from_db or or_else\n    // converts to double.\n    return x*x;\n}).and_then([](double x){\n    // Invoked on the result of transform and because we \n    // have preceeding or_else this will always be invoked.\n    if (x > 0) {\n        return std::optional<std::string>{\"42\"};\n    } else {\n        return std::optional<std::string>{};\n    }\n}).or_else([](){\n    // Invoked if and_then returned an empty optional\n    return std::optional<std::string>{\"Empty\"};\n});\n// r5 == std::string{\"42\"}"
        }
      ],
      "id": "ymoEsI9d",
      "createdAt": 1711972678869,
      "updatedAt": 1711972690833
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::any",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::any, introduced in C++17, will hold a single copy-constructible value of any type.\n\nstd::any can be treated as a type-safe alternative to void*, with the caveat (and benefit) that std::any provides value semantics.\n\n#include <any>\n#include <stdexcept>\n\nstruct BasicPayload {};\nstruct ExtendedPayload {};\n\nvoid function(std::any payload) {\n    if (payload.type() == typeid(BasicPayload)) {\n        // Process basic payload\n    } else if (payload.type() == typeid(ExtendedPayload)) {\n        // Process extended payload\n    } else {\n        throw std::runtime_error(\"Bad payload type.\");\n    }\n}\n\n\nfunction(BasicPayload{});\nfunction(ExtendedPayload{});\nfunction(10); // throws std::runtime_error\n\nstd::any holder; // Empty std::any\nassert(holder.has_value() == false);\n\nholder = 42;\ntry {\n    // OK, holder holds an int, returns copy\n    int v = std::any_cast<int>(holder);\n\n    // Also OK, obtain pointer to contained data\n    int *p = std::any_cast<int>(&holder);\n\n    // Not OK, will throw bad_any_cast\n    double w = std::any_cast<double>(holder);\n} catch (const std::bad_any_cast&) {}"
        }
      ],
      "id": "ARFrSoT1",
      "createdAt": 1711972695537,
      "updatedAt": 1711972711665
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::sort",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::sort is perhaps one of the most well-known algorithms.\n\nThe algorithm sorts elements (by default in non-descending order) and doesn’t maintain the relative order of equivalent elements.\n\nC++17 standard added a parallel variant.\nThe C++20 standard added a range version and enabled constexpr evaluation for all but the parallel variant.\n\n#include <algorithm>\n#include <vector>\n#include <execution>\n\n\nstd::vector<int> data{9,2,6,4,3,5,1,7,8};\n\n// Default sort using operator<\nstd::sort(data.begin(), data.end());\n// data == {1,2,3,4,5,6,7,8,9}\n\n// Sort with custom comparator\nstd::sort(data.begin(), data.end(), std::greater<>{});\n// data == {9,8,7,6,5,4,3,2,1}\n\n// Same as above, but using a lambda\nstd::sort(data.begin(), data.end(), \n          [](int l, int r) { return l > r; });\n// data == {9,8,7,6,5,4,3,2,1}\n\n// C++17 parallel version\nstd::sort(std::execution::par_unseq, data.begin(), data.end());\n// data == {1,2,3,4,5,6,7,8,9}\n\n// C++20 range version\n// Note: default comparator is std::ranges::less{}, not operator<\nstd::ranges::sort(data, std::ranges::greater{});\n// data == {9,8,7,6,5,4,3,2,1}\n\nstruct Item {\n    int id;\n    std::string label;\n};\nstd::vector<Item> words{{9, \"bench\"}, {2, \"rain\"}, {0, \"reasonable\"},\n                        {5, \"fool\"}, {3, \"waist\"}, {7, \"insure\"}};\n\n// Sort lexicographically by label.\nstd::ranges::sort(words, {}, &Item::label);\n// std::ranges::sort(words, std::ranges::less{}, &Item::label);\n\n// {9:\"bench\", 5:\"fool\", 7:\"insure\", \n//  2:\"rain\", 0:\"reasonable\", 3:\"waist\"}\n\n// Sort by id, non-ascending\nstd::ranges::sort(words, std::ranges::greater{}, &Item::id);\n// {9:\"bench\", 7:\"insure\", 5:\"fool\", \n//  3:\"waist\", 2:\"rain\", 0:\"reasonable\"}"
        }
      ],
      "id": "Gm43F2RT",
      "createdAt": 1711972717753,
      "updatedAt": 1711972723029
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::midpoint",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Calculating the midpoint value between two arithmetic types or pointers might seem trivial; however, when the values are close to numerical limits or not in order, trivial implementations can easily run into undefined behaviour.\n\nC++20 introduced std::midpoint, which provides a safe implementation.\n\n#include <numeric>\n\n\nauto m1 = std::midpoint(std::numeric_limits<int>::max(),\n    std::numeric_limits<int>::max()-2);\n// m1 == std::numeric_limits<int>::max()-1\n\nint data[]={5, 9, 2, 3, 1, 8, 4, 6, 7};\nauto m2 = std::midpoint(data, data+9);\n// *m2 == 1\n\nauto m3 = std::midpoint(3.2, 7.6);\n// m3 ~= 5.4"
        }
      ],
      "id": "rjK-4TUS",
      "createdAt": 1711972744410,
      "updatedAt": 1711972763257
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::take, std::views::take_while",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 std::views::take and std::views::take_while produce views of the leading elements of the adapted range.\n\nAdditionally, std::views::take is optimized for random access ranges and will not introduce any overhead for std::span, std::string_view, std::views::iota, std::views::repeat and std::ranges::subrange (if it models random_access and sized).\n\n#include <ranges>\n#include <vector>\n\n\nstd::vector<int> data{1,2,3,4,5}; \n\n// First three elements of data\nauto x = data | std::views::take(3);\n// x == {1,2,3}\n// decltype(x) == std::ranges::take_view<std::vector<int>>\n\n\n// Taking more elements than available is safe\nauto y = data | std::views::take(42);\n// y = {1,2,3,4,5}\n// std::size(y) == 5\n\n\n// Optimized for span, string_view, views::iota, \n// views::repeated, ranges::subrange.\nauto z = std::span(data) | std::views::take(3);\n// z == {1,2,3}\n// decltype(z) == std::span<int>\n\n\n// Take until the predicate evaluates as false\nauto v = data | std::views::take_while([](int i) {\n    return i % 5 != 0;\n});\n// v == {1,2,3,4}"
        }
      ],
      "id": "sqwRSO-G",
      "createdAt": 1711972807403,
      "updatedAt": 1711972814758
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "explicit specifier",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Single-argument constructors and conversion operators should (almost) always be marked as explicit to prevent accidental silent conversions.\n\nWhen the conversion is desired, explicit operations can be invoked by spelling out the destination type.\n\nstruct Unsafe {\n    Unsafe(int v) : v_(v) {}\n    operator int() { return v_; }\nprivate:\n    int v_;\n};\n\nstruct Safe {\n    explicit Safe(int v) : v_(v) {}\n    explicit operator int() { return v_; }\nprivate:\n    int v_;\n};\n\nvoid function(Unsafe, int) {}\nvoid function(Safe, int) {}\n\n\nint v{10}; Unsafe x{20}; Safe y{30};\n\n// wrong argument order, no warnings\nfunction(v, x);\n// int->Unsafe{}, Unsafe{}->int implicit conversions\n\n// won't compile, no impl.conv. int->Safe && Safe->int\nfunction(v, y);\n\n// OK, explicit conversions\nfunction(Safe{v}, int{y});"
        }
      ],
      "id": "qYYozA9O",
      "createdAt": 1711972824547,
      "updatedAt": 1711972833706
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::replace, std::replace_if",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The two algorithms, std::replace and std::replace_if, will replace elements of a range that match the provided value or predicate with a new provided value.\n\nBoth algorithms are constexpr enabled (C++20) and have parallel (C++17) and range (C++20) variants.\n\n#include <string>\n#include <algorithm>\n#include <vector>\n\nstruct Cycle {\n    enum { VALID, EXPIRED, READY } state;\n    std::string data;\n};\n\n\nstd::vector<int> data{1,2,3,4,5,6};\n// Replace elements matching the value with \n// a different value.\nstd::replace(data.begin(), data.end(), 2, 8);\n// data == {1, 8, 3, 4, 5, 6}\n\n\nstd::vector<Cycle> runners{\n    {Cycle::VALID,\"hello\"},\n    {Cycle::EXPIRED,\"bye\"},\n    {Cycle::READY,\"i'm ready\"}\n    };\n\n// With C++20 projections, we can project each element\n// and compare against the projected value.\nstd::ranges::replace(runners,\n    Cycle::EXPIRED, // if equal to this\n    Cycle{Cycle::READY, \"let's go\"}, // replace with this\n    &Cycle::state); // project each element to the member state\n// runners == {{VALID,\"hello\"},{READY,\"let's go\"},{READY,\"i'm ready\"}}\n\n\n// Replace elements for which the predicate evaluates to true.\nstd::replace_if(data.begin(), data.end(),\n    [](int v) { return v % 2 == 0; }, \n    -1);\n// data == {1, -1, 3, -1, 5, -1}"
        }
      ],
      "id": "dbnZKJ5g",
      "createdAt": 1711972846153,
      "updatedAt": 1711972864544
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::type_index, boost::type_index",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::type_info object returned by the typeid operator does not provide access to the human-readable name of the type.\n\nWe can mitigate this issue manually by relying on the C++11 std::type_index and manually tracking the mapping between std::type_info and any desired information.\n\n#include <unordered_map>\n#include <string>\n#include <typeindex>\n#include <iostream>\n\nstruct A { virtual void fun() {} };\nstruct B : A {};\n\nstd::unordered_map<std::type_index, std::string> names;\n\nvoid inspector(A& a) {\n    std::cout << names[typeid(a)] << \"\\n\";\n}\n\n\n// Fill our custom mapping\nnames[typeid(A)] = \"Base\";\nnames[typeid(B)] = \"Derived\";\nnames[typeid(int)] = \"int\";\nnames[typeid(double)] = \"double\";\n\nint x = 20;\ndouble y = 2.4;\nstd::cout << names[typeid(x)] << \"\\n\";\n// prints: \"int\"\nstd::cout << names[typeid(y)] << \"\\n\";\n// prints: \"double\"\n\nA a;\nB b;\ninspector(a);\n// prints: \"Base\"\ninspector(b);\n// prints: \"Derived\"\n\nOpen the example in Compiler Explorer.\n\nAlternatively, we can rely on the boost::type_index library, which provides additional features.\n\n#include <boost/type_index.hpp>\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <iostream>\n\nnamespace bti = boost::typeindex;\n\nstruct A { virtual void fun() {} };\nstruct B : A {};\n\nvoid inspector(A& a) {\n    std::cout << bti::type_id_runtime(a).pretty_name() << \"\\n\";\n}\n\n\n// Compile time type information:\nint x = 20;\ndouble y = 2.4;\nstd::cout << bti::type_id<decltype(x)>().pretty_name() << \"\\n\";\n// prints: \"int\"\nstd::cout << bti::type_id<decltype(y)>().pretty_name() << \"\\n\";\n// prints: \"double\"\n\n// Runtime type information:\nA a;\nB b;\ninspector(a);\n// prints: \"A\"\ninspector(b);\n// prints: \"B\"\n\n// Also supports cv qualifiers (typeid doesn't)\nstd::cout << bti::type_id_with_cvr<const int>().pretty_name() << \"\\n\";\n// prints: \"int const\"\n\n// We also get demangling for complex nested types\nusing nested = std::unordered_map<A,std::vector<std::string>>;\nstd::cout << bti::type_id<nested>().pretty_name();\n// prints (GCC): \"std::unordered_map<A, std::vector<\n//                  std::__cxx11::basic_string<char..."
        }
      ],
      "id": "an-nE1Fb",
      "createdAt": 1711972872857,
      "updatedAt": 1711972886247
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::min_element, std::max_element and std::minmax_element",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::min_element, std::max_element and (C++11) std::minmax_element are min-max algorithms that operate on top of iterators, returning an iterator to the minimum/maximum element.\n\nThe algorithms provide parallel (C++17) variants and are constexpr and range enabled (C++20).\n\nC++20 also offers a simpler alternative: a range overload of the base min-max algorithms.\n\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> data{1,2,3,4,5};\n\nauto min = std::min_element(data.begin(), data.end());\n// min == data.begin(), *min == 1\n\n\nauto max = std::max_element(data.begin(), data.end());\n// max == std::prev(data.end()), *max == 5\n\n\nauto [mi,ma] = std::minmax_element(data.begin(), data.end());\n// mi == min, ma == max, *mi == 1, *ma == 5\n\n\n// If we only need the values, C++ 20 offers a simpler alternative:\nauto [x,y] = std::ranges::minmax(data); // Returns by-value\n// x == 1, y == 5\n\n\n// Example with projections:\nstruct Element {\n    int v;\n};\n\nstd::vector<Element> elements{{2},{1},{4},{5},{3}};\n// Select the minimum element based on the value of Element::v\nauto it = std::ranges::min_element(elements, {}, &Element::v);\n// *it == Element{1}"
        }
      ],
      "id": "42zBZaia",
      "createdAt": 1711972928398,
      "updatedAt": 1711972933724
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::filesystem::path, std::filesystem::directory_iterator",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++17 filesystem library introduced the notion of a filesystem path.\n\nPaths can be converted to their absolute, canonical and relative forms and tested for equivalence across all these types.\n\nPaths that refer to directories can be explored using directory iterators either only for that directory or recursively.\n\n#include <filesystem>\n#include <cassert>\n\nstd::filesystem::path local(\".\");\n// iterate over entries in directory specified by path\nfor (const auto& entry : std::filesystem::directory_iterator(local)) {\n    auto p1 = entry.path(); // e.g. ./file.ext\n    auto p2 = absolute(entry.path()); // e.g. /some/path/./file.ext\n    auto p3 = canonical(entry.path()); // e.g. /some/path/file.ext\n\n    // paths can be checked for equivalence (only for valid paths)\n    assert(equivalent(p1,p2));\n    assert(equivalent(p2,p3));\n}\n\n// recursively iterate over entries in directory specified by path\nfor (const auto& entry :\n     std::filesystem::recursive_directory_iterator(local)) {\n    auto p1 = entry.path(); // e.g. ./file.ext\n    auto p2 = absolute(entry.path()); // e.g. /some/path/./file.ext\n    auto p3 = canonical(entry.path()); // e.g. /some/path/file.ext\n}\n\n// Relative paths\nstd::filesystem::path a(\"/some/file/path\");\nstd::filesystem::path b(\"/some/other/path\");\n\nstd::filesystem::path c = relative(a,b);\n// c == \"../../file/path\""
        }
      ],
      "id": "XGnTO2l7",
      "createdAt": 1711972941362,
      "updatedAt": 1711972957060
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::partition, std::stable_partition",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::partition algorithm reorders elements of a range based on a predicate. Elements for which the predicate evaluates to true are all ordered before elements for which the predicate evaluates to false.\n\nThe stable version std::stable_partition also maintains the relative order of elements (within each partition).\n\n#include <algorithm>\n#include <vector>\n\n\nstd::vector<int> data1{1, 2, 3, 4, 5, 6, 7, 8, 9};\n\nauto pp1 = std::partition(data1.begin(), data1.end(), \n    [](int v) { return v % 2 == 0; }); // predicate for even numbers\n\n// [begin, partition_point) - even elements\nfor (auto it = data1.begin(); it != pp1; ++it) {}\n\n// [partition_point, end) - odd elements\nfor (auto it = pp1; it != data1.end(); ++it) {}\n\n\nstd::vector<int> data2{1, 2, 3, 4, 5, 6, 7, 8, 9};\n\nauto odd = std::ranges::stable_partition(data2,\n    [](int v) { return v % 2 == 0; }); // predicate for even numbers\n\n// Range version returns a sub-range {partition_point, end}\n// odd == {1, 3, 5, 7, 9} - guaranteed order\n\n// even elements\nauto even = std::ranges::subrange(data2.begin(), odd.begin());\n// even == {2, 4, 6, 8} - guaranteed order"
        }
      ],
      "id": "brmKIoY2",
      "createdAt": 1711973032107,
      "updatedAt": 1711973038582
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::sample",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::sample algorithm (C++17) is a stable (maintains relative order of elements) sampling algorithm that randomly copies the specified number of elements from the source range into the destination range (output iterator).\n\n#include <algorithm>\n#include <vector>\n#include <random>\n#include <iterator>\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};\nstd::vector<int> out;\n\nauto gen = std::mt19937(1); // fixed seed for deterministic result\n\nstd::sample(data.begin(), data.end(),   // input range\n    std::back_inserter(out),            // output iterator\n    4,      // number of elements to sample\n    gen);   // random number engine\n\n// stdlibc++: out == {1, 6, 8, 9}\n// libc++: out == {2, 4, 5, 9}"
        }
      ],
      "id": "jwBTIU4u",
      "createdAt": 1711973069954,
      "updatedAt": 1711973076459
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::deque",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::deque is a non-contiguous container that models a double-ended queue while still providing random access, albeit at the cost of one extra indirection.\n\nElements can be added and removed from each end of the queue with O(1) time complexity without invalidating existing iterators (except for the erased elements).\n\n#include <queue>\n\nstd::deque<int> data;\n\n// On top of push_back and pop_back we also get the same for front\ndata.push_back(1);\n// data == {1}\ndata.push_front(2);\n// data == {2, 1}\ndata.push_back(3);\n// data == {2, 1, 3}\n\ndata.pop_front();\ndata.pop_front();\n// data == {3}\n\n// Otherwise the std::deque offers the same interface as std::vector\ndata.resize(7, 42);\n// data == {3, 42, 42, 42, 42, 42, 42}\n\n// Insert/Erase from the middle is still O(n):\ndata.insert(data.begin()+1, 7);\n// data == {3, 7, 42, 42, 42, 42, 42, 42}\ndata.erase(data.begin()+2);\n// data == {3, 7, 42, 42, 42, 42, 42}"
        }
      ],
      "id": "2INcpS71",
      "createdAt": 1711973081270,
      "updatedAt": 1711973115891
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::adjacent_transform",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::view::adjacent_transform is a view that produces elements by continually applying the provided N-ary invocable to each consecutive group of N elements.\n\nThe functionality can be simulated by combining std::views::adjacent and std::views::transform, however, this is both less efficient and more cumbersome.\n\n#include <ranges>\n#include <vector>\n\nstd::vector<int> data{5,1,2,4,3};\n\nauto med3 = [](int a, int b, int c) {\n    if (a >= b) {\n        if (b >= c) return b;\n        if (a >= c) return c;\n        return a;      \n    } else {\n        if (c >= b) return b;\n        if (a >= c) return a;\n        return c;\n    }\n};\n\nauto medians = data | std::views::adjacent_transform<3>(med3);\n// medians == {2, 2, 3}\n\n// Same as the following, but avoiding the intermediate tuple:\nauto medians_twostep = data | std::views::adjacent<3> |\n  std::views::transform([&](auto&& e) {\n    return std::apply(med3, e);\n  });\n// medians_twostep == {2, 2, 3}\n\n// Simulating the adjacent difference algorithm.\n// The pairwise specialization is equivalent to adjacent_transform<2>.\nauto adjacent_difference = data |\n  std::views::pairwise_transform(std::minus<>{});\n// adjacent_difference == {4, -1, -2, 1}"
        }
      ],
      "id": "kdxt07Vd",
      "createdAt": 1711973172009,
      "updatedAt": 1711973177800
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::gcd and std::lcm",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The greatest common divisor and least common multiple are often used as simple programming exercises or interview questions.\n\nSince C++17, we finally have the standard versions of these functions as std::gcd and std::lcm in the numeric header.\n\ndelitel, nasobitel\n\n#include <numeric>\n\nauto gcd = std::gcd(2*3, 3*5);\n// gcd == 3\n\nauto lcm = std::lcm(2*3, 3*5);\n// lcm == 2*3*5"
        }
      ],
      "id": "xnaIHePg",
      "createdAt": 1711973194208,
      "updatedAt": 1711973324470
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::remove, std::remove_if",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::remove and std::remove_if compact a range so that the leading sub-range [begin, last) does not contain any elements that match the provided value or for which the provided predicate evaluates to true.\n\nThe number of elements in the underlying range is unaffected, the non-removed elements maintain their relative order, and the subrange [last, end) contains elements in a moved-from state.\n\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n\nstd::vector<int> data{1,2,3,4,5};\nauto it = std::remove(data.begin(), data.end(), 3);\n\n// [begin, it) contains non-removed elements\nauto remainder = std::ranges::subrange(data.begin(), it);\n// remainder == {1,2,4,5}\n\n// Range version since C++20, returns the [it, end) subrange\nauto removed = std::ranges::remove_if(remainder,\n    [](int v) { return v % 2 == 0; });\nauto odd = std::ranges::subrange(remainder.begin(), removed.begin());\n// odd == {1,5}\n\n// Move only object that sets its value to \"empty\" when moved from\nstruct Object {\n    Object(std::string value) : value(value) {}\n    Object(Object&& other) : \n    value(std::exchange(other.value,\"empty\")) {}\n    Object& operator=(Object&& other) { \n        value = std::exchange(other.value,\"empty\");\n        return *this;\n    }\n    std::string value;\n};\n\nstd::vector<Object> move_semantics;\nmove_semantics.emplace_back(\"hello\");\nmove_semantics.emplace_back(\"this\");\nmove_semantics.emplace_back(\"is\");\nmove_semantics.emplace_back(\"dog\");\n\nstd::ranges::remove_if(move_semantics,\n    [](auto &e) { return e.value.length() > 4; });\n// move_semantics == {{\"this\"},{\"is\"}, {\"dog\"}, {\"empty\"}}"
        }
      ],
      "id": "5Itjhotw",
      "createdAt": 1711973326028,
      "updatedAt": 1711973336348
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::list, std::forward_list",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::list and std::forward_list are containers with perfect iterator stability and support for O(1) splicing of elements.\n\nThe only situation that invalidates an iterator is the removal of elements, and only for the removed elements, even when splicing between containers.\n\nConsequently, traversing std::list and std::forward_list is roughly 5x-10x slower than std::vector.\n\n#include <list>\n#include <forward_list>\n\nstd::list<int> data{1,2,3,4,5};\nstd::list<int> other{6,7,8,9};\n\n// Get iterator to the third element.\n// Note, this is a linear operation:\n// i.e. auto it = std::next(std::next(data.begin()));\nauto it = std::next(data.begin(), 2);\n\n// Transfer the third element of data before the first element of other\nother.splice(other.begin(), data, it); // O(1) operation\n// it still valid, *it == 3\n// data == {1, 2, 4, 5}, other == {3, 6, 7, 8, 9}\n\n// std::list provides only bidirectional and std::forward_list\n// only forward iterator support.\n\n// But both provide common algorithms as methods:\nstd::forward_list<int> list{5,2,1,4,3};\n\nlist.sort(); // approx. n*logn\n// list == {1, 2, 3, 4, 5}\n\nlist.reverse(); // O(n)\n// list == {5, 4, 3, 2, 1}\n\n// std::forward_list provides an unusual interface due to forward list\n// structure (can only insert/erase after an element).\nlist.insert_after(list.before_begin(), 42); // O(1)\n// same as list.push_front(42);\n// list == {42, 5, 4, 3, 2, 1}\n\nlist.erase_after(list.begin()); // O(1)\n// list == {42, 4, 3, 2, 1}"
        }
      ],
      "id": "ajCSTD5r",
      "createdAt": 1711973373258,
      "updatedAt": 1711973385986
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::erase, std::erase_if",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Before C++20, erasing elements from most containers based on their value or a predicate was a two-step process.\n\nC++20 added a set of container-specific function overloads of std::erase and std::erase_if. These functions simplify the two-step process into a single call and (for the value version) support heterogeneous comparisons.\n\n#include <vector>\n#include <map>\n#include <algorithm>\n\n\nstd::vector<int> data{1,2,3,4,5};\n\nstd::erase(data, 3);\n// same as:\nauto it = std::remove(data.begin(), data.end(), 3);\ndata.erase(it, data.end());\n// data == {1, 2, 4, 5}\n\n\nstd::erase_if(data, [](int v) { return v % 2 == 0; });\n// same as:\nit = std::remove_if(data.begin(), data.end(), \n                    [](int v) { return v % 2 == 0; });\ndata.erase(it, data.end());\n\n\n// Additionally std::erase(_if) returns the number of erased elements:\nsize_t cnt = std::erase_if(data, [](int v){ return v != 0; });\n// cnt == 2, data == {}\n\n// Supported for:\n// std::vector, std::deque, std::list, std::forward_list, std::string\n\n\n// Heterogeneous comparison:\nstd::vector<std::string> mixed{\"hello\",\"this\",\"is\",\"dog\"};\nstd::erase(mixed, \"hello\");\n// \"hello\" directly compared with each element without conversion\n// mixed == {\"this\", \"is\", \"dog\"}\n\n\n// unordered and associative containers only support std::erase_if\nstd::map<int,int> map{{1,2},{2,3},{3,4}};\nstd::erase_if(map, [](auto &e) { return e.first < 3; });\n// map == {3->4}\n\n// Note that map::erase() already supports heterogeneous erase-by-value"
        }
      ],
      "id": "V_Dgz3JM",
      "createdAt": 1711973426830,
      "updatedAt": 1711973433305
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::initializer_list",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::initializer_list (C++11) is a simple proxy object around a const-array that is automatically constructed when a braced-initializer-list is:\n\n    used as a function argument\n    used to initialize or assign to an object with an appropriate constructor/assignment operator\n    bound to auto\n\nNote that we cannot move from a const array, which has performance implications.\n\n#include <initializer_list>\n#include <vector>\n\nstruct X {\n    X(std::initializer_list<int>) {}\n    X& operator=(std::initializer_list<int>){ return *this; }\n};\n\nvoid function(std::initializer_list<int>) {}\n\nstruct Data{};\n\n\n// Constructing an object\nX x{1, 2, 3, 4, 5};\n// Assigning to an object\nx = {1, 2, 3, 4, 5};\n\n// Function explicitly accepting initializer_list\nfunction({1, 2, 3, 4, 5});\n\n// Binding to auto\nauto y = {1, 2, 3, 4, 5};\n// decltype(y) == std::initializer_list<int>\n\n// initialized by copy-initialization\nData a, b;\nstd::vector<Data> z{a, b};\n// 4x copy\n//      2x to create std::initializer_list\n//      2x to create std::vector\n\n// C++17 guaranteed copy-elision\nstd::vector<Data> w{Data{}, Data{}};\n// copy-initialization from pr-values turns into direct-initialization\n// 2x copy to create std::vector"
        }
      ],
      "id": "sF9jndGq",
      "createdAt": 1711973449685,
      "updatedAt": 1711973455185
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Curiously Recurring Template Pattern",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Curiously Recurring Template Pattern (CRTP) is a C++ technique allowing us to pass type information about a derived class to a base class.\n\nA typical use case for CRTP is Mixin support, where we encapsulate functionality into a base class without relying on virtual dispatch. This way, the derived class can avoid becoming polymorphic and potentially remain trivially copyable.\n\n#include <span>\n#include <vector>\n\nstruct Connection{};\nstruct ServerConfig{};\n\n// The Base/Mixin type\ntemplate <typename Handler>\nstruct SimpleServer {\n    // Public interface, exposed through the derived class.\n    void listen() {\n        bool running = true;\n        while (running) {\n            Connection conn = accept_connection();\n            // Safe, because we know that Handler is a derived class.\n            static_cast<Handler*>(this)->handle_connection(conn);\n        }\n    }\nprotected:\n    // Protected interface, only usable by the derived class.\n    int read(Connection, std::span<std::byte>) { /* impl */ }\n    int write(Connection, std::span<std::byte>) { /* impl */ }\n    // Prevent accidental direct instantiation\n    SimpleServer(ServerConfig cfg) { /* impl */ }\nprivate:\n    Connection accept_connection() { /* impl */ }\n};\n\n// Users only need to initialize and implement the handle method.\nstruct ServerImpl : SimpleServer<ServerImpl> {\n    ServerImpl() : SimpleServer<ServerImpl>(ServerConfig{}) {}\n\n    void handle_connection(Connection conn) {\n        std::vector<std::byte> buff(64*1024);\n       // SimpleServer<SererImpl>::read()\n        int rres = read(conn, buff);\n      \n        /* process data */\n      \n        // SimpleServer<SererImpl>::write()\n        int wres = write(conn, buff);\n    }\n};\n\nint main() {\n    ServerImpl server;\n    server.listen();\n}"
        }
      ],
      "id": "UgM9mr0X",
      "createdAt": 1711973462833,
      "updatedAt": 1711973479419
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Argument Dependent Lookup (ADL)",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Argument Dependent Lookup (ADL) governs how unqualified function calls are resolved.\n\nAfter looking up a function in the current (and parent) namespace(s), the innermost namespaces of the types of arguments (simplified) will also be considered.\n\nDue to interactions with visibility rules, we can set up functions (callables) to only be invocable through ADL or qualified calls.\n\nnamespace lib1 {\n    struct X {\n        friend void adl_only(const X&) {}\n    };\n    X operator+(const X&, const X&) { return {}; }\n    void operate(const X&) {}\n    void shut_off(const X&) {}\n    constexpr inline auto only_explicit = [](const X&) {};\n}\n\nconstexpr inline auto shut_off = [](auto&&) {};\n\n\nlib1::X a,b;\n// Operator overloading requires ADL.\na = a + b; // Syntax sugar for: a = operator+(a, b);\n// Without operator overload we would have to write:\na = lib1::operator+(a, b);\n\n// ADL call, lookup finds lib1::operate()\n// because decltype(a) == lib1::X\noperate(a);\n// Qualified call still works.\nlib1::operate(a);\n\n// Non-function entities shut off ADL, this calls ::shut_off()\nshut_off(a);\n// Qualified call still works.\nlib1::shut_off(a);\n\n// Friend functions are members of the surrounding namespace,\n// but are not visible outside of ADL.\nadl_only(a);\n// lib1::adl_only(a); // Will not compile, not visible outside of ADL.\n\n// Non-function entities also do not participate in ADL.\n// only_explicit(a); // Will not compile not visible to ADL.\n// Qualified call still works.\nlib1::only_explicit(a);"
        }
      ],
      "id": "QlZMwyvo",
      "createdAt": 1711973486231,
      "updatedAt": 1711973492252
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::expected",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::expected is a C++23 type representing either a correct result or an unexpected error.\n\nSemantically, std::expected works very similarly to std::optional; instead of optionally storing a value, std::expected always stores either a result or an error.\n\n#include <expected>\n#include <string>\n#include <system_error>\n\n// Typical use case\nstd::expected<std::string,std::error_code> fun() {\n    if (/* some operation that can fail */)\n        return std::unexpected(std::make_error_code(\n         std::errc::invalid_argument));\n    return \"Hello World!\";\n}\n\n// Similar interface to std::optional\nstd::expected<int,int> v = 10;\n// v.has_value() == true\n// v.value() == 10, *v == 10\n\n\n// To distinguish the error, it has to be wrapped in std::unexpected\nstd::expected<int,int> e = std::unexpected{10};\n// e.has_value() == false\n// e.error() == 10\n\n\n// std::expected always contains either a result or an error\nstd::expected<int,int> m;\n// m.has_value() == true\n// m.value() == int{} == 0\n\n\n// Therefore if the result type cannot be default constructed\n// the resulting std::expected cannot be default constructed either.\nstruct NoDefault {\n    NoDefault(int) {}\n};\n// std::expected<NoDefault,int> n; // Wouldn't compile\nstd::expected<NoDefault,int> n{20}; // OK\n// n.has_value() == true"
        }
      ],
      "id": "7ohL5XBJ",
      "createdAt": 1711973499831,
      "updatedAt": 1711973506573
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::counted",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::views::counted is the C++20 range equivalent to the std::counted_iterator, producing a range from an iterator and the number of elements.\n\nSimilar to std::views::take, this view also handles contiguous and random-access-sized ranges efficiently.\n\nFor contiguous ranges, it produces a std::span; for random-access-sized ranges, it resolves the end iterator.\n\n#include <ranges>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nstd::vector<int> data{1,2,3,4,5};\n\nauto c = std::views::counted(data.begin(), 3);\n// decltype(c) == std::span<int>\n// c == {1,2,3}\n\n\nstd::deque<int> q{1,2,3,4,5};\nauto random = std::views::counted(q.begin(), 3);\n// random == {1,2,3}\n// *random.end() == 4, O(1) operation\n\n\n// More involed example:\n\n// Preallocate space for three elements.\nstd::vector<int> top_three(3);  \n// Produce the lowest three elements in top_three.\nstd::ranges::partial_sort_copy( \n    // From upto 5 integers read from the standard input.\n    std::views::counted( \n        std::istream_iterator<int>(std::cin), 5),\n    top_three\n);\n// For input: 13 97 42 7 666 1\n// top_three == {7, 13, 42}"
        }
      ],
      "id": "K95V1m4a",
      "createdAt": 1711973513403,
      "updatedAt": 1711973524492
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Customization point using ADL",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "One of the possibilities to introduce a customization point in a library is through ADL (Argument Dependent Lookup). With C++20 concepts, this approach got much cleaner.\n\nA Niebloid combined with a concept that detects the presence of custom implementation can handle the fallback to default implementation without the need to fiddle with namespaces on the calling site.\n\n#include <utility>\n\nnamespace dflt {\nnamespace impl {\n\n// Concept checking whether an ADL call is valid.\ntemplate <typename T> \nconcept HasADL = requires(T a) { do_something(a); };\n\n// Main machinery to pick between default or ADL implementation.\nstruct DoSomethingFn {\n    // Type has a custom implementation, simply call, relying on ADL.\n    template <typename T> void operator()(T&& arg) const\n    requires HasADL<T> { do_something(std::forward<T>(arg)); }\n\n    // Type doesn't have a custom implementation, use the default.\n    template <typename T> void operator()(T&&) const\n    requires (!HasADL<T>) { /* default implementation */ }\n};    \n}\n// Inline namespace makes the inline variable not conflict with \n// implementations for types in dflt namespace.\ninline namespace var {\n// Only invocable as dflt::do_something, not visible to ADL.\nconstexpr inline auto do_something = impl::DoSomethingFn{};\n}\n}\n\nnamespace lib { struct X { friend void do_something(const X&){}; }; }\nnamespace dflt { struct Y { friend void do_something(const Y&){}; }; }\n\nint main() {\n    int a = 0; lib::X x; dflt::Y y;\n    // No explicit implementation for int, falls back to default.\n    dflt::do_something(a);\n    // Calls the friend function do_something for X\n    dflt::do_something(x);\n    // Calls the friend function do_something for Y\n    dflt::do_something(y);\n\n    // Pure-ADL calls, will only invoke custom implementations.\n    do_something(x);\n    do_something(y);\n}"
        }
      ],
      "id": "gQ95p00O",
      "createdAt": 1711973530115,
      "updatedAt": 1711973538629
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::binary_search",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::binary_search is a presence-check algorithm that operates on at least partially ordered ranges (in regards to the searched-for value) and provides O(logn) complexity if the range models at least random-access iteration.\n\nThe algorithm does have a range variant and supports constexpr (both since C++20); however, as might be expected, it does not have a parallel variant.\n\n#include <algorithm>\n#include <vector>\n#include <ranges>\n\nstd::vector<int> data{1,2,3,4,5,6,7,8,9};\n\n// Default version with operator< as comparator\nbool contains = std::binary_search(data.begin(), data.end(), 4);\n// contains == true\n\n\n// Partially ordered example\ndata = {3,1,2,4,8,9,7,6,5};\n// OK because:\n// - all of {3,1,2} compare less than 4\n// - all of {8,9,7,6,5} compare not less than 4\ncontains = std::binary_search(data.begin(), data.end(), 4);\n// contains == true\n\n\n// Custom comparator example\nstd::ranges::sort(data, std::ranges::greater{});\n// The comparator has to consistent with the ordering in the range\ncontains = std::ranges::binary_search(data, 42, \n                                      std::ranges::greater{});\n// contains == false\n\ncontains = std::ranges::binary_search(data, 4, std::ranges::greater{});\n// contains == true\n\n\n// Projections are supported, however, keep in mind that when using\n// a custom projections, the required ordering applies to the projected \n// values.\ncontains = std::ranges::binary_search(data, -4, \n                                      std::ranges::less{},\n                                      std::negate<>{});\n// contains == true\n// Negating the value flips the comparator from greater to less."
        }
      ],
      "id": "c-Jpn7qZ",
      "createdAt": 1711973545313,
      "updatedAt": 1711973553801
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::equal_to, std::not_equal_to, std::greater, std::less, std::greater_equal, std::less_equal and std::compare_three_way",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The function objects std::equal_to, std::not_equal_to, std::greater, std::less, std::greater_equal, std::less_equal and (C++20) std::compare_three_way implement the corresponding comparison operations.\n\nThese objects can serve as comparators for algorithms that accept them. This saves us the hassle of writing a lambda just to return the result of comparing the two arguments.\n\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nstruct A {};\nstruct B {};\nbool operator<(A,B) { return false; }\n\n\nstd::vector<int> data{8,4,1,3,2,9,6,5,7};\n// Explicit specialization version:\nstd::ranges::sort(data, std::greater<int>{});\n// data == {9,8,7,6,5,4,3,2,1}\n\n// Explicit specialization can cause issues with implicit conversions.\nstd::vector<double> fpoint{4.2,4.1,4.3,4.4,4.9,4.5};\nstd::ranges::sort(fpoint, std::greater<int>{});\n// Unspecified order, but technically should be a no-op.\n// Reason: all elements are equal when converted to int.\n\n// C++14 <void> specialization with deduction\nstd::ranges::sort(fpoint, std::greater<>{});\n// Arguments of the comparator will be deducated as double.\n// fpoint == {4.9,4.5,4.4,4.3,4.2,4.1}\n\n// C++20 ranges version, arguments are always deduced.\nstd::ranges::sort(data, std::ranges::greater{});\n\n// When using with non-homogenous types, the behaviour differs.\nint x = 4; double y = 4.2;\n// Old style, explicit specified type with forced implicit conversion\nbool cmp1 = std::less<int>{}(x,y);\nbool cmp2 = std::less<double>{}(x,y);\n// cmp1 == false, cmp2 == true\n\n// C++14, both arguments are deduced, operator< potentially\n// aplied to a heterogeneous type.\nbool cmp3 = std::less<>{}(x,y); // <int,double>\n// cmp3 == true\n\n// C++20, both arguments are deduced, \n// but constrained with stricter semantics.\nbool cmp4 = std::ranges::less{}(x,y);\n// cmp4 == true\n\nstd::less<>{}(A{},B{}); // OK\n// std::ranges::less{}(A{},B{}); // Will not compile"
        }
      ],
      "id": "3upis7GG",
      "createdAt": 1711973598831,
      "updatedAt": 1711973607409
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::is_sorted, std::is_sorted_until",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++11 std::is_sorted, and std::is_sorted_until algorithms verify that the provided range is sorted in non-descending order (using the operator< or a comparator).\n\nThe std::is_sorted algorithm returns a boolean; the std::is_sorted_until returns an iterator to the first out-of-order element.\n\nBoth algorithms provide parallel (C++17), constexpr (C++20) and range versions (C++20).\n\n#include <algorithm>\n#include <vector>\n\n\nstd::vector<int> nonsort{1,2,3,4,5,2,7,8,9};\n\nauto r1 = std::is_sorted(nonsort.begin(), nonsort.end());\n// r1 == false\n\nauto r2 = std::is_sorted_until(nonsort.begin(), nonsort.end());\n// r2 == nonsort.begin()+5, *r2 == 2\n\n\nstd::vector<std::string> sort{\"x\",\"mn\",\"xyz\",\"ijkl\",\"abcde\"};\n\nauto r3 = std::ranges::is_sorted(sort,\n    [](const auto& l, const auto& r) {\n        return l.length() < r.length();\n    });\n// r3 == true\n\n// Note, that while technically the above is equivalent to\n// std::ranges::is_sorted(sort, {}, &std::string::length);\n// it would be undefined behaviour as we are not permitted to\n// take address of standard functions (including members).\n\nauto r4 = std::ranges::is_sorted_until(sort, \n    [](const auto& l, const auto& r) {\n        return l.length() < r.length();\n    });\n// r4 == sort.end()"
        }
      ],
      "id": "ncgnk_4q",
      "createdAt": 1711973625951,
      "updatedAt": 1711973630606
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::array",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::array is a container that represents fixed-sized arrays. Besides the range interface, std::array also avoids the implicit decay into a pointer (e.g. int[3] into int*).\n\nOn top of that, std::array doesn’t have explicit constructors, allowing it to maintain the trivially copyable property of the underlying data.\n\n#include <array>\n#include <algorithm>\n#include <functional>\n\nvoid fun(int,int,int,int,int) {}\nstruct A { A(int,int,int,int,int) {} };\n\n\nstd::array<int,5> data{1,2,3,4,5};\n\n// Models contiguous range\nstd::ranges::sort(data, std::greater<>{});\n// data == {5,4,3,2,1}\n\n// Models tupple-like (C++11)\nint x = std::get<2>(data);\n// x == 4\nsize_t sz = std::tuple_size<decltype(data)>{};\n// sz == 5\n\n// Since C++17:\nauto [a,b,c,d,e] = data;\n// a == 5, b == 4, c == 3, d == 2, e == 1\n\n// Since C++23:\n// Construct A with the elements of data\nA m = std::make_from_tuple<A>(data);\n// Call fun with the elements of data\nstd::apply(fun, data);"
        }
      ],
      "id": "C1PyFowc",
      "createdAt": 1711973635901,
      "updatedAt": 1711973640885
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::uninitialized_copy, std::uninitialized_fill, std::uninitialized_move, std::uninitialized_value_construct, std::uninitialized_default_construct, std::destroy",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Manual lifetime management and creating objects inside untyped memory blocks is a very niche topic.\n\nHowever, there are situations when std::vector isn’t sufficient.\n\nFortunately, the C++ standard library offers a set of uninitialized algorithms that provide default, copy, move and value construction and destruction on top of raw memory.\n\n#include <vector>\n#include <string>\n#include <memory>\n\nstd::vector<std::string> src{\"Hello\", \"World!\"};\n\n{ \nvoid* buffer = std::aligned_alloc(alignof(std::string),\n                                  sizeof(std::string) * src.size());\nif (buffer == nullptr) std::abort();\nauto raw_it = static_cast<std::string*>(buffer);\n  \n{ // Copy construction\nauto end_it = std::uninitialized_copy(src.begin(), src.end(), raw_it);\n// subrange(raw_it,end_it) == {\"Hello\", \"World!\"}\n\n// Manual creation requires manual destruction\nstd::destroy(raw_it, end_it);\n}  \n\n{ // Copy construction from a single value\nauto end_it = raw_it + src.size();\nstd::uninitialized_fill(raw_it, end_it, std::string(\"Something\"));\n// subrange(raw_it,end_it) == {\"Something\", \"Something\"}\n\n// Manual creation requires manual destruction\nstd::destroy(raw_it, end_it);\n}\n\n{ // (C++17) Move construction\nauto end_it = raw_it + src.size();\nstd::uninitialized_move(src.begin(), src.end(), raw_it);\n// subrange(raw_it,end_it) == {\"Hello\", \"World!\"}\n// src == {\"\", \"\"}\n\n// Manual creation requires manual destruction\nstd::destroy(raw_it, end_it);\n}\n\n// Free the buffer\nstd::free(buffer);\n}\n\n\n{ // (C++20) Value and Default construction\nconstexpr size_t size = 7;\nvoid* buffer = std::aligned_alloc(alignof(int), \n                                  sizeof(int) * size);\nif (buffer == nullptr) std::abort();\n\nauto raw_it = static_cast<int*>(buffer);\nauto end_it = raw_it + size;\n\n// Value construction (for POD types this means zero-initialization)\nstd::uninitialized_value_construct(raw_it, end_it);\n// subrange(raw_it, end_it) == {0, 0, 0, 0, 0, 0, 0}\n\n// For the next example\n*raw_it = 42;\n\n// Manual creation requires manual destruction\nstd::destroy(raw_it, end_it);\n\n// Default construction (for POD types this means no initialization)\nstd::uninitialized_default_construct(raw_it, end_it);\n// Technically, the content is indeterminate values.\n// In practical terms the data will typically not be touched.\n// subrange(raw_it, end_it) == {42, 0, 0, 0, 0, 0, 0}\n// If you want to rely on this, check with your compiler vendor.\n\n// Manual creation requires manual destruction\nstd::destroy(raw_it, end_it);\n\n// Free the buffer\nstd::free(buffer);\n}"
        }
      ],
      "id": "hwCJ4o8g",
      "createdAt": 1711973679916,
      "updatedAt": 1711973687828
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::binary_semaphore",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 std::binary_semaphore is a specialization of the more general std::counting_semaphore that only supports two values, 0 and 1.\n\nThe main use case of a binary semaphore is for simple signalling, where the alternative approach would be to use the combination of std::mutex, std::condition_variable and a boolean variable.\n\n#include <thread>\n#include <semaphore>\n#include <condition_variable>\n\n{\nstd::binary_semaphore signal(0);\nauto t = std::jthread([&signal]() {\n    // Wait until this thread is signaled\n    signal.acquire();\n    // Actual code...\n});\n\n// Signal the thread to run\nsignal.release();\n}\n\n{\n// Example of how this would look with a condition variable:\nstd::mutex mux;\nstd::condition_variable cond;\nbool received = false;\n\nauto t = std::jthread([&mux, &cond, &received]() {\n    // Wait until this thread is signaled\n    std::unique_lock lock(mux);\n    cond.wait(lock, [&received]{ return received; });\n    // Actual code...\n});\n\n{ // Signal the thread to run\n    std::unique_lock lock(mux);\n    received = true;\n}\ncond.notify_one();\n}"
        }
      ],
      "id": "oOKin9x4",
      "createdAt": 1711973722265,
      "updatedAt": 1711973728689
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::priority_queue",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::priority_queue is a container adapter implementing an ordered queue, i.e. a queue in which the largest element is always on the top and extracted first.\n\nThe behaviour is similar to manually managing a heap using heap algorithms, with a more convenient interface. However, with the caveat that the elements can only be copied from the queue, not moved out.\n\n#include <queue>\n#include <iostream>\n#include <iomanip>\n\n\nstd::priority_queue<int> queue;\n// push() is a O(logn) operation\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\nqueue.push(4);\n\n// Prints: 4 3 2 1\nwhile (!queue.empty()) {\n    // top() is O(1)\n    std::cout << queue.top() << \" \";\n    // pop() is O(logn)\n    queue.pop();\n}\nstd::cout << \"\\n\";\n\n// Example with custom comparator:\nstd::priority_queue<\n    // Element type\n    std::string,\n    // Underlying container to use\n    std::vector<std::string>,\n    // Custom comparator\n    decltype([](const auto& left, const auto& right) {\n        return left.length() > right.length();\n    })> custom;\n\ncustom.push(\"a\");\ncustom.push(\"aa\");\ncustom.push(\"aaa\");\n\n// Prints \"a\" \"aa\" \"aaa\"\nwhile (!custom.empty()) {\n    std::cout << std::quoted(custom.top()) << \" \";\n    custom.pop();\n}\nstd::cout << \"\\n\";"
        }
      ],
      "id": "I-pxDvpo",
      "createdAt": 1711973747288,
      "updatedAt": 1711973753566
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::source_location",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Before C++20, obtaining information about the source code location (line, file, function) required reliance on (sometimes non-portable) macros.\n\nThe std::source_location is a small C++20 utility that encapsulates source code location information in a C++ class. Note that the returned values are still implementation-defined.\n\n#include <source_location>\n#include <string>\n#include <iostream>\n\nvoid logger(std::string message,\n// Tip: to capture source location at caller site, \n//      use default argument:\n    std::source_location caller = std::source_location::current()) {\n    std::clog << \"[\" << caller.file_name()  // Filename\n        << \":\" << caller.line()             // Line number\n        << \"/\" << caller.column()           // Column number\n        << \"] \" << caller.function_name()   // Function name\n        << \" \\\"\" << message << \"\\\"\\n\";\n}\n\nint main(int, char*[]) {\n    logger(\"hello\");\n    // [/app/example.cpp:15/11] int main(int, char**) \"hello\"\n\n    [](){ logger(\"lambda\"); }();\n    // [/app/example.cpp:18/17] main(int, char**)::<lambda()> \"lambda\"\n\n    struct X {\n        X() { logger(\"constructor\"); }\n        ~X() { logger(\"destructor\"); }\n    } var;\n    // [/app/example.cpp:22/21] main(int, char**)::X::X() \"constructor\"\n    // [/app/example.cpp:23/22] main(int, char**)::X::~X() \"destructor\"\n}"
        }
      ],
      "id": "LgW9R2le",
      "createdAt": 1711973757775,
      "updatedAt": 1711973762346
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::invoke",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++17 std::invoke is a utility that can invoke any callable with the provided arguments. Note that this includes member functions and even members.\n\nIf we don’t need the type erasure properties of std::function or std::move_only_function, std::invoke can be a lower-level alternative (with the callable and arguments statically deduced).\n\n#include <functional>\n\n// Invoking typical callables (i.e. lambdas, functions...)\nauto zero_arg = [](){ return 42; };\nauto two_arg = [](int a, int b) { return a + b; };\n\nint a = std::invoke(zero_arg);\n// a == 42\nint b = std::invoke(two_arg, 98, 2);\n// b == 100\n\n\n// Demonstration of member invocation\nstruct X {\n    int value;\n    int get_value() { return value; }\n    int add(int extra) { return value + extra; }\n};\n\nX x{42};\n\nint c = std::invoke(&X::value, x);\n// c == 42\nint d = std::invoke(&X::get_value, x);\n// d == 42\nint e = std::invoke(&X::add, x, 42);\n// e == 84\n\n\n// Demonstration of using std::invoke as an alternative\n// to std::(move_only_)function.\n\n#include <format>\n\nint do_some_magic(int a, int b) { return a + b; }\n\n// Customizing code with a std::(move_only_)function.\nvoid operate(int a, int b, \n             std::move_only_function<void(std::string)> logger) {\n    int c = do_some_magic(a,b);\n    logger(std::format(\"Did some magic with {} and {},\"\n                       \" the result was {}.\", a, b, c));\n}\n\n// Statically customizing code with a callable.\nvoid operate_static(int a, int b, auto&& logger) {\n    int c = do_some_magic(a,b);\n    std::invoke(std::forward<decltype(logger)>(logger), \n        std::format(\"Did some magic with {} and {},\"\n                    \" the result was {}.\", a, b, c));\n}\n\n#include <iostream>\n\nauto logger1 = [](std::string line) { \n  std::cout << \"Logger1: \" << line << \"\\n\"; \n};\nauto logger2 = [](std::string line) {\n  std::cout << \"Logger2: \" << line << \"\\n\";\n};\n\n// Two different callables, type erased:\noperate(1,2,logger1);\noperate(1,2,logger2);\n\n// Two different callables, two generated functions:\noperate_static(1,2,logger1);\noperate_static(1,2,logger2);"
        }
      ],
      "id": "smaLBYB1",
      "createdAt": 1711973827140,
      "updatedAt": 1711973836919
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Lexicographical comparison with containers",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Standard C++ containers provide lexicographical comparison through the standard set of comparison operators (before C++20) and the three-way comparison operator (since C++20).\n\nThe support covers std::array, std::vector, std::deque, std::(forward_)list, std::string (and variants), std::(multi)set, std::(multi)map, std::stack and std::queue.\n\n#include <vector>\n#include <string>\n#include <cassert>\n \nstd::vector<int> data1{1, 3, 4, 5};\nstd::vector<int> data2{1, 3, 6, 7};\nstd::vector<int> data3{1, 3};\n\nassert(data1 < data2);\nassert(data3 < data1);\n\nstd::u8string str1 = u8\"😀😄😁\";\nstd::u8string str2 = u8\"😁😁😁\";\nstd::u8string str3 = u8\"😁\";\n\nassert(str1 < str2);\nassert(str3 < str2);"
        }
      ],
      "id": "CUFbciNM",
      "createdAt": 1711973847703,
      "updatedAt": 1711973859905
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::transform_inclusive_scan, std::transform_exclusive_scan",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::transform_inclusive_scan and std::transform_exclusive_scan compute the inclusive/exclusive prefix sum from the results of a transformation applied to each element.\n\nUnlike std::partial_sum, the prefix sum is generalized and not evaluated in strict order, requiring associative reduction operation for deterministic results.\n\n#include <numeric>\n#include <functional>\n#include <vector>\n\n\nstd::vector<int> data{1,1,1,1,1};\nstd::vector<int> out;\n\nstd::transform_inclusive_scan(\n    data.begin(), data.end(), // Input range\n    std::back_inserter(out), // Output iterator\n    std::plus<>{}, // Reduction operation\n    std::bind_front(std::multiplies<>{},2)); // Transformation op.\n// out == {2, 4, 6, 8, 10}\n\n\nout.clear();\nstd::transform_inclusive_scan(\n    data.begin(), data.end(), // Input range\n    std::back_inserter(out), // Output iterator\n    std::plus<>{}, // Reduction operation\n    std::bind_front(std::multiplies<>{},2), // Transformation op.\n    100); // Initial value\n// out == {102, 104, 106, 108, 110}\n\n\nout.clear();\nstd::transform_exclusive_scan(\n    data.begin(), data.end(), // Input range\n    std::back_inserter(out), // Output iterator\n    100, // Initial value (required)\n    std::plus<>{}, // Reduction operation\n    std::bind_front(std::multiplies<>{},2)); // Transformation op.\n// out == {100, 102, 104, 106, 108}"
        }
      ],
      "id": "bry8XEQp",
      "createdAt": 1711973877775,
      "updatedAt": 1711973890848
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::lexicographical_compare, std::lexicographical_compare_three_way",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "On top of the standard containers providing lexicographical comparison, the standard also provides two algorithms std::lexicographical_compare and std::lexicographical_compare_three_way (C++20) that can operate on any input range.\n\n#include <algorithm>\n#include <vector>\n\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6};\n\nauto cmp1 = std::lexicographical_compare(\n  data.begin(), std::next(data.begin(), 2), // {1, 2}\n  data.begin(), std::next(data.begin(), 3)  // {1, 2, 3}\n);\n// cmp1 == true, {1, 2} < {1, 2, 3}\n\nauto cmp2 = std::lexicographical_compare(\n  std::next(data.begin(), 1), std::next(data.begin(), 4), // {2, 3, 4}\n  data.begin(), std::next(data.begin(), 3) // {1, 2, 3}\n);\n// cmp2 == false, {2, 3, 4} >= {1, 2, 3}\n\nauto cmp3 = std::lexicographical_compare_three_way(\n  data.begin(), std::next(data.begin(), 2), // {1, 2}\n  data.begin(), std::next(data.begin(), 3)  // {1, 2, 3}\n);\n// std:is_lt(cmp3) == true, (cmp3 < 0) == true"
        }
      ],
      "id": "z-V-Fb4n",
      "createdAt": 1711973899885,
      "updatedAt": 1711973905195
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::filesystem: file manipulation",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Besides filesystem exploration, the std::filesystem offers the typical file manipulation operations.\n\nEach operation offers two variants, one throwing one that returns the potential error as an outparameter.\n\nThe following example relies on throwing versions of operations to minimize error handling.\n\n#include <filesystem>\n#include <fstream>\n#include <stdexcept>\n\nstd::filesystem::path file = \"current_file\";\n{\n    std::ofstream f(weakly_canonical(file));\n    f << \"Current content\\n\";\n}\n\n// Create a backup folder if it doesn't exist\nstd::filesystem::path backup_folder = \"./backup\";\nif (!exists(backup_folder)) create_directory(backup_folder);\n\n// Check if there is sufficient space\nif (space(backup_folder).available < file_size(file))\n    throw std::runtime_error(\"Not enough space for backup.\");\n\n// Construct a filename with a timestamp\nstd::filesystem::path backup_file = backup_folder / file.filename();\n{\n    using namespace std::chrono;\n    auto cnt =\n        duration_cast<seconds>(system_clock::now().time_since_epoch())\n            .count();\n    backup_file += std::to_string(cnt);\n}\n// Create a backup\ncopy(file, backup_file);\n\n// Create or update the symlink to the latest backup\nstd::filesystem::path symlink = file.parent_path() / \"current_backup\";\nif (exists(symlink)) remove(symlink);\ncreate_symlink(backup_file, symlink);\n\n/* Example result:\n\"./current_backup\" (\"./backup/current_file1662980474\")\n\"./current_file\"\n\"./backup\"\n\"./backup/current_file1662980474\"\n*/"
        }
      ],
      "id": "L5cQSid4",
      "createdAt": 1711973924097,
      "updatedAt": 1711973928179
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::stable_sort",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::stable_sort is a slower version of std::sort that additionally provides stability, i.e. equivalent elements maintain their relative positions.\n\nThis is important, notably for interactive cases when one range can be repeatedly sorted based on different aspects.\n\n#include <algorithm>\n#include <vector>\n\nstruct Data {\n    int a;\n    int b;\n    int c;\n};\n\nstd::vector<Data> data{\n    {0, 1, 1},\n    {0, 2, 1},\n    {1, 1, 2},\n    {1, 2, 2},\n    {2, 1, 3},\n    {2, 2, 3},\n};\n\n// Sort by b\nstd::ranges::stable_sort(data, {}, &Data::b);\n// Guaranteed order:\n// {{0,1,1},{1,1,2},{2,1,3},{0,2,1},{1,2,2},{2,2,3}}\n\n// Sort by c\nstd::ranges::stable_sort(data, {}, &Data::c);\n// Guaranteed order:\n// {{0,1,1},{0,2,1},{1,1,2},{1,2,2},{2,1,3},{2,2,3}}\n\nstd::vector<std::string> labels{\n   \"a\", \"aa\", \"aaa\", \"b\", \"bb\", \"bbb\", \n   \"c\", \"cc\", \"ccc\", \"d\", \"dd\", \"ddd\"\n};\n\nstd::ranges::stable_sort(labels, {}, [](const auto& l) {\n    return l.length();\n});\n// Guaranteed order:\n// \"a\", \"b\", \"c\", \"d\", \"aa\", \"bb\", \"cc\", \"dd\", \n// \"aaa\", \"bbb\", \"ccc\", \"ddd\""
        }
      ],
      "id": "3xOJcsnG",
      "createdAt": 1711973997687,
      "updatedAt": 1711974004684
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::lerp",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::lerp is a C++20 mathematical function that handles linear interpolation (and extrapolation) for floating-point types.\n\nThe function takes three arguments: the two boundary values and an interpolation factor. The implementation will correctly handle infinities and boundary values for the interpolation factor.\n\n#include <cmath>\n\n// interpolation factor [0, 1] will interpolate\nauto mid = std::lerp(1.0, 2.0, 0.5);\n// mid ~= 1.5\n\n// when factor == 0, returns first argument\nauto a = std::lerp(1.0, 2.0, 0);\n// a == 1.0, guaranteed\n\n// when factor == 1, returns second argument\nauto b = std::lerp(1.0, 2.0, 1.0);\n// b == 2.0, guaranteed\n\n// extrapolation\nauto extra = std::lerp(1.0, 2.0, 1.5);\n// extra ~= 2.5\n\n// integral values are converted to floating point\nauto v = std::lerp(1, 2, 2);\nstatic_assert(std::is_same_v<decltype(v), double>);\n// v ~= 3"
        }
      ],
      "id": "xWpoNZW5",
      "createdAt": 1711974005593,
      "updatedAt": 1711974017130
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::shared_future",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::shared_future is a C++11 synchronization tool suitable for one-shot single-producer/many-consumers situations.\n\nUnlike std::future, std::shared_future is copyable, allowing multiple instances of std::shared_future to refer to the same shared state.\n\nSimilar to std::future, std::shared_future<void> can be used for signalling.\n\n#include <future>\n#include <thread>\n#include <vector>\n\nstd::promise<int> provider;\n// Transfer the state from the promise generated future\n// to a shared future.\nstd::shared_future<int> future(provider.get_future());\n\nstd::vector<std::jthread> runners;\n\n// Start a new thread, taking a copy of the future.\nrunners.push_back(std::jthread([future](){\n    // Block until the promise is fulfilled.\n    int value = future.get();\n   // Process the result.\n}));\n\n// Start a new thread, taking a copy of the future.\nrunners.push_back(std::jthread([future](){\n // Block until the promise is fulfilled.\n    int value = future.get();\n   // Process the result.\n}));\n\n// Fulfill the promise\nprovider.set_value(42);"
        }
      ],
      "id": "FKexLml_",
      "createdAt": 1711974024090,
      "updatedAt": 1711974031858
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "C++ | C++20 mathematical constants",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Before C++20, using common mathematical constants relied on either POSIX or a compiler extension through the <math.h> header.\n\nC++20 introduced a new <numbers> header that provides common mathematical constants as templates that can be specialized for user types. The standard library provides float, double and long double specialisations with an alias for the double variant.\n\n#include <numbers>\n#include <cmath>\n\nstruct Fraction {\n    int numerator;\n    int denominator;\n};\n\nnamespace std::numbers {\n    template<> inline constexpr Fraction pi_v<Fraction> = {355, 113};\n}\n\nusing namespace std::numbers;\n\nauto custom_log2 = std::log(2.4)/ln2; // ln2 == ln2_v<double>\n\nauto custom_log10 = std::log(2.4)/ln10; // ln10 == ln10_v<double>\n\nauto circle = 2*pi; // pi == pi_v<double>\n\n// phi == phi_v<double>\nauto approx_fibonacci = [](int in) -> int { return phi*in+0.5; };\nint fib7 = approx_fibonacci(8);  // fib7 == 13\nint fib8 = approx_fibonacci(13); // fib8 == 21\n\n// specialized constant for Fraction user-type\nauto mypi = pi_v<Fraction>;\n// mypi == {355, 133}"
        }
      ],
      "id": "iPE5Ycsk",
      "createdAt": 1711974046390,
      "updatedAt": 1711974052747
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "iostreams error handling",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Despite recent developments (<format> and <print>), iostreams will be with us for the foreseeable future.\n\nOne of the quirks of iostreams is their approach to error handling, with errors represented using flags and error states.\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n// A stream that isn't associated with any file yet.\nstd::fstream f;\n// f.good() == true, (bool)f == true\n\n// Trying to write into a closed stream.\nf << 10;\n// f.good() == false, f.fail() == true, f.bad() == true\n// (f.rdstate() & std::ios_base::badbit) != 0\n\n// Badbit represents an irrecoverable error,\n// i.e. the stream is in a bad state.\n\n\n// Reset the stream by opening /dev/null.\n// Reading from /dev/null immediately leads to EOF\nf.open(\"/dev/null\");\n// f.good() == true\n\nf.peek(); // Don't even read, just peek at the next character.\n// f.good() == false, f.eof() == true\n// (f.rdstate() & std::ios_base::eofbit) != 0\n\n// Eofbit represents a stream that is at the end of file.\n\n\nstd::stringstream s(\"hello\");\n// Try to parse an integer from a string \n// that contains non-digit characters.\nint v;\ns >> v;\n// s.good() == false, s.fail() == true\n// (s.rdstate() & std::ios_base::failbit) != 0\n\n// Failbit represents recoverable errors, mostly parsing errors.\n\nstd::string txt;\n// A stream not in a good state will not proceed\n// with further insertion/extraction.\ns >> txt;\n// txt == \"\"\n\ns.clear(); // clear error bits\ns >> txt;\n// txt == \"hello\"\n\n\n// Exceptions can be opted into, however, \n// they do not contain useful information.\ntry {\n    // s is currently at eof, opting into exceptions \n    // will therefore throw immediately\n    s.exceptions(std::ifstream::eofbit); // the argument is a bitmask\n} catch(const std::exception& e) {\n    std::cout << e.what() << \"\\n\";\n   // basic_ios::clear: iostream error\n}"
        }
      ],
      "id": "CM1cRwwX",
      "createdAt": 1711974078813,
      "updatedAt": 1711974087805
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::reverse",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "If we want to iterate over the elements of a bidirectional range in reverse order, we do not have to mutate it.\n\nHowever, if we want to mutate the range, we can use the std::reverse algorithm.\n\nNote that std::list and std::forward_list provide a reverse method that reorders the nodes (instead of reversing the order of the values).\n\n#include <forward_list>\n#include <list>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> data{1,2,3,4,5};\nstd::reverse(data.begin(), data.end());\n// data == {5,4,3,2,1}\n\nstd::list<int> lst1{1,2,3,4,5};\nstd::forward_list<int> lst2{1,2,3,4,5};\nauto it1 = lst1.begin();\nauto it2 = lst2.begin();\n\n// Reverse method on list reverses nodes, instead of values\nlst1.reverse();\n// lst1 == {5,4,3,2,1}\n// it1 != lst1.begin(), *it1 == 1\nlst2.reverse();\n// lst2 == {5,4,3,2,1}\n// it2 != lst2.begin(), *it2 == 1\n\n// Only std::list models bidirectional range\nlst1 = {1,2,3,4,5};\nit1 = lst1.begin();\n\nstd::reverse(lst1.begin(), lst1.end());\n// lst1 == {5,4,3,2,1}\n// it1 == lst1.begin(), *it1 == 5"
        }
      ],
      "id": "OqebNOEl",
      "createdAt": 1711974174205,
      "updatedAt": 1711974179494
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::queue",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::queue is a container adapter that implements the interface of a FIFO queue.\n\nThe options for the backing containers are std::deque and std::list.\n\n#include <queue>\n\nstd::queue<int> q;\n// q.size() == 0, q.empty() == true\n\n// push a new element into the queue\nq.push(1);\n// q.front() == 1, q.back() == 1\n\n// pop an element from the front of the queue\nq.pop();\n\nq.push(2);\nq.push(3);\nq.push(4);\n\nwhile(not q.empty()) {\n    int v = q.front();\n    // iterate over 2, 3, 4\n    q.pop();\n}"
        }
      ],
      "id": "kEe5MMks",
      "createdAt": 1711974187562,
      "updatedAt": 1711974194490
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::search",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::search algorithm returns the first instance of a sub-sequence.\n\nThe C++17 variant supports both parallel execution and custom searchers. Custom searchers offer better average complexity (up to linear).\n\n#include <string>\n#include <algorithm>\n#include <functional>\n\nstd::string text = \"the quick brown fox jumps over the lazy dog\";\nstd::string needle = \"fox\";\n\n// Find the first instance of a sub-sequence in text\nauto it = std::search(text.begin(), text.end(), \n                      needle.begin(), needle.end());\n// it != text.end()\n\nstd::string_view word(it, it+needle.length());\n// word == \"fox\"\n\n// C++17 introduced searchers that offer better average complexity\nstd::boyer_moore_horspool_searcher searcher(\n  needle.begin(), needle.end());\n// Average linear complexity\nit = std::search(text.begin(), text.end(), searcher);\n// Same behaviour as default search\n// it != text.end()\nword = std::string_view(it, it+needle.length());\n// word == \"fox\"\n\n// Range version doesn't support searchers and returns a subrange\nauto [begin, end] = std::ranges::search(text, needle);\nword = std::string_view(begin,end);\n// word == \"fox\""
        }
      ],
      "id": "T8JkT-Ii",
      "createdAt": 1711974201156,
      "updatedAt": 1711974207401
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::iostream: custom manipulators",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When implementing stream insertion and extraction, it might be convenient to expose additional options that allow the class users to control how it is formatted or parsed.\n\nEach stream instance comes with an array of options (integers and pointers) that user-defined manipulators can use to store formatting information.\n\n#include <iostream>\n#include <cmath>\n#include <sstream>\n\nnamespace absolute {\n    // Obtain a unique index which can be used to address \n    // integer or pointer value inside of all streams.\n    static int flag = std::ios_base::xalloc();\n\n    // Stream manipulators:\n    struct on {\n        friend std::ostream& operator<<(std::ostream& s, const on&) {\n            // In the current stream, set the value of the integer\n            // at index stored in flag to one.\n            s.iword(flag) = 1;\n            return s;\n        }\n        friend std::istream& operator>>(std::istream& s, const on&) {\n            s.iword(flag) = 1;\n            return s;\n        }\n    };\n    struct off {\n        friend std::ostream& operator<<(std::ostream& s, const off&) {\n            // In the current stream, set the value of the integer\n            // at index stored in flag to zero.\n            s.iword(flag) = 0;\n            return s;\n        }\n        friend std::istream& operator>>(std::istream& s, const off&) {\n            s.iword(flag) = 0;\n            return s;\n        }\n    };\n}\n\n// Object with I/O that uses the above manipulators\nstruct MyInt {\n    int value;\n    friend std::ostream& operator<<(std::ostream& s, const MyInt& v) {\n        // Same as above, but only read the value\n        if (s.iword(absolute::flag))\n            return s << std::abs(v.value);\n        else\n            return s << v.value;\n    }\n    friend std::istream& operator>>(std::istream& s, MyInt& v) {\n        // Same logic for istream\n        if (s.iword(absolute::flag)) {\n            if (s >> v.value)\n                v.value = std::abs(v.value);\n            return s;\n        } else {\n            return s >> v.value;\n        }\n    }\n};\n\n\nstd::stringstream s(\"-9 -7 5 12\");\n\nMyInt x,y;\ns >> absolute::on{} >> x >> absolute::off{} >> y;\n// x.value == 9, y.value == -7\ns >> absolute::on{} >> x >> absolute::off{} >> y;\n// x.value == 5, y.value == 12\n\ns = std::stringstream{};\ns << absolute::on{} << x << \" \" << absolute::off{} << y << \" \";\nx.value = -9; y.value = -7;\ns << absolute::on{} << x << \" \" << absolute::off{} << y;\n// s.str() == \"5 12 9 -7\""
        }
      ],
      "id": "DMMwd8C8",
      "createdAt": 1711974232374,
      "updatedAt": 1711974240971
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::advance, std::distance",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When implementing generic code that should operate on top of ranges, the std::advance and std::distance utilities can help.\n\nBoth utilities provide constant complexity for random access ranges and fallback to linear operations.\n\n#include <vector>\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7};\nauto it = data.begin();\nstd::advance(it, 5);\n// *it == 6\n\n// For non-random-access ranges distance(a,b)\n// b needs to be reachable by incrementing a\nauto cnt = std::distance(data.begin(), it);\n// cnt == 5\n\n// For random access ranges distance(a,b)\n// either b reachable from a, or a reachable from b\ncnt = std::distance(it, data.begin()); \n// cnt == -5\n\n// Negative distance requires a bidirectional range.\nstd::advance(it, -2);\n// *it == 4"
        }
      ],
      "id": "U_ar4c7C",
      "createdAt": 1711974244181,
      "updatedAt": 1711974258692
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::string_view",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::string_view is a borrowed range that can reference any (not necessarily null-terminated) string, i.e. string literals, std::string and other character contiguous ranges.\n\nstd::string_view should be preferred over an immutable std::string, except for cases when ownership is also required, as std::string_view can only reference data owned by other ranges.\n\n#include <string>\n#include <iostream>\n#include <vector>\n\n// String literals have static storage duration,\n// therefore string_view of string literal is always valid.\nstd::string_view str1=\"The quick brown fox jumps over the lazy dog\";\n// str1 == \"The quick brown fox jumps over the lazy dog\"\n\n// Otherwise as with any other borrowed range, the string_view \n// should not outlive the range it is borrowing from.\nstd::string_view view;\n{\n    std::string owned=\"The quick brown fox jumps over the lazy dog\";\n    view = owned;\n    // view is valid here\n} // owned destroyed\n// view invalid\n\n// Importantly, string_views are not necessarily null terminated\nchar s1[3] = {'t', 'h', 'e'};\nstd::string_view str2(s1, s1+3); // OK\n// str2 == \"the\"\n\nstd::cout << str2 << \"\\n\"; // OK\n// std::cout << str2.data() << \"\\n\"; // NOT OK, not null-terminated\n\nstd::vector<char> s2{'a','b','c'};\n// Can be constructed from any contiguous range of characters\nstd::string_view str3(s2.begin(), s2.end());\n// str3 == \"abc\"\n\n// Sub-string views are easy to create\nstr1.remove_prefix(4);\n// str1 == \"quick brown fox jumps over the lazy dog\"\n\nstr1.remove_suffix(4);\n// str1 == \"quick brown fox jumps over the lazy\"\n\nstd::string_view str4 = str1.substr(6,15);\n// str4 == \"brown fox jumps\""
        }
      ],
      "id": "BOOjGK6y",
      "createdAt": 1711974281380,
      "updatedAt": 1711974287039
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Conditional explicit",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Since C++20, the explicit specifier can be conditional. This allows for generic code that permits implicit conversions in safe cases.\n\nIn this example, the wrapper for integral types permits implicit conversion only when the destination type can represent the full range of the source type.\n\n#include <concepts>\n\ntemplate<std::integral Src, std::integral Dst>\nconstexpr bool is_safe_conversion =\n// Signed -> Signed where sizeof(Src) <= sizeof(Dst)\n    (std::is_signed_v<Src> && std::is_signed_v<Dst> && \n     sizeof(Src) <= sizeof(Dst)) ||\n// Unsigned -> Unsigned where sizeof(Src) <= sizeof(Dst)\n    (std::is_unsigned_v<Src> && std::is_unsigned_v<Dst> && \n     sizeof(Src) <= sizeof(Dst)) ||\n// Unsigned -> Signed where sizeof(Src) < sizeof(Dst)\n    (std::is_unsigned_v<Src> && std::is_signed_v<Dst> && \n     sizeof(Src) < sizeof(Dst));\n\ntemplate <std::integral T>\nstruct SafeIntegral {\n    constexpr SafeIntegral() : val_{} {}\n    constexpr SafeIntegral(T src) : val_(src) {}\n\n//  Either conversion operator, or conversion constructor\n/*\n    template<std::integral Dst>\n    constexpr explicit(!is_safe_conversion<T, Dst>) \n    operator SafeIntegral<Dst>() const { return val_; }\n*/\n    template <std::integral Src>\n    constexpr explicit(!is_safe_conversion<Src, T>)\n    SafeIntegral(SafeIntegral<Src> src) : val_(src.val_) {}\n\n    T val_;\n};\n\nint main() {\n    SafeIntegral a{2}; // SafeIntegral<int>\n    SafeIntegral b{2u}; // SafeIntegral<unsigned>\n    // a = b; // Will not compile, unsafe conversion\n    a = SafeIntegral<int>{b}; // OK explicit conversion\n    \n    SafeIntegral<long> c = b; // OK\n    // assuming sizeof(long) > sizeof(unsigned)\n    c = a; // OK\n}"
        }
      ],
      "id": "Q7pqW9Za",
      "createdAt": 1711974328471,
      "updatedAt": 1711974341019
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "<iosfwd>",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Including the <iostream> header can significantly impact compile time, as it is one of the heavy standard C++ headers.\n\nAs an alternative, notably for library headers, the <iosfwd> header provides only forward declaration, making it essentially free.\n\nAs long as we only need to declare stream insertion and extraction functions, the <iosfwd> header is sufficient.\n\n// Sufficient for declarations\n#include <iosfwd>\n\nstruct X {\n    // Declare stream insertion\n    friend std::ostream& operator<<(std::ostream&, const X&);\n    // Declare stream extraction\n    friend std::istream& operator>>(std::istream&, X&);\n    int x;\n};\n\n// Required for definitions\n#include <iostream>\n\n// Implement stream insertion\nstd::ostream& operator<<(std::ostream& s, const X& x) {\n    return s << x.x;\n}\n// Implement stream extraction\nstd::istream& operator>>(std::istream& s, X& x) {\n    return s >> x.x;\n}"
        }
      ],
      "id": "yYm1bSVm",
      "createdAt": 1711974350898,
      "updatedAt": 1711974359531
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::stoi, std::stol, std::stoll, std::stoul, std::stoul, std::stof, std::stod, std::stold",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++11 added functions for converting std::string into integer and floating point types.\n\nSigned integers: std::stoi, std::stol, std::stoll.\n\nUnsigned integers: std::stoul, std::stoull.\n\nFloating point types: std::stof, std::stod, std::stold.\n\nFor std::string_view or string literals, prefer the std::from_chars function (to an excessive std::string temporary).\n\n#include <string>\n\n// Normal use:\nstd::string negative = \"-200\";\nauto v1 = stoi(negative);\n// decltype(v1) == int, v1 == -200\n\nauto v2 = stol(negative);\n// decltype(v2) == long, v2 == -200\n\nauto v3 = stoll(negative);\n// decltype(v3) == long long, v3 == -200\n\nstd::string positive = \"42\";\nauto v4 = std::stoul(positive);\n// decltype(v4) == unsigned long, v4 == 42\n\nauto v5 = std::stoull(positive);\n// decltype(v5) == unsigned long long, v5 == 42\n\nstd::string pi = \"3.14\";\nauto v6 = std::stof(pi);\n// decltype(v6) == float, v6 ~= 3.14\n\nauto v7 = std::stod(pi);\n// decltype(v7) == double, v7 ~= 3.14\n\nauto v8 = std::stold(pi);\n// decltype(v8) == long double, v8 ~= 3.14\n\n// Optional, length of parsed text, and base for integer types:\nstd::string complex = \"  169AQ\";\nsize_t offset = 0;\nauto v9 = std::stol(complex, &offset, 10);\n// v9 == 169, decltype(v9) == long\n// std::string_view(complex.begin()+offset, complex.end()) == \"AQ\"\n\noffset = 0;\nauto v10 = std::stol(complex, &offset, 16);\n// v10 == 5786 (0x169A), decltype(v10) == long\n// std::string_view(complex.begin()+offset, complex.end()) == \"Q\"\n\n// Note that these functions require std::string, not std::string_view.\n// For that, prefer std::from_chars."
        }
      ],
      "id": "38lpHOp6",
      "createdAt": 1711974399872,
      "updatedAt": 1711974408368
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::to_address",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::to_address is a simple C++20 utility that provides uniform access to the address from raw and smart pointers (and pointer-like objects) without the need to access the underlying value.\n\nBefore this utility was introduced, the most uniform way to obtain the address was using std::addressof(*p), which requires p to point to a valid object.\n\n#include <memory>\n#include <vector>\n\nauto t1 = std::make_unique<int>(1);\nint *p1 = std::to_address(t1);\n// p1 == t1.get()\n\nstd::unique_ptr<int> t2; // empty smart pointer\nint *p2 = std::to_address(t2);\n// p2 == nullptr\n\nint x = 0, *t3 = &x;\nint *p3 = std::to_address(t3);\n// t3 == p3\n\n// Also works for contiguous iterators\nstd::vector<int> rng{1,2,3};\nint *p4 = std::to_address(rng.begin());\n// p4 == rng.data()"
        }
      ],
      "id": "Ad0UVfBZ",
      "createdAt": 1711974429804,
      "updatedAt": 1711974436014
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::not_fn",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::not_fn is a C++17 utility from the functional header that creates a simple forwarding call wrapper that returns the negation of the wrapped callable.\n\n#include <algorithm>\n#include <vector>\n#include <functional>\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6};\nauto is_even = [](int v) { return v % 2 == 0; };\n\nstd::vector<int> out1;\nstd::copy_if(data.begin(), data.end(),\n    std::back_inserter(out1),\n    is_even);\n// out1 == {2, 4, 6}\n\nstd::vector<int> out2;\nstd::copy_if(data.begin(), data.end(),\n    std::back_inserter(out2), \n    std::not_fn(is_even));\n// out2 == {1, 3, 5}\n// Note: same as std::remove_copy_if with is_even"
        }
      ],
      "id": "tyve-PLr",
      "createdAt": 1711974449434,
      "updatedAt": 1711974468903
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Overload selection: functions vs. function templates",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The function overload selection rules are complex enough to justify a book. Very roughly:\n\n    construct the set of viable functions (following lookup rules and deducing arguments for function templates)\n    the best viable function minimizes implicit conversions first and then prefers concrete functions over templates\n    templates are ordered by how *concrete* they are\n\n#include <string>\n\ntemplate <typename T> void f1(T) {}\ntemplate <> void f1(const char*) {}\nvoid f1(int) {}\nvoid f1(std::string) {}\n\ntemplate <typename T> void f2(T, T) {}\ntemplate <typename T, typename U> void f2(T, U) {}\nvoid f2(int, double) {}\n\n\nusing namespace std::literals;\n// 1. minimize conversions\n// 2. prefer concrete function over templates\n// 3. prefer more concrete templates over less concrete templates\n\nf1(0); // f1(int) and f1<>(int) are viable\n       // f1(int) preferred because it is not a template\n\nf1(0.0); // f1(int) and f1<>(double) are viable\n         // f1<>(double) preferred because it doesn't involve \n         //              an implicit conversion\n\nf1(\"hello\");  // f1(std::string) and f1<>(const char*) are viable\n              // f1<>(const char*) preffered because it doesn't involve\n              //                   an implicit conversion\n\n              // Because there is specialization matching the template\n              // arguments, it is used instead of the base template.\n              // Note that this happens only if the base template \n              // is the best viable candidate.\n\nf1(\"hello\"s); // only f1(std::string) is viable\n\nf2(0,0.0); // f2(int,double), f2<>(int,double) viable\n           // f2(int,double) preferred\n           // Note: f2<>(T,T) can't be instantiated\n\nf2(0,0); // f2(int,double), f2<>(T,T), f2<>(T,U) viable\n         // f2<>(T,T) and f2<>(T,U) are prefered (no conversions),\n         // but f2<>(T,T) is ordered before f2<>(T,U) \n         // as it is a more specific template"
        }
      ],
      "id": "TPTl7boT",
      "createdAt": 1711974578099,
      "updatedAt": 1711974584819
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::counted_iterator",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Only a few algorithms in the standard library offer counted variants that operate using a begin iterator and the number of elements.\n\nC++20 introduced the std::counted_iterator adapter that can turn any range version of an algorithm into a counted variant.\n\n#include <algorithm>\n#include <vector>\n#include <iterator>\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\n\nstd::vector<int> out1;\n// A counted variant of std::copy.\nstd::copy_n(data.begin(), 5, std::back_inserter(out1));\n// out1 == {1, 2, 3, 4, 5}\n\nstd::vector<int> out2;\nstd::ranges::copy(\n    // Adapt iterator, and specify number of elements.\n    std::counted_iterator(data.begin(), 5), \n    // counted_iterator == default_sentinel if count is zero\n    std::default_sentinel,\n    std::back_inserter(out2));\n// out2 == {1, 2, 3, 4, 5}"
        }
      ],
      "id": "5GHeO5e7",
      "createdAt": 1711974798603,
      "updatedAt": 1711974803991
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::chunk_by",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::views::chunk_by is a view similar to C++20 std::views::split; however, unlike split, it operates using a binary predicate.\n\nA new chunk will be started between the two tested elements when the predicate returns false.\n\n#include <ranges>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> data{1,2,-4,-2,-1,8,7,3,4,-5,-5};\n\nauto same_sign = [](int left, int right){\n    return std::signbit(left) == std::signbit(right);\n};\n\nfor (const auto& chunk : data | std::views::chunk_by(same_sign)) {\n    // Iterate over chunks:\n    // {1,2}, {-4,-2,-1}, {8,7,3,4}, {-5,-5}\n}"
        }
      ],
      "id": "V65EhH93",
      "createdAt": 1711974836676,
      "updatedAt": 1711974841139
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "User-defined literals",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++11 introduced user-defined literals, allowing libraries to expose strongly typed unit value types in a natural and readable way.\n\nNote that the only permitted base types for user-defined literals are unsigned long long int, long double, char types and string literal types.\n\n#include <iostream>\n\nnamespace units {\n    struct m {\n        unsigned long long int value;\n        friend auto operator<=>(const m&, const m&) = default;\n    };\n    struct km {\n        unsigned long long int value;\n        operator m() const { return {value*1000}; }\n        friend auto operator<=>(const km&, const km&) = default;\n    };\n}\n\nconstexpr units::km operator\"\" _km(unsigned long long int v) { \n  return {v}; \n}\nconstexpr units::m operator\"\" _m(unsigned long long int v) {\n  return {v}; \n}\n\nint main() {\n    if (100_m < 1_km) {\n        std::cout << \"100m is less than 1km\\n\";\n    }\n    if (1001_m > 1_km) {\n        std::cout << \"1001m is more than 1km\\n\";\n    }\n}"
        }
      ],
      "id": "rk7x9pZx",
      "createdAt": 1711974847797,
      "updatedAt": 1711974851980
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::partial_sort_copy",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Most sort algorithms in the standard library require the source range to be a random access range.\n\nHowever, the std::partial_sort_copy algorithm stands out from the pack as it can operate on input ranges.\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n\nstd::vector<int> top_five(5);\n\nstd::partial_sort_copy(\n    // iterate over integers on standard input until reaching EOF\n    std::istream_iterator<int>(std::cin), std::istream_iterator<int>{},\n    // destination range is still required to be a random access\n    top_five.begin(), top_five.end(),\n    // default order is non-descending; make it non-ascending\n    std::greater<int>{});\n\n// For standard input: 9 1 3 4 2 7 8 6 5\n// top_five == {9, 8, 7, 6, 5}"
        }
      ],
      "id": "AueWt1BG",
      "createdAt": 1711974856396,
      "updatedAt": 1711974861112
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Legacy resources with std::unique_ptr",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "A typical pattern with legacy APIs is for the initializing function to return an opaque pointer that needs to be freed by manually calling a cleanup function.\n\nstd::unique_ptr can serve as a helper here, as it accepts custom deleters. Unfortunately, the interface is not ergonomic, which we can fix by introducing a short helper.\n\n#include <memory>\n#include <cstdio>\n\ntemplate <typename P, typename D>\nauto wrap_unique(P* pointer, D&& deleter) {\n    return std::unique_ptr<P, D>{\n        pointer,\n        std::forward<D>(deleter)\n    };\n}\n\nint main() {\n    auto file = wrap_unique(\n        fopen(\"/dev/null\", \"r\"),\n        [](std::FILE* fp) noexcept {\n            fclose(fp);\n        });\n    // file will autoclose when going out of scope\n}"
        }
      ],
      "id": "69g7joUQ",
      "createdAt": 1711974867117,
      "updatedAt": 1711974871754
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::stride",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::views::stride is a view that contains every n-th element from the source view.\n\nThis is useful when we want to represent column-order traversal using views.\n\n#include <iostream>\n#include <ranges>\n#include <vector>\n#include <string_view>\nusing namespace std::literals;\n\nauto text = \"Hello   World!\"sv;\n\n// Iterate over every second element:\nfor (auto c : text | std::views::stride(2))\n    std::cout << c << \" \";\nstd::cout << \"\\n\";\n\n// Same but shifted by one by dropping the first element:\nfor (auto c : text | std::views::drop(1) | std::views::stride(2))\n    std::cout << \" \" << c;\nstd::cout << \"\\n\";\n/* Prints:\nH l o   W r d \n e l     o l !\n*/\n\n\nstd::vector<int> data{1,2,3,4,5,6,7,8,9};\n\n// Treat data as a 3x3 2D array and do column-order traversal:\nfor (auto column : std::views::iota(0,3)) {\n    for (auto e : data | \n         std::views::drop(column) | std::views::stride(3))\n        std::cout << e << \" \";\n    std::cout << \"\\n\";\n}\n/* Prints:\n1 4 7\n2 5 8\n3 6 9\n*/"
        }
      ],
      "id": "i2WUFR61",
      "createdAt": 1711974876365,
      "updatedAt": 1711974881089
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::cartesian_product",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::views::cartesian_product is a view representing the n-ary cartesian product of the content of the views passed in as arguments.\n\nOne of the use cases of std::views::cartesian_product is replacing standard nested for loops.\n\n#include <ranges>\n#include <vector>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nauto dir = {-1,0,1};\nPoint p{5,5};\n\n// Cartesian product representing the 3x3 grid around a center point.\nfor (auto [x,y] : std::views::cartesian_product(dir,dir)) {\n    // Iterate over:\n    // {4,4}, {4,5}, {4,6}, {5,4}, {5,5}, {5,6}, {6,4}, {6,5}, {6,6}\n}\n\n// Same but filter out diagonals and center point.\nfor (auto [x,y] : std::views::cartesian_product(dir,dir) | \n    std::views::filter([](const auto& v) {\n        return std::abs(std::get<0>(v)) != std::abs(std::get<1>(v));\n    })) {\n    // Iterate over: {4,5}, {5,4}, {5,6}, {6,5}\n}\n\nstd::vector<char> a{'1','2'}, b{'a','b'}, c{'&','$'};\nfor (auto [i,j,k] : std::views::cartesian_product(a,b,c)) {\n    // Iterate over:\n    // 1a&, 1a$, 1b&, 1b$, 2a&, 2a$, 2b&, 2b$\n}"
        }
      ],
      "id": "J2l6fHWo",
      "createdAt": 1711974885060,
      "updatedAt": 1711974892067
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::repeat",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::view::repeat can represent finite and infinite views of a single repeated value.\n\n#include <ranges>\n#include <iostream>\n\n// Repeated view of the value 42, since we take the first 7 elements\n// only, the compound result is 7 instances of the value 42.\nfor (auto v : std::views::repeat(42) | std::views::take(7)) {\n    std::cout << v << \"\\n\";\n}\n\nstd::cout << \"\\n\";\n\n// Repeated view itself supports a positive bound, turning it into \n// a counted view.\n\n// Same behaviour as above.\nfor (auto v : std::views::repeat(42, 7)) {\n    std::cout << v << \"\\n\";\n}"
        }
      ],
      "id": "bnqgvskg",
      "createdAt": 1711974898637,
      "updatedAt": 1711974904637
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::spanstream",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 added the std::spanstream, effectively a std::stringstream equivalent operating on a borrowed contiguous range.\n\nstd::spanstream can be used to directly parse text stored in raw memory, string views or string literals.\n\nWhen using std::spanstream for writing, the std::spanstream will write as much output as fits into the output span, which can be inconvenient.\n\n#include <spanstream>\n#include <vector>\n\n// Works as a stringstream, but with a borrowed underlying range\n\n// Parsing of text data in buffers, string_views, string literals\nchar buffer[] = \"10 20 30\";\nstd::spanstream stream(buffer);\nint a, b, c;\nstream >> a >> b >> c;\n// a == 10, b == 20, c == 30, stream.good() == true\n\n// Also works for output\nstd::vector<char> data(1024*8,'\\0');\nstd::spanstream out(data);\nout << 10 << \" \" << 20 << \" \" << 30;\n// data == \"10 20 30\" (followed by nul characters)\n\n// However note that handling write errors is cumbersome\nstd::vector<char> limited(8, '\\0');\nstd::spanstream sstr(limited);\nsstr << 1000 << \" \";\n\nauto pos = sstr.tellp(); // remember the offset\nsstr << 1000; // this fails (not enough space)\n// data = \"1000 100\"\nif (!sstr.good()) {\n    sstr.clear(); // clear the error flags\n    sstr.seekp(pos); // seek back\n}\nwhile (sstr << 'X'); // fill the rest of the buffer with 'X'\n// data == \"1000 XXX\""
        }
      ],
      "id": "zW-soU1W",
      "createdAt": 1711974911775,
      "updatedAt": 1711974916193
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::spanstream",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 added the std::spanstream, effectively a std::stringstream equivalent operating on a borrowed contiguous range.\n\nstd::spanstream can be used to directly parse text stored in raw memory, string views or string literals.\n\nWhen using std::spanstream for writing, the std::spanstream will write as much output as fits into the output span, which can be inconvenient.\n\n#include <spanstream>\n#include <vector>\n\n// Works as a stringstream, but with a borrowed underlying range\n\n// Parsing of text data in buffers, string_views, string literals\nchar buffer[] = \"10 20 30\";\nstd::spanstream stream(buffer);\nint a, b, c;\nstream >> a >> b >> c;\n// a == 10, b == 20, c == 30, stream.good() == true\n\n// Also works for output\nstd::vector<char> data(1024*8,'\\0');\nstd::spanstream out(data);\nout << 10 << \" \" << 20 << \" \" << 30;\n// data == \"10 20 30\" (followed by nul characters)\n\n// However note that handling write errors is cumbersome\nstd::vector<char> limited(8, '\\0');\nstd::spanstream sstr(limited);\nsstr << 1000 << \" \";\n\nauto pos = sstr.tellp(); // remember the offset\nsstr << 1000; // this fails (not enough space)\n// data = \"1000 100\"\nif (!sstr.good()) {\n    sstr.clear(); // clear the error flags\n    sstr.seekp(pos); // seek back\n}\nwhile (sstr << 'X'); // fill the rest of the buffer with 'X'\n// data == \"1000 XXX\""
        }
      ],
      "id": "4wZh3IyC",
      "createdAt": 1711974921787,
      "updatedAt": 1711974930513
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::chrono — time zones Šimon Tóth  Šimon Tóth ·",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Besides introducing support for dates, the C++20 standard also extended the std::chrono library with support for time zones.\n\nWhen working with dates and time, we can distinguish between sys and local time, where sys time is always UTC and local time is local to a timezone. Combining local time with a timezone then produces a zoned time.\n\n#include <chrono>\n#include <iostream>\n\nusing namespace std::chrono;\n\nstd::cout << \"USA switching to summer time on \"\n    << year_month_day{2023y/March/Sunday[2]} << \"\\n\";\nstd::cout << \"Europe switching to summer time on \"\n    << year_month_day{2023y/March/Sunday[last]} << \"\\n\\n\";\n/* Will print\nUSA switching to summer time on 2023-03-12\nEurope switching to summer time on 2023-03-26\n*/\n\nstd::cout << \"Weekly meeting Wednesday 15:00 \" \n  << \"Europe/Prague time zone.\\n\";\nauto prague = locate_zone(\"Europe/Prague\");\nauto newyork = locate_zone(\"America/New_York\");\n\nauto day = year_month_day{2023y/March/Wednesday[1]};\n// first Wednesday in March 2023\nfor (int i = 1; i <= 6; i++) {\n    // create zoned time for Prague\n    zoned_time<seconds> local { prague, local_days{day} + 15h };\n    zoned_time<seconds> remote { newyork, local };\n    // convert Prague time to corresponding New York time\n\n    std::cout << i << \". \\n\";\n    std::cout << \"\\tPrague: \" << local << \"\\n\";\n    std::cout << \"\\tNew York: \" << remote << \"\\n\";\n\n    // When manipulating dates, stay with day precision\n    day = sys_days{day} + weeks{1};\n}\n/* Will print (note the CET->CEST and EST->EDT changes):\nWeekly meeting Wednesday 15:00 Europe/Prague time zone.\n1. \n Prague: 2023-03-01 15:00:00 CET\n New York: 2023-03-01 09:00:00 EST\n2. \n Prague: 2023-03-08 15:00:00 CET\n New York: 2023-03-08 09:00:00 EST\n3. \n Prague: 2023-03-15 15:00:00 CET\n New York: 2023-03-15 10:00:00 EDT\n4. \n Prague: 2023-03-22 15:00:00 CET\n New York: 2023-03-22 10:00:00 EDT\n5. \n Prague: 2023-03-29 15:00:00 CEST\n New York: 2023-03-29 09:00:00 EDT\n6. \n Prague: 2023-04-05 15:00:00 CEST\n New York: 2023-04-05 09:00:00 EDT\n*/"
        }
      ],
      "id": "0IezdDS_",
      "createdAt": 1711974934631,
      "updatedAt": 1711974940681
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::chrono — working with pseudo-dates",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When working with dates, it is often convenient to refer to pseudo-dates, such as the last day in March or the second Friday in April.\n\nThe C++20 extension to std::chrono which introduced date manipulation also added support for these constructs.\n\n#include <chrono>\n#include <iostream>\n\nusing namespace std::chrono;\n\n// Last day for February 2020\nauto leap_day = 2020y/February/last;\n// decltype(leap_day) == std::chrono::year_month_day_last\n\n// To get the actual date, we need to convert to year_month_day\nyear_month_day actual_leap_day{leap_day};\n// actual == 2020/02/29\n\n// Last Sunday of 2022\nauto last_sunday = 2022y/December/Sunday[last];\n// decltype(last_sunday) == std::chrono::year_month_weekday_last\n\n// To get the actual date, we need to convert to year_month_day\nyear_month_day actual_sunday{last_sunday};\n// actual_sunday == 2022/12/25\n\n// US Thanksgiving date, 4th Thursday in November\nauto thanksgiving = November/Thursday[4];\n// decltype(thanksgiving) == std::chrono::month_weekday\nfor (auto year = 2022y; year < 2027y; year++) {\n    year_month_day date{thanksgiving/year}; \n    /* Iterate over:\n    2022-11-24\n    2023-11-23\n    2024-11-28\n    2025-11-27\n    2026-11-26\n    */\n}"
        }
      ],
      "id": "4Ka09IEi",
      "createdAt": 1711974946760,
      "updatedAt": 1711974952023
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::chrono — date manipulation",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced a large extension to the std::chrono library that added (among other things) full support for date representation and manipulation.\n\n#include <chrono>\n\nusing namespace std::chrono;\n\n// Day in a year can be specified using literals and operator/\nauto christmas_eve = 2023y/December/24d;\n// decltype(christmas_eve) == std::chrono::year_moth_day\n\nauto day = weekday{sys_days{christmas_eve}};\n// day == Sunday\n\nfor (auto date = 2023y/April/1d;\n    date.month() == April;\n    date = sys_days{date} + days{1}) {\n    // iterate over all days in April 2023\n}\n\nOpen the example in Compiler Explorer."
        }
      ],
      "id": "HZbi5Yo5",
      "createdAt": 1711974955771,
      "updatedAt": 1711974960537
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::chrono — time",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::chrono library added in C++11 enables simple time measurement.\n\nThe library provides two types for storing time information: time points and durations.\n\nBesides expected operations, the library provides convenience features such as pretty printing (C++20) and time literals (C++14).\n\n#include <chrono>\n#include <iostream>\n#include <thread> // sleep_for\n\nusing namespace std::literals;  \n\nauto tp1 = std::chrono::steady_clock::now(); // obtain a time point\nstd::this_thread::sleep_for(1ms); // millisecond literal\nauto tp2 = std::chrono::steady_clock::now();\n// base type and precision depend on the type of clock\n\n// The standard offers three clocks:\n// std::chrono::system_clock, std::chrono::steady_clock,\n// std::chrono::high_resolution_clock\n\n// Whether a clock is steady and its resolution can be queried using:\nbool system_is_steady = std::chrono::system_clock::is_steady;\nauto resolution = std::chrono::system_clock::duration{1};\n\nauto duration = tp2 - tp1; // difference of time points is a duration\nstd::cout << duration << \"\\n\";\n// example output: 1115389ns\n\n// explicit type of duration, base type double, with micro precision\nstd::chrono::duration<double, std::micro> fpdur = tp2 - tp1;\nstd::cout << fpdur << \"\\n\";\n// example output: 1115.39µs\n\n// duractions can be converted between each other using duration_cast\nauto micro = std::chrono::duration_cast<\n  std::chrono::microseconds>(tp2 - tp1);\nstd::cout << micro << \"\\n\";\n// example output: 1115µs"
        }
      ],
      "id": "0nBMKwfg",
      "createdAt": 1711974964069,
      "updatedAt": 1711974977414
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::copy_if, std::remove_copy_if",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "If we need selectively copy elements from one range to another, the standard offers the std::copy_if and std::remove_copy_if algorithms.\n\nBoth algorithms accept a predicate, copying elements for which the predicate returns true and false respectively.\n\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8};\n\nstd::vector<int> dst1;\nstd::copy_if(data.begin(), data.end(), // all elements\n    std::back_inserter(dst1), // push_back elements into dst1\n    [](int v) { return v % 2 == 0; }); // condition\n// dst1 == {2, 4, 6, 8}\n\nstd::vector<int> dst2;\nstd::remove_copy_if(data.begin(), data.end(), // all elements\n    std::back_inserter(dst2), // push_back elements into dst2\n    [](int v) { return v % 2 == 0; }); // negative condition\n// dst2 == {1, 3, 5, 7}"
        }
      ],
      "id": "mtS34H9P",
      "createdAt": 1711974985200,
      "updatedAt": 1711974989300
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Ref-qualified methods",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "With the introduction of r-value references, the C++11 standard also added ref-qualifiers for methods. This allows us to distinguish between situations when a method is invoked on an l-value and r-value object.\n\nIf you dislike the resulting code duplication, look for the “deducing this” feature in C++23.\n\nstruct MyClass {\n    // mutable l-value\n    void operation() & { }\n    // prvalue or xvalue\n    void operation() && { }\n    // const l-value\n    void operation() const& { }\n};\n\nconst MyClass a;\na.operation();\n// const l-value\n\nMyClass b;\nb.operation();\n// mutable l-value\n\nMyClass{}.operation();\n// prvalue\n\nstd::move(b).operation();\n// xvalue"
        }
      ],
      "id": "px1CI0B0",
      "createdAt": 1711974993499,
      "updatedAt": 1711974999939
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::transform_reduce",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The transform-reduce is a common operation in distributed systems. C++17 added support for a namesake algorithm that offers the transform-reduce pattern for ranges.\n\nThe algorithm requires a commutative and associative reduction but offers single and two-range variants and parallel overloads.\n\n#include <numeric>\n#include <vector>\n#include <execution>\n\nstd::vector<double> values{2.3, 9.1, 4.7, 7.1, 1.9, 5.2};\nstd::vector<double> predictions{1.0, 2.0, 3.0, 4.0, 5.0, 6.0};\n\n// Calculate the mean square error:\nauto mse = std::transform_reduce(\n    values.begin(), values.end(), // all elements\n    predictions.begin(), // first element from second range\n    0., // starting value, also dictates the type of accumulator\n    std::plus<>{}, // reduction operation\n    [](double val, double pred) { // transform operation\n        return (val-pred)*(val-pred);\n    }) / values.size(); // calculate the mean\n\n// Same, but computed in parallel.\nauto mse_par = std::transform_reduce(std::execution::par_unseq,\n    values.begin(), values.end(),\n    predictions.begin(), \n    0.,\n    std::plus<>{},\n    [](double val, double pred) {\n        return (val-pred)*(val-pred); \n    }) / values.size();\n\n// mse == mse_par == 12.475\n\nstd::vector<int> data{1,2,3,4,5};\n// Unary (single-range) version is also supported:\nint sum_of_squares = std::transform_reduce(data.begin(), data.end(),\n    0,\n    std::plus<>{},\n    [](int v) { return v*v; });\n// sum_of_squares == 55"
        }
      ],
      "id": "996lcdwb",
      "createdAt": 1711975004298,
      "updatedAt": 1711975010898
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Defaulted comparison operators",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced default comparison operators.\n\nThe spaceship comparison operator results in a piece-wise comparison, comparing the bases and members in order (resulting in strong, weak or partial comparison).\n\nThe defaulted spaceship operator will implicitly default the equality operator if none is declared. The equality operator can also be defaulted separately.\n\n#include <compare>\n#include <string>\n\nstruct Custom {\n    int v;\n    // Default operator==, also provides operator!=\n    friend bool operator==(const Custom&, const Custom&) = default;\n    // Same as: bool operator==(const Custom&) const = default;\n};\n\nCustom c{4}, d{5};\n// c != d\n\n\nstruct Point {\n    int x;\n    int y;   \n    // Default three-way comparison, also defaults operator== \n    // if none is declared:\n    friend auto operator<=>(const Point&, const Point&) = default;\n    // Same as: auto operator <=>(const Point&) const = default;\n};\n\nPoint a{3,2}, b{1,3};\n// a > b\n\n\nstruct Base {\n    int id;\n    auto operator<=>(const Base&) const = default;\n};\n\nstruct Derived : Base {\n    std::string data;\n  \n    // Default spaceship operator:\n    auto operator<=> (const Derived&) const = default;\n  \n    /*  Manual implementation with the same semantics:\n    auto operator<=>(const Derived& other) const {\n        auto cmp = (const Base&)*this <=> (const Base&)other;\n        if (std::is_neq(cmp)) // id != other.id\n            return cmp;\n        return this->data <=> other.data;\n    }\n    */\n};\n\nDerived e{2,\"hello\"}, f{2,\"bye\"};\n// e > f"
        }
      ],
      "id": "0-1MJJp5",
      "createdAt": 1711975014454,
      "updatedAt": 1711975019390
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::visit",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When working with std::variant, querying the current content can become cumbersome. As an alternative, especially for cases when type deduction is involved, we can use the std::visit.\n\nThe std::visit requires as an argument an invocable that is compatible with each of the contained types.\n\n#include <variant>\n#include <iostream>\n\nstd::variant<int,double,std::string> v = \"hello world!\";\n\n// Generic visit, will instantiate the generic lambda for each type:\nstd::visit([](auto&& x) {\n    std::cout << x << \"\\n\";\n}, v);\n// prints \"hello world!\"\n\n\n// Helper relying on CTAD. Inherits from constructor arguments \n// and exposes their call operator.\ntemplate <typename ...Ts>\nstruct overloaded : Ts... {\n    using Ts::operator()...;\n};\n\nv = 2.4;\n// Create a new type by inheriting from lambdas that handle each type:\nstd::visit(overloaded{\n    [](int& x) {\n        std::cout << \"Contains 'int', value: \" << x << \"\\n\";\n    },\n    [](double& x) {\n        std::cout << \"Contains 'double', value: \" << x << \"\\n\";\n    },\n    [](std::string& x) {\n        std::cout << \"Contains 'std::string', value: \" << x << \"\\n\";\n    }\n}, v);\n// prints \"Contains 'double', value: 2.4\"\n\n// Multiple variants can be visited, \n// each mapping to a function argument:\nstd::variant<std::string,int> a(\"hello world!\");\nstd::variant<double,char> b('X');\nstd::visit([](auto&& first, auto&& second) {\n    std::cout << \"first argument :\\n\"\n        << \"\\ttype == \" << typeid(first).name() << \"\\n\"\n        << \"\\tvalue == \" << first << \"\\n\";\n    std::cout << \"second argument :\\n\"\n        << \"\\ttype == \" << typeid(second).name() << \"\\n\"\n        << \"\\tvalue == \" << second << \"\\n\";\n}, a, b);\n// prints (type names are implementation specific):\n// first argument : \n//   type == NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE\n//   value == hello world!\n// second argument : \n//   type == c \n//   value == X"
        }
      ],
      "id": "uihmXyRp",
      "createdAt": 1711975023258,
      "updatedAt": 1711975028680
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::variant",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++17 std::variant is a type-safe alternative to a union, which supports non-trivial custom types.\n\nWhenever you need to store unrelated types or want to avoid relying on inheritance, std::variant is a great choice.\n\nElements can be extracted by type or index; however, only the active type can be accessed.\n\n#include <variant>\n#include <string>\n\nstruct NoDefault{ NoDefault(int) {} };\n\nstd::variant<std::string, int, double> v;\n\n// Variant is never empty, without arguments it \n// default constructs the first type:\nbool x = std::holds_alternative<std::string>(v);\n// x == true\n\n// Assignment sets the variant type:\nv = 10;\n\nint y = std::get<int>(v);\n// OK, y == 10\ny = std::get<1>(v); // same as above, by index\n\ntry {\n    // throws when we attempt to access the wrong type\n    double z = std::get<double>(v);\n} catch (const std::bad_variant_access& ex) {\n    // ex.what() == std::get: wrong index for variant\n}\n\n// Because a variant can't be empty, to default construct,\n// the first type needs to be default constructible:\n// std::variant<NoDefault,int> i; // Wouldn't compile\nstd::variant<NoDefault,int> j(10); // contains int\nstd::variant<NoDefault,int> k(NoDefault{10}); // OK, contains NoDefault"
        }
      ],
      "id": "kTtoWjGy",
      "createdAt": 1711975033521,
      "updatedAt": 1711975038617
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Customizing swap",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Customizing swap for user-defined types and correctly calling swap with a fallback can be tricky.\n\nIf we are not using the C++20 range version, we need to correctly implement the customized version as a friend function (making it visible only to ADL) and pull in the default swap when calling it (to get the fallback).\n\n#include <algorithm>\n\nnamespace MyNamespace {\nstruct MyClass {\n    // Use inline friend function to implement custom swap.\n    friend void swap(MyClass&, MyClass&) { }\n};\n\nstruct MyOtherClass {};\n}\n\nMyNamespace::MyClass a, b;\nMyNamespace::MyOtherClass x, y;\n\n// Fully qualified call, will always call std::swap\nstd::swap(a,b); // calls std::swap\nstd::swap(x,y); // calls std::swap\n\n// No suitable swap for MyOtherClass.\nswap(a,b); // calls MyNamespace::swap\n// swap(x,y); // would not compile\n\n// Pull std::swap as the default into local scope:\nusing std::swap;\nswap(a,b); // calls MyNamespace::swap\nswap(x,y); // calls std::swap\n\n// C++20 std::ranges::swap which will do the correct thing:\nstd::ranges::swap(x,y); // default swap\nstd::ranges::swap(a,b); // calls MyNamespace::swap"
        }
      ],
      "id": "n-o3rD2c",
      "createdAt": 1711975054118,
      "updatedAt": 1711975065328
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::for_each",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::for_each algorithm invokes the provided functor on each range element in order, ignoring the result.\n\nWhile the range-based for-loop has mostly replaced the use cases for std::for_each, it still comes in handy as a trivial parallelization tool and in its C++20 range version with projections.\n\n#include <algorithm>\n#include <execution>\n#include <vector>\n#include <optional>\n\n\nstd::vector<int> data{1, 2, 3, 4, 5};\nstd::for_each(data.begin(), data.end(), [i = 5](int& v) mutable {\n    // iterate over all elements in order\n    v += i--;\n});\n// data == {6, 6, 6, 6, 6}\n\n\nstruct Custom {};\nvoid process(Custom&) {}\n\nstd::vector<Custom> rng(10,Custom{});\n// Parallel execution C++17\nstd::for_each(std::execution::par_unseq, // parallel, in any order\n    rng.begin(), rng.end(), // all elements\n    process // invoke process on each element\n);\n\n\nstd::vector<std::optional<int>> opt{{},2,{},4,{}};\n// Range version with projection C++20\nstd::ranges::for_each(opt,\n    [](int v) {\n        // iterate over projected values\n        // {0, 2, 0, 4, 0}\n    },\n    [](std::optional<int>& v){\n        // projection that will return \n        // the contained value or zero\n        return v.value_or(0);\n    });"
        }
      ],
      "id": "MC3DjIaC",
      "createdAt": 1711975073970,
      "updatedAt": 1711975084429
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Monostate pattern",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The Monostate pattern (not to be confused with std::monostate) is a pattern with similar goals to a Singleton.\n\nWhere a Singleton only permits a single instance, the Monostate pattern can be instantiated many times while ensuring only one instance of its internal state.\n\n#include <cstdint>\n#include <mutex>\n#include <string>\n\nstruct MonoConfig {\n  MonoConfig() {\n    // ensure a single initialization outside of the static chain\n    // if we don't need multi-threaded safety we can downgrade to\n    // a boolean flag\n    std::call_once(flag_, populate_config);\n  }\n\n  // Interface to acess the monostate\n  uint64_t get_id() const { return field1; }\n  const std::string& get_label() const { return field2; }\n\nprivate:\n  static std::once_flag flag_;\n  static void populate_config() {\n    /* read the fields from config source */\n    field1 = UINT64_C(42);\n    field2 = \"Hello World\";\n  }\n  static uint64_t field1;\n  static std::string field2;\n};\n\n// All static members left default initialized\nstd::once_flag MonoConfig::flag_;\nuint64_t MonoConfig::field1;\nstd::string MonoConfig::field2;\n\n// Create instance of the monostate object\nMonoConfig config;\n// to access the global state\nconfig.get_label();\n\n// Creating additional instances is a no-op.\n// Note that when stored as a member, it will still take up \n// minimum 1 byte unless we use [[no_unique_address]].\nMonoConfig a, b, c, d, e, f, g, i, j, k;\n\nOpen the example in Compiler Explorer.\n\nA Monostate (with all the downsides of a global state) can be a better fit for testability.\n\n#include <memory>\n\n// When combined with the PIMPL pattern we can mock/fake\n// the global state:\nstruct ImplIface {};\nstruct Actual : ImplIface {\n  static std::unique_ptr<ImplIface> make() {\n    return std::make_unique<Actual>();\n  }\n};\nstruct Testing : ImplIface {\n  static std::unique_ptr<ImplIface> make() {\n    return std::make_unique<Testing>();\n  }\n};\n\n// Switch active type based on testing/production\nusing ActiveType = Testing;\n\nstruct MonoPIMPL {\n  MonoPIMPL() {\n    std::call_once(flag_, [] { impl_ = ActiveType::make(); });\n  }\n  /* expose ImplIface as any other PIMPL */\nprivate:\n  static std::once_flag flag_;\n  static std::unique_ptr<ImplIface> impl_;\n};\n\nstd::once_flag MonoPIMPL::flag_;\nstd::unique_ptr<ImplIface> MonoPIMPL::impl_;"
        }
      ],
      "id": "WRtqYWEg",
      "createdAt": 1711975091317,
      "updatedAt": 1711975098978
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "opaque enum declaration",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Opaque enum declaration allows us to specify an enum type without exposing the enumerators and their values.\n\n////////////\n// library.h\n#include <cstdint>\n\n// Opaque declaration\nenum class Fruit : uint32_t;\n// Unscoped enum would also work, but the underlyign type has \n// to be specified.\n\n// We can use Fruit in the API without providing enumerators.\nFruit get_apple();\nFruit get_banana();\nvoid function(Fruit);\n\nOpen the example in Compiler Explorer.\n\nThis has the benefit of introducing a strongly typed integral type without implicit conversion semantics.\n\nOn top of that, we avoid making the enumerators and their values part of the public API.\n\n/////////////\n// library.cc\n#include \"library.h\"\n\n// Definition with enumerators\nenum class Fruit : uint32_t {\n    Apple,\n    Banana\n};\n\n// Only implementation can access enumerators\nFruit get_apple() {\n    return Fruit::Apple;\n}\n\nFruit get_banana() {\n    return Fruit::Banana;\n}\n\n#include <iostream>\n\nvoid function(Fruit c) {\n    switch (c) {\n        case Fruit::Apple:\n            std::cout << \"Called with \\\"apple\\\" enumerator.\\n\";\n            break;\n        case Fruit::Banana:\n            std::cout << \"Called with \\\"banana\\\" enumerator.\\n\";\n         break;\n    }\n}\n\n///////////\n// main.cpp\n#include \"library.h\"\n\nint main() {\n    function(get_apple());\n    function(get_banana());\n}"
        }
      ],
      "id": "bG2h-_US",
      "createdAt": 1711975114394,
      "updatedAt": 1711975127470
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::shuffle",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When we need to shuffle elements into a random order, we can use the C++11 std::shuffle algorithm, which relies on a random engine as the source of randomness.\n\nAny random engine can be used, but for simple operations, it is typically sufficient to use the implementation-defined std::default_random_engine.\n\n#include <random>\n#include <algorithm>\n\nstd::vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\n\nstd::shuffle(\n    data.begin(), data.end(), // all elements\n   // source of randomness with a specified seed\n    std::default_random_engine(42)\n);\n// data == {2, 7, 4, 0, 6, 1, 8, 3, 5, 9} libstdc++\n// data == {6, 8, 7, 0, 1, 4, 9, 3, 2, 5} libc++\n\n// Ranges variant with a random seed:\nstd::random_device rd;\nstd::ranges::shuffle(data, std::default_random_engine(rd()));\n// data now re-shuffled"
        }
      ],
      "id": "snbALuQU",
      "createdAt": 1711975132617,
      "updatedAt": 1711975137829
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::iota and std::views::iota",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::iota is a simple algorithm that generates consecutive values by repeatedly applying the prefix increment, starting from the initial value.\n\nWhile the base std::iota algorithm is fairly niche, the C++20 std::views::iota is a more helpful version, particularly when we combine it with other views.\n\n#include <numeric>\n#include <algorithm>\n#include <vector>\n#include <ranges>\n\nstd::vector<int> data(5);\nstd::iota(data.begin(), data.end(), 42);\n// data == {42, 43, 44, 45, 46}\n\n// One convenient use case is to generate an \"indirect\" container.\nstd::vector<std::vector<int>::iterator> indirect(data.size());\nstd::iota(indirect.begin(), indirect.end(), data.begin());\n\n// Useful when swapping is expensive or impossible.\n// We can manipulate the indirect container instead.\nstd::sort(indirect.begin(), indirect.end(), \n          [](auto& left, auto& right) {\n     return *left > *right;\n    });\n// data == {42, 43, 44, 45, 46}\n// indirect ~ {46, 45, 44, 43, 42}\n\n// Finite view {9, 10, 11}\nfor (auto v : std::views::iota(9,12)) { }\n\n// Infinite iota view {42,....}\nfor (auto v : std::views::iota(42)) {\n    if (v % 13 == 0) break;\n}\n\n// Infinite std::view::iota, zipped with a range\n// (std::views::zip is C++23)\nfor (auto [idx, elem] : std::views::zip(std::views::iota(1), data)) {}"
        }
      ],
      "id": "6Uwcjfjj",
      "createdAt": 1711975143793,
      "updatedAt": 1711975151132
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::min, std::max and std::minmax",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::min, std::max, and std::minmax algorithms are relatively simple yet provide multiple overloads suitable for different use cases.\n\nC++11 introduced the std::minmax and std::initializer_list variants, and C++20 introduced range variants (not just the namespace).\n\n#include <algorithm>\n#include <vector>\n\nint a = 20, b = 30;\n\n// Basic overloads return a const-reference to the minimum element.\nauto &r1 = std::min(a,b);\n// &a == &r1\n\nb = 20;\n// Worth noting that both min and max are biased \n// towards the first argument.\nauto &r2 = std::min(a,b);\nauto &r3 = std::max(a,b);\n// &a == &r2 == &r3\n\n// C++11 introduced std::minmax\na = 10;\nb = 5;\n// Returns a std::pair<const&,const&> which can be deconstructed\n// using C++17 structured binding.\nauto [min, max] = std::minmax(a,b);\n// &min == &b, &max == &a\n\n// C++11 also introduced initializer list overloads. These return \n// by value due to the temporary nature of initializer lists.\nint v = std::min({5,2,4,3,9});\n// v == 2\n\n// C++20 introduced a range variant\nstd::vector<int> data = {5,2,4,3,9};\n\n// Accepts any range and returns by value.\nauto [x,y] = std::ranges::minmax(data);\n// x == 2, y == 9"
        }
      ],
      "id": "qlZFm8Em",
      "createdAt": 1711975157051,
      "updatedAt": 1711975165828
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::span",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When interacting with legacy code or C APIs, passing data around as C arrays might be unavoidable. This brings with it the potential for errors.\n\nC++20 introduced std::span, a view that can wrap a contiguous memory block and provides a contiguous range interface.\n\nWe can use a std::span to bridge the C and C++ code and to access the underlying byte representation.\n\n#include <cstdint>\n#include <span>\n#include <vector>\n#include <ranges>\n\nchar buffer[16];\nauto view = std::span(buffer);\n// Call C API using a wrapped buffer\nsize_t cnt = read(view.data(), view.size());\n// Process a sub-view based on the number of actually read bytes\nfor (auto v : view.subspan(0, cnt)) {}\n\nchar* buff;\nsize_t length;\nint ret = get_data(&buff, &length);\nif (ret != 0) { return ret; }\n// Wrap a C buffer into a std::span\nauto buffer_view = std::span(buff, length);\n\n// std::span works as any other range, e.g. reverse iteration:\nfor (auto it = buffer_view.rbegin(); it != buffer_view.rend(); ++it) {}\n// or combining with views:\nfor (auto v : buffer_view | std::views::drop(16)) {}\n\nstd::vector<Data> data{{2,3},{1,5},{4,4}};\n// Acces the underlying representation:\nstd::span<std::byte> bytes = std::as_writable_bytes(std::span(data));"
        }
      ],
      "id": "5PYlsH5n",
      "createdAt": 1711975170178,
      "updatedAt": 1711975175503
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::make_heap, std::pop_heap, std::push_heap, std::sort_heap",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The set of heap algorithms: std::make_heap, std::push_heap, std::pop_heap and std::sort_heap can be used as a replacement for std::priority_queue and std::set when it is desirable to keep the elements in continuous storage or when we require cheap element extraction.\n\nFor the benefits, we pay with a more error-prone interface.\n\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> data{8,2,1,7,4,5,3,6,9};\n// initialize max-heap\nauto begin = data.begin(), end = data.end();\nstd::make_heap(begin, end);\n\n// pop each element from the heap producing \n// a sorted order in the vector\nwhile (begin != end) {\n    // pop_heap swaps the max element with \n    // the last element in range, maintaining the heap\n    std::pop_heap(begin, end--);\n    // iterate over 9,8,...\n}\n// data == {1, 2, 3, 4, 5, 6, 7, 8, 9}\n\nstd::vector<std::string> labels{\"world\",\"bye\",\"fox\",\"lazy\",\"dog\"};\nstd::make_heap(labels.begin(), labels.end());\n// labels now in heap order\n\n// extract element from heap, without removing it from the vector\nstd::pop_heap(labels.begin(), labels.end());\n// in-place modify\nlabels.back()[0] = 'e';\n// insert element into heap\nstd::push_heap(labels.begin(), labels.end());\n\nstd::sort_heap(labels.begin(), labels.end());\n// labels == {\"bye\", \"dog\", \"eorld\", \"fox\", \"lazy\"}"
        }
      ],
      "id": "GtMEyPtj",
      "createdAt": 1711975182239,
      "updatedAt": 1711975189002
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::compare_strong_order_fallback, std::compare_weak_order_fallback, std::compare_partial_order_fallback",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When integrating C++20 three-way comparison with older code, we don’t have to switch all code immediately.\n\nInstead, we can rely on helpers that produce a three-way comparison result using standard comparison operators.\n\n#include <compare>\n\nstruct Coord {\n    int x;\n    int y;\n    friend bool operator < (const Coord& left, const Coord& right) {\n        if (left.x == right.x)\n            return left.y < right.y;\n        return left.x < right.x;\n    }\n    friend bool operator == (const Coord& left, const Coord& right) {\n        return left.x == right.x && left.y == right.y;\n    }\n};\n\nCoord a{1, 2}, b{2, 2};\n\n// Wouldn't compile:\n// auto v = a <=> b;\n\n// Produces strong_order result using operator == and <\nauto w = std::compare_strong_order_fallback(a,b);\n// std::is_lt(w) == true\n\n// strong and weak order require only ==, <\n// partial order requires ==, <, >"
        }
      ],
      "id": "vkEanKtH",
      "createdAt": 1711975196838,
      "updatedAt": 1711975203155
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::bitset",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::bitset is a statically-sized container offering bit-level addressing.\n\nOn top of the storage and bit access, the container also provides the typical boolean (all_of, any_of, none_of), bitwise (AND, OR, XOR, NOT) and global (set, reset, flip) bit manipulations.\n\n#include <bitset>\n\nstd::bitset<16> data;\n\n// the zero index refers to the least significant bit\ndata[0] = 1;\n// data.to_ullong() == 1\n\n// set all bits to 1\ndata.set();\n// data.to_ullong() == 65535\n\n// flip all bits (setting them to zero)\ndata.flip();\n\ndata[0] = 1;\ndata[2] = 1;\ndata[4] = 1;\n\nstd::bitset<16> other;\nother[0] = 1;\nother[2] = 1;\n\n// bitwise AND\ndata &= other;\n// data.to_ullong() == 5\n\n// any_of\nbool test = data.any();\n// test == true\n\n// count of 1 bits\nsize_t cnt = data.count();\n// cnt == 2"
        }
      ],
      "id": "ay5SErZ6",
      "createdAt": 1711975215287,
      "updatedAt": 1711975221057
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::strong_ordering, std::weak_ordering, std::partial_ordering",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "With the C++20 spaceship operator, we also received three comparison result types: std::strong_ordering, std::weak_ordering and std::partial_ordering.\n\nstd::strong_ordering equality implies that the values are indistinguishable, and std::partial_ordering is the only ordering that permits uncomparable values (where all a < b, a > b, a == b return false).\n\n#include <cmath>\n\nstruct Coord {\n    int x;\n    int y;\n    friend auto operator<=>(const Coord&, const Coord&) = default;\n};\n\n// Integral types are strongly ordered\nstatic_assert(std::is_same_v<decltype(0 <=> 1), std::strong_ordering>);\n// Aggregates formed from strongly ordered components end up \n// also strongly ordered\nstatic_assert(std::is_same_v<decltype(Coord{0,0} <=> Coord{1,1}),\n               std::strong_ordering>);\n\n// Notably floating-point numbers are only partially ordered:\nstatic_assert(std::is_same_v<decltype(-0.0<=>0.0),\n               std::partial_ordering>);\n\nbool r1 = -0.0 == 0.0;\nbool r2 = std::signbit(-0.0) == std::signbit(0.0);\n// r1 == true, r2 == false\n// -0.0 and 0.0 are equivalent, but distinguishable\n\nbool r3 = NAN == 0.0 || NAN < 0.0 || NAN > 0.0;\n// r3 == false, NaN is unordered"
        }
      ],
      "id": "6768AjpH",
      "createdAt": 1711975226035,
      "updatedAt": 1711975231553
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::all_of, std::any_of and std::none_of",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The trio of boolean algorithms: std::all_of, std::any_of, and std::none_of, provide the expected boolean logic with early termination.\n\nWhile the std::all_of and std::none_of return true for empty ranges, std::any_of requires a positive presence and will return false for an empty range.\n\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> data{2, 2, 2, 4, 6, 8};\n    \nauto is_even = [](int v) { return v % 2 == 0; };\nauto is_odd = [](int v) { return v % 2 != 0; };\nauto is_double_digit = [](int v) { return v > 9 && v < 100; };\n\nbool r1 = std::all_of(data.begin(), data.end(), is_even);\n// r1 == true\n\nbool r2 = std::none_of(data.begin(), data.end(), is_odd);\n// r2 == true\n\nbool r3 = std::any_of(data.begin(), data.end(), is_double_digit);\n// r3 == false\n\nint cnt = 0;\nauto count = [&cnt](int v) {\n    ++cnt;\n    return v < 6;\n};\n\nbool r4 = std::all_of(data.begin(), data.end(), count);\n// r4 == false, cnt == 5 (early terminated after evaluating v == 6)"
        }
      ],
      "id": "bOmnakbL",
      "createdAt": 1711975235580,
      "updatedAt": 1711975241130
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::move_iterator",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Standard data structures can be move constructed only from a matching type.\n\nHowever, using the std::move_iterator adapter, we can still do a piecewise move-construct between non-compatible data structures.\n\n#include <vector>\n#include <list>\n#include <iterator>\n#include <algorithm>\n#include <memory>\n\nstruct MyClass {};\n   \nstd::vector<std::unique_ptr<MyClass>> src;\nstd::generate_n(std::back_inserter(src), 5, []{\n    return std::make_unique<MyClass>();\n});\n\n// Wouldn't compile: incompatible type\n// std::list<std::unique_ptr<MyClass>> dst1(std::move(src));\n\n// Wouldn't compile: std::unique_ptr is not copyable\n// std::list<std::unique_ptr<MyClass>> dst2(src.begin(), src.end());\n\n// OK\nstd::list<std::unique_ptr<MyClass>> dst3(\n    std::move_iterator(src.begin()),\n    std::move_iterator(src.end())\n);"
        }
      ],
      "id": "SvdAtWXD",
      "createdAt": 1711975258925,
      "updatedAt": 1711975263862
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::nth_element",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::nth_element is a partitioning algorithm with linear complexity that will reorder the elements of the given range, such the that element under the middle iterator is the element that would be there if the range was sorted.\n\nThis can be useful for picking the various percentiles out of range (such as the median) without explicitly sorting it.\n\nThe linear complexity of the algorithm does some with a non-trivial constant cost, which means that if you are looking for a small number of elements, the std::partial_sort algorithm can be faster.\n\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> data{8, 6, 2, 4, 3, 5, 9, 1};\nstd::nth_element(data.begin(), data.begin()+3, data.end());\n// *(data.begin()+3) == 4\n// because the sorted range would be {1, 2, 3, 4...}"
        }
      ],
      "id": "o5IcU0Z2",
      "createdAt": 1711975268316,
      "updatedAt": 1711975272671
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::iter_swap",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::iter_swap is a convenient shorthand for swapping the values pointed by two iterators.\n\nWhile the original version is only intended for iterators, the range C++20 version can work with any indirectly movable type and serves as a customization point.\n\n#include <vector>\n#include <iterator>\n#include <iostream>\n#include <memory>\n#include <ranges>\n\ntemplate <typename It, typename Sentinel>\nrequires std::bidirectional_iterator<It> &&\n   std::sentinel_for<Sentinel,It>\nvoid reverse(It begin, Sentinel end) {\n    while (begin != end && std::next(begin) != end) {\n        end = std::prev(end);\n        // using iter_swap to swap the values behind the iterators\n        std::iter_swap(begin,end);\n        begin = std::next(begin);\n    }\n}\n\nstd::vector<int> data{1,2,3,4,5};\nreverse(data.begin()+1, data.end()-1);\n// data == { 1, 4, 3, 2, 5 }\n\n\n// C++20 ranges\nauto a = std::make_unique<int>(7);\nauto b = std::make_unique<int>(42);\n// Generalized iter_swap, works for any indirectly movable type.\nstd::ranges::iter_swap(a,b);\n// *a == 42, *b == 7\n\n\n// Customization point\nstruct Indirect {\n    int* value_;\n    friend void iter_swap(Indirect& l, Indirect& r) {\n        std::cout << \"Customization called.\\n\";\n        int tmp = *l.value_;\n        *l.value_ = *r.value_;\n        *r.value_ = tmp;\n    }\n};\n\nint x = 10, y = 20;\nIndirect xi(&x), yi(&y);\n// Calls customized iter_swap\nstd::ranges::iter_swap(xi,yi);\n// x == 20, y == 10"
        }
      ],
      "id": "UPuAzjTv",
      "createdAt": 1711975276547,
      "updatedAt": 1711975282138
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "if consteval {}",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++23 added the if consteval {} statement, with the ability to test whether the code is constant evaluated.\n\nThis is useful to distinguish between alternate implementations or to allow for runtime side effects such as monitoring.\n\nconstexpr int add(int a, int b) {\n    if consteval {\n        // consteval branch that can only use \n        // constant expression compatible code\n        return a + b;\n    } else {\n        // not consteval, we can use fancy things \n        // like inline assembler, or intristics\n        int ret;\n        asm(\"addl %%ebx, %%eax;\":\"=a\"(ret) : \"a\"(a), \"b\"(b));\n        return ret;\n    }\n}\n\nconstexpr int side(int arg) {\n    // Useful for side-effects such as logging...\n    if !consteval {\n        std::cout << \"Not a constant expression, we can safely log.\\n\";\n    }\n    return arg*arg;\n}"
        }
      ],
      "id": "Cd6kiKPN",
      "createdAt": 1711975293159,
      "updatedAt": 1711975298520
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "consteval",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The consteval specifier was introduced in C++20.\n\nWhile functions marked with constexpr can be evaluated at compile time, but also with runtime arguments at runtime, the consteval specifier forces strict constant-only evaluation.\n\nThis is convenient for compile-time-only constructs (such as reflection) since a function marked with consteval will always produce a constant expression.\n\nconstexpr int sum(int a, int b) {\n    return a + b;\n}\nconsteval int product(int a, int b) {\n    return a * b;\n}\n\nconsteval int product_until(int limit) {\n    int result = 1;\n    for (int i = 2; i <= limit; i++) {\n        // i is not a constant expression but since this is \n        // inside of a consteval function, this is permitted\n        result = product(result, i);\n    }\n    return result;\n}\n\n// Both constexpr and consteval can be used in constant expressions\nstatic_assert(sum(1,2) == 3);\nstatic_assert(product(2,3) == 6);\n\nint a = sum(argc,argc);\n// a == 2 (for argc == 1)\n\n// Wouldn't compile, argc is not a constant expression\n// int b = product(argc,argc);\n\nstatic_assert(product_until(5) == 120);"
        }
      ],
      "id": "DuB9G8Md",
      "createdAt": 1711975311620,
      "updatedAt": 1711975316743
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::tuple",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::tuple is a heterogeneous collection of elements.\n\nUnlike std::pair, a tuple can contain any number (including none) of elements.\n\n#include <tuple>\n#include <vector>\n\nvoid function(int a, int b) {}\n\n// Empty std::tuple\nauto a = std::tuple{};\n// std::tuple_size<delctype(a)>{} == 0\n\nauto b = std::tuple{5,42};\n// construct a std::vector\n// using the tuple elements as arguments to the constructor.\nauto v = std::make_from_tuple<std::vector<int>>(b);\n// v == {42, 42, 42, 42, 42}\n\n// call a function, using the tuple elements as arguments\nstd::apply(function, b);\n\n// as with std::pair, std::tuple can \n// be deconstructed using structured bindings\nauto c = std::tuple{\"Hello World!\", 42, &a};\nauto [msg, val, ptr] = c;\n// msg == \"Hello World!\", val == 42, ptr == &a"
        }
      ],
      "id": "c5l8-r8u",
      "createdAt": 1711975329558,
      "updatedAt": 1711975337068
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::call_once",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::call_once is a low-level synchronization tool that guarantees a single successful (call that doesn't throw) call to callable.\n\nAll successive attempts (even those made during the singular call) will be synchronized to the exit of the callable, which means that any changes made during the call will be visible to all threads.\n\nWhile we can simulate similar behaviour using a local static variable, that approach only works for synchronizing a single function. std::call_once can be used across multiple functions.\n\n\n#include <memory>\n#include <mutex>\n#include <thread>\n#include <vector>\n#include <algorithm>\n\nconstexpr inline std::string_view resource_path = \"/some/path\";\n\nstruct GlobalResource {\n    struct Header{};\n    struct Body{};\n    static const Header& header() {\n        std::call_once(flag_, load_resource, resource_path);\n        return instance_->header_;\n    }\n    static const Body& body() {\n        std::call_once(flag_, load_resource, resource_path);\n        return instance_->body_;\n    }\nprivate:\n    Header header_;\n    Body body_;\n    static void load_resource(std::string_view path) {\n        auto res = std::make_unique<GlobalResource>();\n        instance_ = std::move(res);\n    }\n    static std::once_flag flag_;\n    static std::unique_ptr<GlobalResource> instance_;\n};\n\nstd::unique_ptr<GlobalResource> GlobalResource::instance_ = nullptr;\nstd::once_flag GlobalResource::flag_;\n\nint main() {\n    std::vector<std::jthread> runners;\n    // spawn 4 threads\n    std::generate_n(std::back_inserter(runners), 4,[]{\n        return std::jthread([]{\n            auto& header = GlobalResource::header();\n            // process header\n            auto& body = GlobalResource::body();\n            // process body\n        });\n    });\n}"
        }
      ],
      "id": "j-654jnU",
      "createdAt": 1711975341705,
      "updatedAt": 1711975368712
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::to_underlying",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::to_underlying is a C++23 single-purpose cast that casts an enumerator to the underlying integral type of the enumeration.\n\nBefore C++23, we would have to rely on the static_cast with the C++11 std::underlying_type as the underlying type of unscoped enumerations is implementation-defined.\n\n#include <utility>\n#include <type_traits>\n#include <cstdint>\n\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n};\n\nenum Info {\n    LIMIT = UINT64_MAX\n};\n\nenum class MyColor {\n    RED,\n    GREEN,\n    BLUE\n};\n\nauto a = std::to_underlying(RED);\n// a == 0, sizeof(a) == sizeof(int) (concrete type is impl.defined)\n\nauto b = std::to_underlying(LIMIT);\n// b == UINT64_MAX, decltype(b) an unsigned type of size uint64_t\n\n// Before C++23, we would have to rely on static_cast\nauto c = static_cast<std::underlying_type<Info>::type>(LIMIT); // C++11\nauto d = static_cast<std::underlying_type_t<Info>>(LIMIT); // C++14\n// b == c == d\n\n// Scoped enumerations have a well defined underlying type\nauto e = std::to_underlying(MyColor::GREEN);\n// e == 1, decltype(e) == int"
        }
      ],
      "id": "Cst3Yhr2",
      "createdAt": 1711975380406,
      "updatedAt": 1711975385346
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::scoped_lock",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "We must be mindful when acquiring multiple locks, as we can run into a deadlock. The simplest example of a deadlock:\n\n    T1 holds lock A and tries to acquire lock B\n    T2 holds lock B and tries to acquire lock A\n\nThe std::scoped_lock (C++17) offers a library-level solution to this problem, as it will acquire locks on multiple mutexes without incurring the risk of deadlocks.\n\n#include <iostream>\n#include <thread>\n#include <mutex>\n#include <random>\n#include <algorithm>\n#include <utility>\n\nstruct Player {\n    Player(std::string name, uint64_t seed) : name_(std::move(name)),\n        re_(seed), dist_(1,6), mux_{}, score_{0} {}\n\n    void play_with(Player& other) {\n        if (&other == this) return;\n        // to play a game we need to obtain both our lock and the lock\n        // of the oponent which creates potential for deadlock\n        std::scoped_lock lock(mux_, other.mux_);\n        // Roll a dice until one player wins, then increase the score\n        int our = 0, them = 0;\n        do {\n            our = roll();\n            them = other.roll();\n        } while (our == them);\n        if (our > them)\n            score_++;\n        else\n            other.score_++;\n        // lock released\n    }\n    const std::string& name() const { return name_; }\n    int score() const { return score_; }\nprivate:\n    // Roll a D6\n    int roll() { return dist_(re_); }\n    std::string name_;\n    std::default_random_engine re_;\n    std::uniform_int_distribution<int> dist_;\n    std::mutex mux_;\n    int score_;\n};\n\nint main() {\n    std::random_device r;\n    std::vector<std::unique_ptr<Player>> players;\n    auto names = {\"Player1\", \"Player2\", \"Player3\", \"Player4\",\n                  \"Player5\", \"Player6\", \"Player7\", \"Player8\",\n                  \"Player9\"};\n   // generate players from the names\n    std::ranges::transform(names, std::back_inserter(players),\n     [&](const char* name) {\n          return std::make_unique<Player>(name, r()); \n        });\n\n    // Run the tournament:\n    // each player plays all other players in parallel\n    std::vector<std::jthread> rounds;\n    for (auto &v : players) {\n        rounds.push_back(std::jthread([&players,&v]{\n            for (auto &oponent : players) {\n                v->play_with(*oponent);\n            }\n        }));\n    }\n    rounds.clear(); // a.k.a. join all threads\n\n    // Sort and print\n    std::ranges::sort(players, std::greater<>{}, \n     [](const std::unique_ptr<Player>& p) {\n          return p->score();\n        });\n    for (const auto &v : players) {\n        std::cout << v->name() << \" \" << v->score() << \"\\n\";\n    }\n}"
        }
      ],
      "id": "QRq0-D4o",
      "createdAt": 1711975401849,
      "updatedAt": 1711975408794
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::inplace_merge",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::inplace_merge algorithm merges two sorted subranges into one sorted range.\n\nWith this algorithm, we can quickly build a merge-sort implementation (as the in-place merge is the core of this sort).\n\nBecause the std::inplace_merge algorithm is stable (maintains the order of equal elements), so is this merge-sort implementation.\n\nThe following example uses the range variants introduced in C++20:\n\n#include <concepts>\n#include <ranges>\n#include <algorithm>\n\nvoid merge_sort(std::ranges::random_access_range auto& rng) {\n    if (rng.size() <= 1) return;\n\n    // divide the range into two parts\n    auto mid = rng.begin() + rng.size()/2;\n    auto left = std::ranges::subrange(rng.begin(), mid);\n    auto right = std::ranges::subrange(mid, rng.end());\n\n    // recursively sort left and right\n    merge_sort(left);\n    merge_sort(right);\n    // in-place merge left and right\n    std::ranges::inplace_merge(rng, mid);\n}\n\nstd::vector<int> data{3, 5, 1, 4, 2, 6};\nmerge_sort(data);\n// data == {1, 2, 3, 4, 5, 6}"
        }
      ],
      "id": "-GRZfCPm",
      "createdAt": 1711975449116,
      "updatedAt": 1711975454882
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::promise, std::future",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++ doesn’t offer many high-level thread synchronization and communication tools. One of the few is the pair of std::promise and std::future.\n\nThe std::promise and std::future implement one-shot producer-consumer semantics.\n\nThe consumer (std::future) can block until the result of the producer (std::promise) is available, at which point the produced value can be accessed.\n\n#include <future>\n#include <thread>\n#include <iostream>\n#include <stdexcept>\nusing namespace std::literals;\n\nstd::promise<std::string> promise;\n// Future is obtained from the promise.\nstd::future<std::string> future = promise.get_future();\nauto t = std::jthread([promise = std::move(promise)] mutable {\n    std::this_thread::sleep_for(100ms);\n    // Set the value, this will unblock the consumer (future).\n    promise.set_value(\"Hello World!\"s);\n    // If it is preferable to block until this thread finishes:\n    // promise.set_value_at_thread_exit(\"Hello World!\"s);\n});\n\n// Will block until value awailable, \n// then returns the stored value:\nstd::cout << future.get() << \"\\n\";\n// Will print: \"Hello World!\"\n\n// Promise/Future can also propagate exceptions:\nstd::promise<int> other;\nstd::future<int> will_fail = other.get_future();\nauto f = std::jthread([promise = std::move(other)] mutable {\n    try {\n        throw std::runtime_error(\"Some error happened.\");\n        promise.set_value(10); // unreachable\n    } catch (...) {\n        promise.set_exception(std::current_exception());\n        // same as before we can also:\n        // set_exception_at_thread_exit(...);\n    }        \n});\n\ntry {\n    // Block until value awailable, in this case,\n    // the exception will be propagated instead.\n    int v = will_fail.get();\n    std::cout << \"This will not print \" << v << \"\\n\";\n} catch (const std::exception& e) {\n    std::cout << \"Propagated exception: \" << e.what() << \"\\n\";\n}\n// Will print: \"Propagated exception: Some error happened.\""
        }
      ],
      "id": "DvVMAY3s",
      "createdAt": 1711975459495,
      "updatedAt": 1711975466587
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Compositing C++20 views",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When working with C++20 views, creating functions that encapsulate complex view compositions might be tempting.\n\nHowever, that will very likely lead to unnecessary data copies. Instead, consider compositing views as inline constexpr variables.\n\n#include <ranges>\n#include <cctype>\n\nconstexpr inline auto trim_front = \n  std::views::drop_while([](int c) { return std::isspace(c); });\nconstexpr inline auto trim_back = \n  std::views::reverse | trim_front | std::views::reverse;\nconstexpr inline auto trim_space = \n  trim_back | trim_front;\n\n\nstd::string str = \"    abc    \\t\";\n\n// Compose the view with data\nauto lazy_trimmed = str | trim_space;\n\n// Generate the output (before C++23 std::ranges::to)\nstd::string out(lazy_trimmed.begin(), lazy_trimmed.end());\n// out == \"abc\""
        }
      ],
      "id": "eqCAyqZe",
      "createdAt": 1711975470410,
      "updatedAt": 1711975475545
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::plus, std::minus, std::multiplies, std::divides, std::modulus and std::negate",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::plus, std::minus, std::multiplies, std::divides, std::modulus and std::negate are function objects from the <functional> header that wrap the corresponding arithmetic operators.\n\nSince C++14, these objects also provide a void specialization that relies on type deduction for both arguments.\n\n#include <vector>\n#include <algorithm>\n\nauto int_plus = std::plus<int>{};\nauto v = int_plus(4.2, 3.9);\n// decltype(v) == int, v == 7 (4+3)\n\nauto deduced_plus = std::plus<>{};\nauto w = deduced_plus(4, 3.9);\n// decltype(w) == double, w ~= 7.9\n\n// Useful when working with algorithms:\nstd::vector<int> data{1,2,3,4,5};\nstd::vector<int> out;\nstd::ranges::transform(data, std::back_inserter(out),\n                       std::negate<>{});\n// out == {-1,-2,-3,-4,-5}\n\nauto product = std::ranges::fold_left(data, 1, \n                                      std::multiplies<>{});\n// product == 120"
        }
      ],
      "id": "NP4_WLxZ",
      "createdAt": 1711975481875,
      "updatedAt": 1711975487359
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::drop, std::views::drop_while",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 std::views::drop and std::views::drop_while are views that omit leading elements of the underlying range.\n\nstd::views::drop will omit the specified number of leading elements. std::views::drop_while will omit the leading elements that satisfy the provided predicate.\n\n#include <vector>\n#include <ranges>\n\nstd::vector<int> data{1,2,3,4,5};\n\n// iterate over {2,3,4,5}\nfor (auto v : data | std::views::drop(1)) {}\n\nconstexpr auto less_three = [](int v) { return v < 3; };\n// iterate over {3,4,5}\nfor (auto v : data | std::views::drop_while(less_three)) {}"
        }
      ],
      "id": "_bJCln19",
      "createdAt": 1711975492645,
      "updatedAt": 1711975499509
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Anonymous namespaces",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Anonymous (unnamed) namespaces are a great C++11 tool for controlling the linkage of symbols.\n\nAny symbols inside an unnamed namespace will have internal linkage, i.e. the symbols are only visible to the translation unit.\n\n// unit.h\nnamespace MyLib {\n    void function();\n}\n\n// unit.cc\nnamespace { // Unnamed namespace\n    void internal_function() {}\n}\n\nnamespace MyLib {\n    void function() { internal_function(); } // OK, visible inside unit\n}\n\nvoid other_function() {}\n\n// main.cc\nint main() {\n    MyLib::function();  // OK, accesible through header\n\n    void other_function(); // manual declaration\n    other_function();      // OK, external linkage\n\n    void internal_function(); // manual declaration\n    internal_function();      // Linker error, symbol not visible\n}"
        }
      ],
      "id": "dXvM_wtv",
      "createdAt": 1711975506652,
      "updatedAt": 1711975512442
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::monostate",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "By default, std::variant will default construct with the first of its element active.\n\nThis can be problematic when we want to permit an empty state or the elements are expensive to construct or do not support default construction.\n\nstd::monostate can be used as the first element of a variant to get around these issues.\n\n#include <variant>\n\nstruct X {\n    X(int v) : v_(v) {}\n    int v_;\n};\n\nstruct Y {\n    Y(double v) : v_(v) {}\n    double v_;\n};\n\nstd::variant<std::monostate, int> a;\n// \"Empty\" when default constructed\n// a.index() == 0\n\n// X, Y are non-default constructible\n// std::variant<X,Y> b; wouldn't not compile, can't default construct\nstd::variant<X,Y> b = Y{20};\n// b.index() == 1\n\nstd::variant<std::monostate,X,Y> c; // OK\n// c.index() == 0"
        }
      ],
      "id": "wkP_4RCX",
      "createdAt": 1711975588375,
      "updatedAt": 1711975592639
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Standard string literals",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "String literals in C++ are immutable character arrays (for compatibility with C).\n\nThis can be inconvenient when working with generic functions or when using auto.\n\nSince C++14, the standard library provides support for standard string literals, that is, literals of type std::string and its variants.\n\n#include <string>\nusing namespace std::string_literals;\n\nauto s1 = \"Hello World!\"s;\n// decltype(s1) == std::string\n\nauto s2 = L\"😀\"s;\n// decltype(s2) == std::wstring\n\n// utf8 string literal since C++20\nauto s3 = u8\"🙃\"s; \n// decltype(s3) == std::u8string\n\nauto s4 = u\"😜\"s;\n// decltype(s4) == std::u16string\n\nauto s5 = U\"🤔\"s;\n// decltype(s5) == std::u32string"
        }
      ],
      "id": "7CsHZUkQ",
      "createdAt": 1711975596335,
      "updatedAt": 1711975602226
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::common",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Before C++20, a range was an implicit concept represented by two iterators. With C++20, this concept was formalized and relaxed to an iterator and a sentinel.\n\nTo adapt a range for old code that requires a common range (iterator and sentinel of the same type), we can use the std::views::common adapter view.\n\n#include <ranges>\n#include <numeric>\n\n// std::views::iota(1) is not a common view\nauto view = std::views::iota(1) | std::views::take(3);\n\n// Will not compile, view.begin() and view.end() are of different types\n// int sum = std::accumulate(view.begin(), view.end(), 0);\n\nauto common_view = view | std::views::common;\nint sum = std::accumulate(common_view.begin(), common_view.end(), 0);\n// OK, sum == 6"
        }
      ],
      "id": "73o5fL6K",
      "createdAt": 1711975607450,
      "updatedAt": 1711975612540
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Structured bindings",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Structured bindings were introduced in C++17.\n\nThey allow the decomposition of arrays, tuples and non-static data members into named identifiers.\n\nThe original object is captured following the standard deduction rules for auto; the identifiers are effectively transparent references into the captured object.\n\n#include <unordered_set>\n#include <string>\n\nstruct UserType {\n    int a;\n    double b;\n    std::string c;\n};\n\n// typical use case for structured binding to decompose \n// a pair returned by some standard library operations\nstd::unordered_set<int> data{1, 2, 3, 4, 5};\nif (auto [it, inserted] = data.insert(4); inserted) {\n    // insertion happened\n    // it points to the newly inserted element  \n} else {\n    // no insertion happened\n    // it points to the existing element\n}\n\n// Normal auto deduction rules still apply\nstd::pair a{10,20}; // mutable\nconst std::pair b{10,20}; // immutable\n\nauto [i,j] = a; // Capture by copy\ni = 0; j = 0; // OK\n// a.first == 10, a.second == 20\n\nauto &[k,l] = a; // Capture by reference\nk = 0; l = 0; // OK\n// a.first == 0, a.second == 0\n\nauto &[m,n] = b; // Capture by reference, auto will deduce const\n// m = 0; j = 0; // Not OK, cannot mutate read-only variable\n\nUserType u{42, 3.14, \"Hello World!\"};\n// Decomposing an aggregate\nauto &[x,y,z] = u;\n// x == 42, y == 3.14, z == \"Hello World!\""
        }
      ],
      "id": "SOiDp80F",
      "createdAt": 1711975615902,
      "updatedAt": 1711975621032
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::next, std::prev",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::next and std::prev are C++11 iterator utilities that return the succeeding or preceding iterator.\n\nIf the provided iterator models random access, the operation will be constant, even if a custom distance is specified.\n\n#include <vector>\n#include <list>\n#include <iterator>\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7};\n\n// std::prev requires bidirectional iterator\nauto it1 = std::prev(data.end());\n// *it1 == 7\n\n// distance can be customized\nauto it2 = std::next(data.begin(), 3);\n// *it2 == 4\n\nstd::list<int> lst{1, 2, 3, 4, 5, 6, 7};\n\n// for non-random-access iterators the operation is linear\nauto it3 = std::prev(lst.end(), 4);\n// *it3 == 4"
        }
      ],
      "id": "Icu_6VRy",
      "createdAt": 1711975629209,
      "updatedAt": 1711975642065
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Integer literal bases",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Integer literals can be specified in decimal, octal, hexadecimal and since C++14 binary bases.\n\nFurther, since C++14, the single-quote character can be used as a digit separator without changing the value.\n\n// decimal: non-zero decimal digit (1, 2, 3, 4, 5, 6, 7, 8, 9), \n// followed by zero or more decimal digits \n// (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n\nint i = 42;\n\n// octal: digit zero (0) \n// followed by zero or more octal digits (0, 1, 2, 3, 4, 5, 6, 7)\n\nint j = 072; // 58 decimal\n\n// hexadecimal: character sequence 0x or the character sequence 0X \n// followed by one or more hexadecimal digits \n// (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, A, b, B, c, C, d, D, e, E, f, F)\n\nint k = 0XFF; // 255 decimal\n\n// binary: character sequence 0b or the character sequence 0B \n// followed by one or more binary digits (0, 1)\n// since C++14\n\nint l = 0B1101; // 13 decimal\n\n// Digits can be separated using ' for improved readability.\n// since C++14\n\nint m = 1'000'000;"
        }
      ],
      "id": "FT27d06b",
      "createdAt": 1711975646848,
      "updatedAt": 1711975651841
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::quoted",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::quoted is a C++14 utility that simplifies reading and writing quoted strings.\n\nWhen used during stream insertion, it will surround the given string with quotes and escape any internal quotes.\n\nWhen used during stream extraction, the extraction will read the entire quoted string, remove surrounding quotes (if any) and unescape internal quotes.\n\n#include <iostream>\n#include <iomanip>\n\n\nstd::cout << std::quoted(R\"(I say: \"Hello Wordl!\")\") << \"\\n\";\n// prints: \"I say: \\\"Hello World!\\\"\"\n\nstd::stringstream s(R\"(\"I say: \\\"Hello World!\\\"\")\");\nstd::string unescaped;\ns >> std::quoted(unescaped);\n// unescaped == I say: \"Hello World!\"\n\n// Escape and quote characters can be customized.\nstd::cout << std::quoted(\"10|20|30\",'|','#') << \"\\n\";\n// prints: |10#|20#|30|"
        }
      ],
      "id": "C3hXKkr7",
      "createdAt": 1711975656270,
      "updatedAt": 1711975664746
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::async",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++11 std::async is a simple tool for launching asynchronous tasks to either start a task in parallel or to defer execution on the same thread.\n\nThe benefit of std::async is simplicity, as std::async directly returns a std::future; however, we pay for that simplicity with a lack of control.\n\n#include <future>\n#include <thread>\n#include <chrono>\n\nusing namespace std::literals;\n\n// Spawn a task to run asynchronously (in a thread)\nauto result = std::async(std::launch::async,[](){\n    std::this_thread::sleep_for(200ms);\n});\n\n// Wait for the task to finish\nresult.wait();\n\n// std::async returns a std::future\nauto future = std::async(std::launch::async, [](){\n    // Slow operation\n    return 42;\n});\n\n// Block until the result is available and then retrieve it\nauto value = future.get();\n// value == 42\n\n// The deferred policy will execute the packaged task on the thread\n// that call get()/wait().\n{    \nauto deferred = std::async(std::launch::deferred, [](){});\n// Run the task on this thread.\ndeferred.wait();\n}\n{\nauto deferred = std::async(std::launch::deferred, [](){});\n// Nothing prevents us from moving the future to a different thread\nstd::jthread([handle=std::move(deferred)](){\n    handle.wait(); // Run the deferred task in this new thread\n});\n}"
        }
      ],
      "id": "xoCU_gep",
      "createdAt": 1711975686555,
      "updatedAt": 1711975693648
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::as_const",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "One downside of standard views is their behaviour when marked as const.\n\nAs is typical with reference types, views do not respect const. Unfortunately, on top of that, certain combinations of views and ranges require mutability.\n\nWith the C++23 std::views::as_const, we can leave the views mutable while enforcing the immutability of the underlying data.\n\n#include <ranges>\n#include <vector>\n#include <list>\n\nstd::vector<int> rnd_acc{1,2,3,4,5,6};\nstd::list<int> bidir{1,2,3,4,5,6};\n\nconst auto v1 = rnd_acc | std::views::drop(1);\nauto x1 = *v1.begin(); // OK\n*v1.begin() = 42; // Also OK (not respecting const)\n\nconst auto v2 = bidir | std::views::drop(1);\n// auto x2 = *v2.begin();\n// Wouldn't compile, views::drop requires mutability to operate on\n// non-random-access ranges.\n\nauto cview1 = rnd_acc | std::views::as_const | std::views::drop(1);\nauto cview2 = bidir | std::views::as_const | std::views::drop(1);\n\nauto y1 = *cview1.begin(); // OK\nauto y2 = *cview2.begin(); // OK\n\n// *cview1.begin() = 42;\n// Wouldn't compile, can't mutate through const reference."
        }
      ],
      "id": "b3QxWsUM",
      "createdAt": 1711975699097,
      "updatedAt": 1711975709672
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Lambdas capturing ‘this’",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "If we are writing a lambda that requires access to members of an object, we need to capture the parent object (i.e. capture ‘this’).\n\nThe options on how to achieve this have changed in C++17 and C++20, and the interactions with implicit captures [=]{} and [&]{} can be non-obvious.\n\n#include <cassert>\n\nstruct Outer {\n    int x = 42; // member\n    void fun() {\n        int y = 7; // local variable\n\n        [this]{ // capture this by reference\n            this->x = 42; // OK\n            // For the purposes of name lookup, the lambda operator() \n            // belongs to the local scope, i.e. 'this' is Outer.\n            // y not captured\n        }();\n        [*this]{ // C++17 capture by copy\n            assert(x == 42); // x is immutable\n            // y is not captured\n        }();\n        [&]{ // implicitly capture this\n            x = 42; // OK\n            y = 7; // y captured by reference\n        }();\n        [&, this]{ // same as above, explicit spelling\n            x = 42; // OK\n            y = 7; //  y captured by reference\n        }();\n        [&, *this]{ // C++17 capture by copy\n            assert(x == 42); // x is immutable\n            y = 7; // y captured by reference\n        }();\n        [=]{ // deprecated in C++20, confusing implicit capture\n            x = 42; // OK, we capture the 'this' pointer by value\n                    // not the object itself\n            assert(y == 7); // y is immutable\n        }();\n        [=, this]{ // explicit spelling remains valid\n            x = 42;\n            assert(y == 7); // y is immutable\n        }();\n        [=, *this]{ // everything by copy, C++17\n            assert(x == 42); // x is immutable\n            assert(y == 7); // y is immutable\n        }();\n    }\n};"
        }
      ],
      "id": "SK1p_qf8",
      "createdAt": 1711975739725,
      "updatedAt": 1711975746927
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::clamp",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::clamp is a simple C++17 algorithm that clamps a given value between the minimum and maximum thresholds.\n\nIf the value is outside the thresholds, the violated threshold is returned instead.\n\n#include <algorithm>\n\nint min = 0;\nint max = 50;\n\n// if the value is outside of the [min, max] range\n// the corresponding bound is returned instead\nauto x = std::clamp(-20, min, max);\n// x == 0\n\nauto y = std::clamp(70, min, max);\n// y == 50\n\n// if the value is inside the bounds (inclusive)\n// the original value is returned\nauto z = std::clamp(30, min, max);\n// z == 30\n\n// Note: std::clamp is a pass-through function.\n// When passing in temporaries, capturing by result by const-ref\n// can lead to dangling references.\nconst int& w = std::clamp(1, 2, 3); // guaranteed undefined behaviour"
        }
      ],
      "id": "sOvEd_-M",
      "createdAt": 1711975758887,
      "updatedAt": 1711975764676
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::istream_iterator, std::ostream_iterator",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::istream_iterator and std::ostream_iterator are iterator adapters that can iterate over input and output streams, providing an input and output iterator respectively.\n\nCombined with algorithms, this allows for simple streamed processing of files or data streams.\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <vector>\n#include <iomanip>\n\nstruct Prompt {\n  int xcoord;\n  int ycoord;\n  std::string label;\n\n  // Custom input operator implementation:\n  friend std::istream& operator>>(std::istream& s, Prompt& prompt) {\n      s >> prompt.xcoord >> prompt.ycoord \n          >> std::quoted(prompt.label);\n      return s;\n  }\n};\n\n\nconstexpr int min = 0;\nconstexpr int max = 255;\nstd::stringstream in1(\"-20 1 999 255 -42 42\");\nstd::stringstream out;\nstd::transform(\n    // Read integers from in1 stringstream\n    std::istream_iterator<int>(in1),\n    // Until EOF or parsing failure\n    std::istream_iterator<int>(),\n    // Output to out stringstream, delimited by one space\n    std::ostream_iterator<int>(out, \" \"),\n    // Clamp each value to the range [0..255]\n    [min,max](int v) { return std::clamp(v, min, max); });\n// out1.str() == 0 1 255 255 0 42\n\nstd::vector<Prompt> data;\nstd::stringstream in2(R\"(\n    20 10 \"Hello World!\"\n    -1 -5 \"Maybe later?\")\");\nstd::copy(\n    // Read Prompt objects from in2 stringstream\n    std::istream_iterator<Prompt>(in2),\n    // Until EOF or parsing failure\n    std::istream_iterator<Prompt>(),\n    // Insert to vector\n    std::back_inserter(data));\n// data == {{20, 10, \"Hello World\"}, {-1, -5, \"Maybe later?\"}}"
        }
      ],
      "id": "RQZt-KPW",
      "createdAt": 1711975770301,
      "updatedAt": 1711975777032
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::allocator and custom allocators",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Allocators are one of the more esoteric parts of C++.\n\nAll containers rely on allocators, defaulting to std::allocator.\n\nIf we want to use a different allocator, we can specify it as the last template argument.\n\nBecause template arguments are part of the type, the allocator cannot be easily switched when exposing types through API boundaries.\n\n#include <boost/pool/pool_alloc.hpp>\n#include <list>\n\nvoid some_func(const std::list<int>&) {}\n\n// A container with an implicit allocator:\nstd::list<int> list1;\n// Equivalent explicit type:\nstd::list<int, std::allocator<int>> list2;\n// decltype(list1) == decltype(list2)\n\n// Customizing the allocator:\nusing BoostAlloc = boost::fast_pool_allocator<int>;\nstd::list<int, BoostAlloc> list3;\n// Note that boost::pool is not very performant, I would use Intel TBB,\n// but that library is currently bugged in Compiler Explorer.\n\n// decltype(list3) != decltype(list1)\n// some_func(list3); // Wouldn't compile\n\n// The goal of using a pool allocator is to limit \n// the total number of allocations.\n{\nstd::list<int> list;\nfor (size_t i = 0; i < 10'000; ++i) list.push_back(i);\n}\n// 10'000 allocations and deallocations (one for each node)\n\n{\nstd::list<int, BoostAlloc> list;\nfor (size_t i = 0; i < 10'000; ++i) list.push_back(i);\n}\n// ~10 allocations"
        }
      ],
      "id": "-V-2j8pP",
      "createdAt": 1711975785320,
      "updatedAt": 1711975794956
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::accumulate, std::partial_sum",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::accumulate and std::partial_sum are single-range left-fold algorithms.\n\nBoth algorithms operate strictly left-to-right, std::accumulate producing a single value, std::partial_sum emitting all partial results.\n\nDue to the left-to-right operation, these algorithms are less performant than generalized reductions but permit reduction operations with side effects and state.\n\n#include <numeric>\n#include <vector>\n#include <iterator>\n\nstd::vector<int> data{ 1, 2, 3, 4, 5, 6, 7 };\n\n// Both algorithms repeatedly evaluate (left-to-right):\n// 1. accumulator = accumulator + element\n// 2. accumulator = custom_op(accumulator, element)\n\nint res = std::accumulate(data.begin(), data.end(),\n    0, // initial accumulator value, also decides accumulator type\n    [](int acc, int el) {\n        return acc / 2 + el;\n    });\n// res == 12\n\nstd::vector<int> left_fold;\nstd::partial_sum(data.begin(), data.end(),\n    std::back_inserter(left_fold),\n    [](int acc, int el) {\n        return acc / 2 + el;\n    });\n// left_fold == {1, 2, 4, 6, 8, 10, 12}\n\n// The initial value of the accumulator for partial_sum\n// is the first element.\n// This is also the first element of the output.\nstd::vector<int> single{1};\nstd::vector<int> out;\nstd::partial_sum(single.begin(), single.end(),\n    std::back_inserter(out),\n    std::plus<>{});\n// out == {1}\n\n// Right-fold possible for bidirectional ranges using reverse iteration:\nstd::vector<int> right_fold;\nstd::partial_sum(data.rbegin(), data.rend(),\n    std::back_inserter(right_fold),\n    [](int acc, int el) {\n        return acc / 2 + el;\n    });\n// right_fold == {7, 9, 9, 8, 7, 5, 3}"
        }
      ],
      "id": "XytBZfvk",
      "createdAt": 1711975805512,
      "updatedAt": 1711975812343
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Implementing custom allocators",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Allocators allow us to control the memory allocation patterns of standard containers.\n\nPreferably, one should use well-established allocators. However, implementing a custom allocator from scratch is not complicated.\n\nKeep in mind that stateful allocators increase the size of each object that uses this allocator. The Monostate pattern can potentially prevent this overhead.\n\n#include <list>\n#include <string>\n#include <array>\n#include <scoped_allocator>\n\n// Backend storage for our allocator\nstruct StackBuffer {\n    // 512kB buffer\n    alignas(alignof(std::max_align_t)) \n      std::array<std::byte,512*1024> buffer;\n    size_t used = 0;\n\n    // Calculate the required offset for allocating type T\n    // so that T is properly aligned.\n    template <typename T> size_t get_offset() const {\n        if (used % alignof(T) == 0) return 0;\n        return alignof(T) - (used % alignof(T));\n    }\n    // Allocate sizeof(T)*cnt bytes in the buffer, properly aligned.\n    template <typename T> T* allocate(std::size_t cnt) {\n        size_t off = get_offset<T>();\n        if (used + off + cnt*sizeof(T) >= buffer.size())\n            throw std::bad_alloc(); // The buffer is full.\n\n        // Pointer to the start of the allocated block.\n        T* result = reinterpret_cast<T*>(buffer.data()+used+off);\n        used += off + cnt*sizeof(T);\n        return result;\n    }\n    // Deallocation is a no-op.\n    void deallocate(void*, std::size_t) {}\n};\n\n// Our custom allocator\ntemplate <typename T> struct StackAllocator {\n    using value_type = T; // Required\n\n    // We need to initialize the first allocator with\n    // our buffer.\n    StackAllocator(StackBuffer* storage) : storage_(storage) {}\n    StackAllocator(const StackAllocator&) = default;\n    // Conversion constructor that passes the buffer along.\n    template <typename U>\n    StackAllocator(const StackAllocator<U>& other) :\n    storage_(other.storage_) {}\n\n    // Required\n    T* allocate(std::size_t n) {\n        return storage_->allocate<T>(n);\n    }\n    // Required\n    void deallocate(T* p, std::size_t n) {\n        storage_->deallocate(p,n);\n    }\nprivate:\n    // Required for the conversion constructor.\n    template <typename U> friend struct StackAllocator;\n    // Pointer to the buffer, note that this will increase\n    // the size of each container that uses this allocator \n    // by sizeof(StackBuffer*), e.g. 8 bytes on x86-64.\n    StackBuffer* storage_;\n};\n\n\n// String that doesn't fit into small string optimization.\nstd::string_view long_string = \"This is a long enough string.\";\n\n// Create an instance of our buffer, allocating 512kB on the stack.\nStackBuffer buffer;\n\n// Allocator that allocates char.\nusing CharAllocator = StackAllocator<char>;\n// String type that uses use the above allocator.\nusing String = std::basic_string<char, std::char_traits<char>,\n         CharAllocator>;\n\n// Instead of allocating on heap, grabs 30 bytes from our buffer.\nString string_that_allocates(long_string, CharAllocator(&buffer));\n// With class template decuction, this gets more reasonable.\nstd::basic_string string_ctad(long_string, CharAllocator(&buffer));\n// decltype(string_that_allocates) == decltype(string_ctad)\n\n// Allocator that allocates the above String.\nusing StringAllocator = StackAllocator<String>;\n\n// When we use nested containers, we would normally\n// have to manually pass in the allocator.\nstd::list<String, StringAllocator> manual{StringAllocator(&buffer)};\n// Two allocations:\n// 30 bytes for the string\n// 56 bytes for the node (sizeof(std::string)+Allocator+Next+Prev)\nmanual.emplace_back(long_string, CharAllocator(&buffer));\n// Note that despite passing in an allocator for String, the list\n// actually uses a converted allocator that allocates nodes.\n\n// However, the std::scoped_allocator_adaptor can do this for us:\nusing ThroughAllocator = \n  std::scoped_allocator_adaptor<StackAllocator<String>>;\n\nstd::list<String, ThroughAllocator>\n automatic{ThroughAllocator(&buffer)};\nautomatic.emplace_back(long_string);\n// Note that the emplace is important here as it creates the object\n// in place, a push_back would create the string on the call site.\n\n// Wouldn't compile:\n// automatic.push_back(long_string);"
        }
      ],
      "id": "vfmK4tjh",
      "createdAt": 1711975827201,
      "updatedAt": 1711975837528
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::join_with",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::views::join_with will, similar to std::views::join, flatten a range of ranges but will additionally insert the provided element in between every pair of sub-ranges.\n\n#include <ranges> \n#include <string>\n#include <vector>\n\nstd::vector<std::vector<int>> data = {{1,2,3}, {4,5,6}, {7,8,9}};\n\n// A flattened view of data with 0 inserted in between every subrange\nauto flattened = data | std::views::join_with(0) | std::views::common;\n\nstd::vector<int> flat(flattened.begin(), flattened.end());\n// flat == {1,2,3,0,4,5,6,0,7,8,9}\n\n\nstd::string greeting = \"Hello World!\";\n\n// Split by space and re-join using newlines\nauto lined = greeting | std::views::lazy_split(' ') | \n    std::views::join_with('\\n') | std::views::common;\n\nstd::string new_greeting(lined.begin(), lined.end());\n// new_greeting == \"Hello\\nWorld!\";"
        }
      ],
      "id": "j0wtTUI9",
      "createdAt": 1711975854532,
      "updatedAt": 1711975858636
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "C++17 constexpr if",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++17 constexpr if replaces most cases where macros would have to be used.\n\nIt also simplifies generic functions and metaprogramming and works with C++20 concepts to allow code to adjust based on features supported by the type of the function arguments.\n\n#include <ranges>\n\nconstexpr inline bool feature_x24_enabled = true;\n\n// Macro replacement\nvoid some_function() {\n    if constexpr (feature_x24_enabled) {\n        // something special for feature x24\n    }\n}\n\n// Function returning different types based on type of argument\nauto generic_function(auto x) {\n    if constexpr (std::is_integral_v<decltype(x)>) {\n        // argument integral -> returns std::string\n        return std::to_string(x);\n    } else if constexpr (std::is_floating_point_v<decltype(x)>) {\n        // argument floting point type -> returns int64_t\n        return static_cast<int64_t>(x);\n    } else {\n        // otherwise return void\n        return;\n    }\n}\n\n// Works with C++20 concepts:\nvoid custom_algorithm(auto&& rng) {\n    using type = decltype(rng);\n    if constexpr (std::ranges::random_access_range<type>) {\n        // implementation for random_access_range\n    } else if constexpr (std::ranges::bidirectional_range<type>) {\n        // implementation for bidirectional_range\n    } else {\n        // fallback implementation\n    }\n}"
        }
      ],
      "id": "-187gUo3",
      "createdAt": 1711975863816,
      "updatedAt": 1711975871632
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::this_thread",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++11 std::this_thread is a namespace in the <thread> header that contains functions for querying the current thread id and yielding the current thread execution.\n\nNote that the actual behaviour of yield, sleep_for and sleep_until very much depends on the thread library and OS scheduler.\n\n#include <thread>\n#include <chrono>\n#include <iostream>\n\n// Print the current thread id\nstd::cout << std::this_thread::get_id() << \"\\n\";  \n\n// Yield execution of this thread,\n// allowing other threads to run\nstd::this_thread::yield();\n\nusing namespace std::chrono;\n// Yield execution of this thread for\n// at least the specified duration\nstd::this_thread::sleep_for(240ms);\n// Yield execution of this thread until\n// at least the specified time point\nstd::this_thread::sleep_until(steady_clock::now() + 1s);"
        }
      ],
      "id": "bnZYCfD7",
      "createdAt": 1711975882995,
      "updatedAt": 1711975888367
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::ranges::find_last, std::ranges::find_last_if, std::ranges::find_last_if_not",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The trio of std::ranges::find_last, std::ranges::find_last_if and std::ranges::find_last_if_not are C++23 algorithms that find the last element matching the provided value or predicate.\n\nWhile we could use std::ranges::find on bidirectional ranges with the same effect, these variants can operate on forward ranges.\n\n#include <forward_list>\n#include <algorithm>\n#include <ranges>\n\n\nstd::forward_list<int> data{1,2,3,4,5,6,7};\n{\nauto [it, end] = std::ranges::find_last(data, 5);\n// *it == 5, end == data.end()\nstd::cout << \"*it == \" << *it << \"\\n\";\n}\n\nauto is_even = [](int v) { return v % 2 == 0; };\n{\nauto [it, end] = std::ranges::find_last_if(data, is_even);\n// *it == 6, end == data.end()\nstd::cout << \"*it == \" << *it << \"\\n\";\n}\n\n// the calculated end is useful when working with lazy ranges\n{\nauto counted = std::views::counted(data.begin(), 5);\nauto [it, end] = std::ranges::find_last_if(counted, is_even);\n// *it == 4, *end == 6\nstd::cout << \"*it == \" << *it << \"\\n\";\nstd::cout << \"*end == \" << *end << \"\\n\";    \n}"
        }
      ],
      "id": "_l1dI5Lz",
      "createdAt": 1711975896324,
      "updatedAt": 1711975903133
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Raw string literals",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Raw string literals (introduced in C++11) simplify the inclusion of multi-line text and strings that contain special characters that would otherwise have to be escaped.\n\n#include <string_view>\n\n// R prefix followed by \"( closed by )\"\nstd::string_view a = R\"(c:\\some\\file\\path)\";\n// c:\\some\\file\\path\n\n// Optionally, an identifier can be included,\n// to allow for a )\" substring\nstd::string_view b = R\"some_data(R\"(this is a raw string)\")some_data\";\n// R\"(this is a raw string)\"\n\nstd::string_view c = R\"(When\nusing multi-line raw strings\n    any leading space and newline characters\n  will be part of the string)\";"
        }
      ],
      "id": "JRuG1Hq8",
      "createdAt": 1711975910412,
      "updatedAt": 1711975915740
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::move_only_function",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::move_only_function is a move-only version of std::function.\n\nApart from allowing for non-copyable function objects, the std::move_only_function fully supports invocable semantics and respects const.\n\n#include <functional>\n#include <memory>\n\nstruct X {\n    void operation(int) {};\n    int x;\n};\n\n// Will not compile, lambda not copy constructible\n// because anchor is not copy constructible.\n// std::function<void(void)> a = \n//   [anchor=std::make_unique<int>(42)](){};\n\n// OK\nstd::move_only_function<void(void)> b = \n  [anchor=std::make_unique<int>(42)](){};\n\n\n// invocable support\n// Note that the type is as-if it was a regular function,\n// lookup \"Abominable Function Types\" for additional context.\nstd::move_only_function<void (X&, int)> c = &X::operation;\nstd::move_only_function<int (X&)> d = &X::x;\n\nX x;\nc(x, 42); // invokes x.operation(42);\nint y = d(x); // same as int y = x.x;\n\n// respects const\nconst std::move_only_function<void(void)> e = [](){};\n// e(); // will not compile, can store,\n        // but not invoke a non-const functions\nconst std::move_only_function<void(void) const> f = [](){};\nf(); // OK"
        }
      ],
      "id": "RMKW_2GP",
      "createdAt": 1711975921547,
      "updatedAt": 1711975925679
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::zip_transform",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::views::zip_transform is a view where the ith element results from applying the n-ary transformation invocable to the ith elements of the provided ranges.\n\nThe view is a lazy version of binary std::ranges::transform, generalized for any number of ranges.\n\n#include <ranges>\n#include <vector>\n\n\nstd::vector<int> first{1,2,3,4};\nstd::vector<double> second{9.1, 9.2, 9.3, 9.4, 9.5};\nstd::vector<std::string> third{\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n// transform function takes one element from every range\nauto zip = [](int& a, double& b, std::string& c) {\n    return a+b+(c[0]-'a');\n};\n// produce a view where the i-th element is the result of applying\n// the transformation function the i-th elements of the provided ranges\n// the length is determined by the shortest of the ranges\nfor (auto v : std::views::zip_transform(zip, first,second,third)) {\n    // iterate over: 10.1, 12.2, 14.3, 16.4\n}"
        }
      ],
      "id": "gWoI_usT",
      "createdAt": 1711975938013,
      "updatedAt": 1711975943761
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::function",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::function is a storage type that can store callable entities (functions, function objects, lambdas) that conform to the specified call signature.\n\nThe container is copyable (which it also requires of the wrapped object) and will throw when invoked without a stored state.\n\n#include <functional>\n#include <numeric>\n#include <algorithm>\n\ndouble sum(const std::vector<double>& data) {\n    return std::accumulate(data.begin(), data.end(), 0.);\n}\n\n\nstd::vector<double> data = {0.5, 1.0, 2.3};\n\nstd::function<double(const std::vector<double>&)> fn;\ntry {\n    fn(data); // Throws std::bad_function_call because empty.\n} catch (...) {}\n\n\n// Store a function in fn\nfn = sum;\nauto res1 = fn(data);\n// res1 == 3.8\n\n\n// Store a capturing lambda in fn\nint offset = 3;\nfn = [offset](const std::vector<double>& v) {\n    return std::ranges::max(v) + offset;\n};\nauto res2 = fn(data);\n// res2 == 5.3\n\n\n// Note, that despite following value semantics, \n// std::function doesn't respect const\nstruct Fun { int x = 0; void operator()() { ++x; } };\n\nconst Fun fun;\n// fun(); // will not compile, would discard const\n\nconst std::function<void()> mutates = Fun{};\nmutates(); // OK\n// mutates.target<Fun>()->x == 1"
        }
      ],
      "id": "rBRtzdoi",
      "createdAt": 1711975949318,
      "updatedAt": 1711975957156
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "projections in C++20 range algorithms",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Support for projections is one of the improvements introduced with the C++20 range versions of standard algorithms.\n\nProjections are applied before elements are passed to the corresponding invocable.\n\nAlgorithms that operate on multiple source ranges provide a separate projection for each range.\n\nNote that taking an address of standard functions (including members) is undefined behaviour.\n\n#include <ranges>\n#include <algorithm>\n#include <vector>\n\nstruct User {\n    int64_t id;\n    std::string name;\n};\n\nusing namespace std::literals;\n\nstd::vector<User> users{{37,\"Eliana Green\"}, {23, \"Logan Sterling\"},\n                        {1, \"Isla Bennett\"}, {7, \"Marcel Jones\"}};\n\n// Sort users by id (any invocable will work)\nstd::ranges::sort(users, {}, &User::id);\n// {} instantiates the default comparator: std::ranges::less\n// std::ranges::sort(users, std::ranges::less{}, &User::id);\n\n// users == {{1,\"Isla...\"}, {7,\"Marcel...\"},\n//           {23,\"Logan...\"}, {37,\"Eliana...\"}}\n\n// Find by name\nauto it = std::ranges::find(users, \"Eliana Green\"s, &User::name);\n// it->id == 37, it->name == \"Eliana Green\"\n\nstd::vector<int> first{1,2,3,4,5};\nstd::vector<int> second{1,2,3,4,5};\nstd::vector<int> out;\n\nstd::ranges::transform(first, second, std::back_inserter(out), \n    [](int left, int right) { return left * right; }, // transformation\n    [](int left) { return left + 10; },   // projection, first range\n    [](int right) { return right / 2; }); // projection, second range\n// out == 0 (11*0), 12 (12*1), 13 (13*1), 28 (14*2), 30 (15*2)"
        }
      ],
      "id": "picJWCOC",
      "createdAt": 1711975959479,
      "updatedAt": 1711975973955
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::transform",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 std::views::transform can be used to lazily produce a range of transformed elements, including the possibility of changing the range’s element type.\n\n#include <vector>\n#include <ranges>\n\n\nstd::vector<int> data{1,2,3,4,5};\n\n// produce a view of squared values\nconstexpr auto square = \n  std::views::transform([](int v) { return v * v; });\nfor (int v : data | square) {\n    // iterate over: 1,4,9,16,25\n}\n\nconstexpr auto as_strings = \n  std::views::transform([](int v) { return std::to_string(v); });\n// views::transform can produce a view with a different element type\nfor (std::string v : data | as_strings) {\n    // iterate over: \"1\"s,\"2\"s,\"3\"s,\"4\"s,\"5\"s\n}"
        }
      ],
      "id": "1SdDcsFI",
      "createdAt": 1711975981166,
      "updatedAt": 1711975984913
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Singleton pattern",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Singletons should be avoided if possible, as they introduce a hurdle for testing. However, sometimes a global state might be the least bad choice.\n\nIf you need a Singleton, use a simple getter function that returns a reference to a local static variable.\n\nBlock-scope static variables are initialized in a thread-safe and exception-safe manner.\n\nstruct GlobalData {\n    int state;\nprivate:\n    // Optional: prevent GlobalData to be constructible\n    // outside of get_global_data()\n    GlobalData(int state) : state(state) {}\n    friend GlobalData& get_global_data();\n};\n\n// a.k.a. Scott Meyer's singleton\nGlobalData& get_global_data() {\n    // Static block-scope variables have static storage duration\n    // and are initialized on the first time the control passes\n    // through the declaration in a thread-safe manner.\n    static GlobalData storage{42};\n    return storage;\n\n    // Note: if the initialization throws, it will be re-attempted \n    // on the next pass-through.\n}\n\n// get_global_data().state == 42"
        }
      ],
      "id": "HSM5MhNk",
      "createdAt": 1711975989400,
      "updatedAt": 1711975995282
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::ranges::fold_left_with_iter, std::ranges::fold_left_first_with_iter",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::ranges::fold_left_with_iter and std::ranges::fold_left_first_with_iter are alternative versions of the fold_left algorithms that additionally return the computed end iterator.\n\nThis comes in handy in cases where the range is terminated using a sentinel. The computed end iterator can then be re-used and doesn’t have to be re-calculated.\n\n#include <algorithm>\n#include <vector>\n#include <ranges>\n#include <concepts>\n\n// Utility to get the absolute base of a nested iterator type\ntemplate <typename T> auto absolute_base(T t) { \n    if constexpr (requires (T t) {\n        { t.base() } -> std::same_as<typename T::iterator_type>;\n    }) return absolute_base(t.base()); else return t;\n}\n\n\nstd::vector<int> data{1,2,3,4,5,6,7,8,9};\n\n// a view without the last 3 elements\nconstexpr auto view = std::views::reverse | std::views::drop(3) |\n  std::views::reverse;\nauto [it, value] = std::ranges::fold_left_with_iter(data | view,\n                                                    0, std::plus<>{});\n// value == 21 (0+1+2+3+4+5+6)\n\n// \"it\" is a reverse iterator of a reverse iterator, we can't do:\n// it == data.end(), but we can do absolute_base(it) == data.end()\nfor (auto v : std::ranges::subrange(absolute_base(it), data.end())) {\n    // process the rest of the range\n    // iterate over {7, 8, 9}\n}"
        }
      ],
      "id": "GCG3U3iS",
      "createdAt": 1711976002472,
      "updatedAt": 1711976009512
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::enumerate",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The range-for-loop is a very convenient replacement for the C-style for-loop.\n\nHowever, range-for-loop can be cumbersome when accessing the original index or computing a target index.\n\nThe C++23 std::views::enumerate removes this problem by producing a range of tuples, where the i-th tuple consists of the value i and a reference to the i-th element of the source range.\n\n#include <vector>\n#include <ranges>\n\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7};\n\n// Applying enumerate before other views to inject original indexes\nconstexpr auto before = std::views::enumerate | \n    std::views::filter([](auto t) {\n        return std::get<1>(t) % 2 == 0;\n    });\nfor (auto [idx, value] : data | before) {\n    // Iterate over: {1,2}, {3,4}, {5,6}\n}\n\n// Applying enumerate after other views to index the resuling range\nconstexpr auto after = std::views::filter([](int v) { \n    return v % 2 == 0;\n}) | std::views::enumerate;\nfor (auto [idx, value] : data | after) {\n    // Iterate over: {0,2}, {1,4}, {2,6}\n}\n\n// Since the second element of the tuple is a reference,\n// we maintain mutability\nfor (auto [idx, value] : data | std::views::enumerate) {\n    value -= idx;\n}\n// data == {1,1,1,1,1,1,1}"
        }
      ],
      "id": "Nk7dEifO",
      "createdAt": 1711976015789,
      "updatedAt": 1711976023632
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::find, std::find_if, std::find_if_not",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The trio of find algorithms: std::find, std::find_if and std::find_if_not, return an iterator to the first element in a range that satisfies the given criteria.\n\nAll three algorithms have std::ranges variants.\n\n#include <algorithm>\n#include <vector>\n#include <functional>\n\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7};\n\n// Find by value\nauto it = std::find(data.begin(), data.end(), 5);\n// *it == 5\nit = std::find(data.begin(), data.end(), 42);  \n// it == data.end()\n\n// Find using a predicate\nauto is_even = [](int v) { return v % 2 == 0; };\nit = std::find_if(data.begin(), data.end(), is_even);\n// *it == 2\n\n// Find using a negation of a predicate\nit = std::find_if_not(data.begin(), data.end(), is_even);\n// *it == 1\n\n// same as\nit = std::find_if(data.begin(), data.end(), std::not_fn(is_even));\n// *it == 1"
        }
      ],
      "id": "Bm9XgUdR",
      "createdAt": 1711976028228,
      "updatedAt": 1711976033023
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::keys, std::views::values",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 std::views::keys and std::views::values are specialized views that represent the views over the keys and values of associate containers.\n\nReminder: for std::set and std::unordered_set (and their multi-variants), the elements are keys, not values.\n\n#include <unordered_map>\n#include <ranges>\n\nint main() {\n    std::unordered_map<int,int> data{{1,7}, {2,8}, {3,9}};\n\n    for (const auto &v : data | std::views::keys) {\n        // iterate over 1, 2, 3\n    }\n\n    for (const auto &v : data | std::views::values) {\n        // iterate over 7, 8, 9\n    }\n}"
        }
      ],
      "id": "JBKEcLJC",
      "createdAt": 1711976038740,
      "updatedAt": 1711976044141
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::endian",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::endian from C++20 is an enum in the <bit> header that provides information about the native endianness of the architecture the program was compiled for.\n\n#include <bit>\n#include <iostream>\n\nint main() {\n    if constexpr (std::endian::native == std::endian::little) {\n        std::cout << \"This system is little-endian.\\n\";\n    } else if constexpr (std::endian::native == std::endian::big) {\n        std::cout << \"This system is big-endian.\\n\";\n    }\n}"
        }
      ],
      "id": "3ULyPcgg",
      "createdAt": 1711976051095,
      "updatedAt": 1711976054389
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "[[no_unique_address]]",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced the [[no_unique_address]] attribute that can be used to annotate non-static data members.\n\nThe attribute allows the compiler to optimize empty members marked with this attribute to take up no space.\n\n#include <utility>\n\nstruct Empty {};\n\nstruct Bigger {\n    int value;\n    // Even though empty, has to take up at least one byte.\n    Empty empty;\n};\n\nstruct SameAsInt {\n    int value;\n    // Allowed to overlap.\n    [[no_unique_address]] Empty empty;\n};\n\nint main() {\n    static_assert(sizeof(Empty) >= 1);\n    static_assert(sizeof(Bigger) >= sizeof(int) + 1);\n    static_assert(sizeof(SameAsInt) == sizeof(int));\n}"
        }
      ],
      "id": "yYiUGmVv",
      "createdAt": 1711976058687,
      "updatedAt": 1711976063300
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::adjacent, std::views::pairwise",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::views::adjacent is a view similar to std::views::slide, producing a sliding window over the input range. However, where std::views::slide produces subranges, std::views::adjacent produces tuples of references to elements.\n\nConsequently, the elements of std::views::adjacent can be deconstructed using structured binding.\n\nThe std::views::adjacent<2> has an alias in std::views::pairwise.\n\n#include <ranges>\n#include <vector>\n\n\nstd::vector<int> data{1,2,3,4,5};\n\n// \"sliding tuple\" of references to elements\nfor (std::tuple<int&,int&,int&> v : data | std::views::adjacent<3>) {\n // iterate over {1,2,3}, {2,3,4}, {3,4,5}\n}\n\n// deconstructed using structured binding\nfor (auto [first, second, third] : data | std::views::adjacent<3>) {\n // iterate over {1,2,3}, {2,3,4}, {3,4,5}\n}\n\n// std::views::adjacent<2> has an alias\nfor (auto [left, right] : data | std::views::pairwise) {\n    // iterate over {1,2}, {2,3}, {3,4}, {4,5}\n}"
        }
      ],
      "id": "W8q4qZak",
      "createdAt": 1711976067509,
      "updatedAt": 1711976072731
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "ranges::fold_left, ranges::fold_left_first, ranges::fold_right, ranges::fold_right_last",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 introduced a set of range-enabled fold algorithms to replace the std::accumulate numeric algorithm.\n\nThe library provides both left and right folds: std::ranges::fold_left and std::ranges::fold_right.\n\nAs well as variants that use the first/last elements as initializers: std::ranges::fold_left_first and std::ranges::fold_right_last.\n\n#include <algorithm>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> data{1,2,3,4,5,6};\n\n// Left fold, with initial value.  \nauto v = std::ranges::fold_left(data, 10, std::plus<>{});\n// Unlike with std::accumulate, the result type is based\n// on the invocation result of operation(init, elem).\n// decltype(v) == int64_t, v == 31\n\n// Right fold, using the last element as initializer.\nauto w = std::ranges::fold_right_last(data, std::plus<>{});\n// The result is a std::optional to accomodate empty ranges.\n// decltype(w) == std::optional<int64_t>, w == 21\n\nstd::vector<int64_t> empty;\n// Left fold, using the first element as initializer.\nauto z = std::ranges::fold_left_first(empty, std::plus<>{});\n// z.has_value() == false"
        }
      ],
      "id": "OAm7Munu",
      "createdAt": 1711976077965,
      "updatedAt": 1711976083000
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::lower_bound, std::upper_bound",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The two arguably most important algorithms in the standard library are the divide and conquer std::lower_bound and std::upper_bound.\n\nThese algorithms provide O(logn) boundary lookup on sorted random-access ranges.\n\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> data{1,2,3,4,5,5,5,6,7,8,9};\n\n// First element for which el < value == false\nauto lb = std::ranges::lower_bound(data, 5);\n\n// First element for which value < el == true\nauto ub = std::ranges::upper_bound(data, 5);\n\n// [begin, lb) forms the subrange of elements lower than value\n// std::ranges::subrange(data.begin(), lb) == {1, 2, 3, 4}\n\n// [lb, ub) forms the subrange of elements equal to the value\n// std::ranges::subrange(lb, ub) == {5, 5, 5}\n\n// [ub, end) forms the subrange of elements higher than the value\n// std::ranges::subrange(ub, data.end()) == {6, 7, 8, 9}"
        }
      ],
      "id": "hoonVLUa",
      "createdAt": 1711976096811,
      "updatedAt": 1711976102030
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::ranges::contains, std::ranges::contains_subrange",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++23 introduced two new algorithms in the ranges namespace.\n\n    std::ranges::contains\n    std::ranges::contains_subrange\n\nThese two algorithms do not introduce novel behaviour; instead, they remove the need to translate the results of std::ranges::find and std::ranges::search.\n\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> data{1,2,3,4,5,6,7,8,9};\n\nbool r1 = std::ranges::contains(data, 5);\n// r1 == true\n// Same as:\nbool r2 = std::ranges::find(data, 5) != data.end();\n// r2 == true\n\nbool r3 = std::ranges::contains_subrange(data, auto({3,4,5}));\n// r3 == true\n// Same as:\nbool r4 = not std::ranges::search(data, auto({3,4,5})).empty();\n// r4 == true"
        }
      ],
      "id": "_tf2RVQk",
      "createdAt": 1711976107615,
      "updatedAt": 1711976113828
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Type tagging",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "One option to distinguish two function calls that would otherwise fully overlap in their argument types is using type tagging.\n\nThis technique is particularly useful for constructors since constructors cannot be renamed.\n\n#include <string_view>\n\n// Tags\nstruct IPv4_t{};\nstruct IPv6_t{};\n\n// Instances of tags\nconstexpr inline IPv4_t IPv4 = {};\nconstexpr inline IPv6_t IPv6 = {};\n\nstruct IPAddr {\n    // First argument is the tag to distinguish the overloads\n    IPAddr(IPv4_t, std::string_view addr, int port) {}\n    IPAddr(IPv6_t, std::string_view addr, int port) {}\n};\n\n// Calling the tagged functions\nIPAddr addr1(IPv4, \"127.0.0.1\", 80);\nIPAddr addr2(IPv6, \"::1\", 80);"
        }
      ],
      "id": "uuF2wXE1",
      "createdAt": 1711976171754,
      "updatedAt": 1711976177023
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Dependency injection",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Dependency injection is a simple design pattern that decouples a component from its dependency.\n\nWhile the pattern introduces a virtual dispatch (with its runtime cost), its simplicity and effect on testability are usually worth it.\n\n#include <memory>\n\nstruct Service { // Base interface\n    virtual void make_important_call() = 0;\n};\n\nstruct FakeService : Service { // Fake implementation for testing\n    void make_important_call() override {}\n};\n\nstruct ProductionService : Service { // Real implementation\n    void make_important_call() override {}\n};\n\nstruct MyClass {\n    MyClass(std::unique_ptr<Service> service) : // Inject dependency\n        dependency_(std::move(service)) {}\n\n    void operate() {\n        dependency_->make_important_call();\n    }\nprivate:\n    std::unique_ptr<Service> dependency_;\n};\n\n// In production code:\nMyClass m(std::make_unique<ProductionService>());\nm.operate(); // calls ProductionService::make_important_call()\n\n// In test code:\nMyClass n(std::make_unique<FakeService>());\nn.operate(); // calls FakeService::make_important_call()"
        }
      ],
      "id": "o6GeieXo",
      "createdAt": 1711976184015,
      "updatedAt": 1711976204164
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::zip",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::views::zip produces a view of tuple-like elements, each consisting of the corresponding elements from all the adapted views.\n\nThe shortest range determines the number of elements in the view.\n\nThe elements of the view maintain reference semantics, meaning that if the arguments are mutable ranges, their elements can be mutated through the elements of this view.\n\n#include <algorithm>\n#include <vector>\n#include <ranges>\n\n\nstd::vector<int> first{1,2,3,4,5};\nstd::vector<double> second{9,8,7,6};\n\n// Iterate over the elements of the zip view\nfor (auto [a, b] : std::views::zip(first, second)) {\n    // {1,9}, {2,8}, {3,7}, {4,6}\n}\n\n// Same as above, without structured binding\nfor (std::tuple<int&,double&> el : std::views::zip(first, second)) {\n    // {1,9}, {2,8}, {3,7}, {4,6}\n}\n\nstd::vector<std::string> third{\"label1\", \"label2\", \"label3\"};\n\n// The zip view can accept one or more arguments\nfor (auto [a, b, c] : std::views::zip(first, second, third)) {\n    // {1,9,\"label1\"}, {2,8,\"label2\"}, {3,7,\"label3\"}\n}\n\n// We can also modify the original ranges through the tuple\nfor (auto [a, b, c] : std::views::zip(first, second, third)) {\n    a = a + b;\n}\n// first == {10, 10, 10, 4, 5}"
        }
      ],
      "id": "zGcBN6CZ",
      "createdAt": 1711976210258,
      "updatedAt": 1711976213859
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::transform",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::transform algorithm has two major use cases:\n\n    copy elements from one range to another, applying a transformation to each element (potentially changing type)\n    reduce two ranges into one range\n\nThe output range is permitted to be either of the input ranges, however, do take care with expensive copies.\n\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <iterator>\n\n// Copy with a transformation:\nstd::vector<int> in{1, 2, 3, 4, 5, 6, 7};\nstd::vector<double> out;\n\nstd::transform(in.begin(), in.end(),\n    std::back_inserter(out),\n    [](int v) { return static_cast<double>(v)/2; });\n// out ~= {0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5}\n\n\n// Reduce two ranges into one:\nstd::vector<int> in1{1, 2, 3, 4, 5};\nstd::vector<int> in2{0, 1, 0, 1, 0};\nstd::vector<int> reduction;\n\nstd::transform(in1.begin(), in1.end(), // first range\n    in2.begin(), // second range, number of elements from first range\n    std::back_inserter(reduction),\n    [](int e1, int e2) { return e1*e2; });\n// reduction == {0, 2, 0, 4, 0}\n\n\n// The output range can be one of the input ranges:\nstd::string str = \"welcome to somewhere\";\nstd::transform(str.begin(), str.end(), // input range\n    str.begin(), // Note, can't be offset (only r1.begin(), r2.begin())\n    [](char c) { return std::toupper(c); });\n// str == \"WELCOME TO SOMEWHERE\"\n\n\n// Take care when working with expensive to copy types.\nstruct Expensive{};\nstd::vector<Expensive> data(10);\nstd::transform(data.begin(), data.end(),\n    data.begin(),\n    [](const Expensive& v) { return v; }); // copy\n// To modify element in-place, use std::for_each or a range-for."
        }
      ],
      "id": "xu0tmyI7",
      "createdAt": 1711976218006,
      "updatedAt": 1711976223218
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "[[nodiscard]] attribute",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++17 introduced the [[nodiscard]] attribute that triggers a compiler warning when the result of a function call is discarded.\n\nAt a minimum, this attribute should be used for functions that are expensive to run and query functions that might be confused with their action counterparts.\n\nstruct MyStruct {\n    [[nodiscard]] ExpensiveResult expensive_call();\n};\n\nstruct CustomVector {\n    // C++20 - optional string that will be included in the error\n    [[nodiscard(\"Did you mean to call clear()?\")]]\n    bool empty() const;\n};\n\n\nMyStruct x;\nx.expensive_call();\n// warning: ignoring return value of \n// 'ExpensiveResult MyStruct::expensive_call()', \n// declared with attribute 'nodiscard'\n\nCustomVector y;\ny.empty();\n// warning: ignoring return value of \n// 'bool CustomVector::empty() const', \n// declared with attribute 'nodiscard': 'Did you mean to call clear()?'"
        }
      ],
      "id": "DstL6nMX",
      "createdAt": 1711976227997,
      "updatedAt": 1711976232596
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "override specifier",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The override specifier (C++11) denotes a virtual method intended to override.\n\nIf the compiler does not find a corresponding virtual method in one of the base classes, it will treat the override specifier as an error.\n\nFollow this guideline (see C.128 in Core Guidelines):\n\n    when introducing a new virtual method, use only the virtual keyword\n    when overriding an existing method, use only the override specifier\n\nstruct Base {\n    virtual void method() {}\n};\n\nstruct Derived : Base {\n    // OK, matching virtual method in the Base\n    void method() override {}\n    // Will not compile, cv-qual does not match\n    void method() const override {}\n\n    // OK, introducing a new method\n    virtual void another() {}\n    // Will not compile, accidentally introducing a new method\n    void yet_another() override {}\n};"
        }
      ],
      "id": "Aqnwgd9h",
      "createdAt": 1711976236903,
      "updatedAt": 1711976246695
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Accessing content of std::optional",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::optional (C++17) offers several interfaces to access the contained value.\n\nThe choice depends on your coding style and your desired exception semantics.\n\n#include <optional>\n\nstruct Data {\n    void method() {}\n    int v;\n};\n\n\nstd::optional<Data> x{Data{1}};\n\n// Pointer-style noexcept interface\nif (x != std::nullopt) {\n    x->method();\n    auto y = *x;\n    // decltype(y) == Data\n    // y.v == 1\n}\n\n// Explicit throwing interface\nif (x.has_value()) {\n    auto y = x.value(); // throws bad_optional_access if empty\n    // decltype(y) == Data\n    // y.v == 1\n}\n\n// Default-value interface, throws only if construction of the\n// contained type throws\nauto y = x.value_or(Data{2});\n// y.v == 1\n\nx = std::nullopt; // or x.reset();\nauto z = x.value_or(Data{2});\n// z.v == 2"
        }
      ],
      "id": "4Y775w2s",
      "createdAt": 1711976267989,
      "updatedAt": 1711976272791
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Inline namespace",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++11 inline namespaces are invisible to code but affect symbol names.\n\nThis makes them a great tool for versioning symbols when introducing ABI-breaking changes.\n\n#include <iostream>\n\nnamespace Library {\n    inline namespace v2 {\n        void function();\n    }\n    // implicit \"using namespace v2;\"\n}\n\nint main() {\n    Library::function(); // Will use Library::v2::function();\n    // prints: \"Hello World! v2\"\n}\n\n// Library implementation:\n\n// Older versions can be kept around (if possible), keeping binary\n// compatibility. \n// If removed, compiling against old header with new binary will\n// result in linker error.\nnamespace Library {\n    inline namespace v1 {\n        void function() {\n            std::cout << \"Hello World! v1\\n\";\n        }\n    }\n    inline namespace v2 {\n        void function() {\n            std::cout << \"Hello World! v2\\n\";\n        }\n    }\n}"
        }
      ],
      "id": "kn_z7xn4",
      "createdAt": 1711976277498,
      "updatedAt": 1711976283548
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::chunk",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::views::chunk is a simple view that will produce a view of sub-ranges spanning the provided number of elements each.\n\nIf the range cannot be divided without a remainder, the last sub-range will contain the remainder (and therefore fewer) elements.\n\n#include <vector>\n#include <ranges>\n\n\nstd::vector<int> data{1,2,3,4,5,6,7,8,9};\n\n// Iterate over chunks of size 4 (and one chunk of size 1)\nfor (const auto& chunk : data | std::views::chunk(4)) {\n    for (int v : chunk) {\n        // Iterate over elements\n    }\n}\n\nstd::vector<int> cube(27,0);\n\n// Can be used to iterate multi-dimensional data stored as 1D\nfor (const auto &slice : cube | std::views::chunk(3)) {\n    for (const auto &row : slice | std::views::chunk(3)) {\n        for (const auto &el : row) {\n            // iterate over all elements\n        }\n    }\n}"
        }
      ],
      "id": "c0PpdqH6",
      "createdAt": 1711976311399,
      "updatedAt": 1711976316808
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::current_exception, std::exception_ptr, std::rethrow_exception",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When implementing coroutines, we must decide how we want to handle exceptions.\n\nOne option is to ignore exceptions and have the unhandled_exception() method terminate.\n\nAlternatively, we can use the C++11 exception storing and re-throwing support:\n\n    std::current_exception\n    std::exception_ptr\n    std::rethrow_exception\n\n#include <iostream>\n#include <coroutine>\n#include <exception>\n\ntemplate <typename Result>\nstruct Promise;\n\n// Result type\ntemplate <typename Result>\nstruct Task : std::coroutine_handle<Promise<Result>> {\n    using promise_type = Promise<Result>;\n\n    ~Task() { this->destroy(); }\n    \n    Result& get_value() {\n     // if the coroutine ended with exception, rethrow\n        if (this->promise().exception_)\n            std::rethrow_exception(this->promise().exception_);\n        // otherwise, return the result\n        return this->promise().value_;\n    }\n};\n\n// Promise type\ntemplate <typename Result>\nstruct Promise {\n    Task<Result> get_return_object() { \n     return {Task<Result>::from_promise(*this)}; \n    }\n    std::suspend_always initial_suspend() noexcept { return {}; }\n    std::suspend_always final_suspend() noexcept { return {}; }\n\n    void return_value(auto&& val) { // store the result\n        value_ = std::forward<decltype(val)>(val);\n    }\n    void unhandled_exception() { // store the exception\n        exception_ = std::current_exception();\n    }\n    \n    Result value_;\n    std::exception_ptr exception_;\n};\n\nTask<int> coro_success() {\n    co_return 1;\n}\n\nTask<int> coro_throws() {\n    throw std::runtime_error(\"Failed.\");\n    co_return 2;\n}\n\n\ntry {\n    auto c1 = coro_success();\n    c1.resume(); // let the coroutine run\n    std::cout << c1.get_value() << \"\\n\";\n    // prints \"1\"  \n\n    auto c2 = coro_throws();\n    c2.resume(); // let the coroutine run\n    std::cout << c2.get_value() << \"\\n\";\n    // c2.get_value() rethrows the exception\n} catch (const std::exception& e) {\n    // e.what() == \"Failed.\"\n    std::cout << e.what() << \"\\n\";\n}"
        }
      ],
      "id": "cRhJMrHr",
      "createdAt": 1711976321856,
      "updatedAt": 1711976328243
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::join",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 std::views::join will produce a view over the elements of sub-ranges. Effectively joining the sub-ranges into a single range.\n\n#include <ranges>\n#include <vector>\n#include <numeric>\n\nstd::vector<std::vector<int>> data{{1,2,3},{4,5,6},{7,8,9}};\n\n// Simple join over the 2nd dimension of the array\nauto view1 = data | std::views::join;\n// view1 == {1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\n// Join with a filter, skipping sub-ranges with odd sum\nauto view2 = data | std::views::filter([](const auto& rng) {\n        return std::accumulate(rng.begin(), rng.end(), 0) % 2 == 0;\n    }) | std::views::join;\n// view2 == {1, 2, 3, 7, 8, 9}"
        }
      ],
      "id": "j-PxkTmY",
      "createdAt": 1711976332214,
      "updatedAt": 1711976338771
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Integer literals",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++ offers a big selection of integer types.\n\nInteger literals get automatically upgraded to the corresponding integer type that can represent them. However, when working with type deduction scenarios, we might want to specify the type of the integer literal explicitly.\n\nWe can use both literal suffixes and fixed-size integer macros from cstdint.\n\n#include <utility>\n#include <cstdint>\n\n// Automated\nstd::is_same_v<decltype(0), int>;\n// platform specific\nstd::is_same_v<decltype(3'000'000'000), long>;\nstd::is_same_v<decltype(0u), unsigned>;\n// platform specific\nstd::is_same_v<decltype(5'000'000'000u), unsigned long>;\n\n// Signed integer literals\nstd::is_same_v<decltype(0), int>;\nstd::is_same_v<decltype(0L), long int>;\nstd::is_same_v<decltype(0LL), long long int>; // C++11\nstd::is_same_v<decltype(0Z), std::ptrdiff_t>; // C++23\n\n// Unsigned integer literals\nstd::is_same_v<decltype(0U), unsigned int>;\nstd::is_same_v<decltype(0UL), unsigned long int>;\nstd::is_same_v<decltype(0ULL), unsigned long long int>; // C++11\nstd::is_same_v<decltype(0UZ), std::size_t>; // C++23\n\n// Fixed-sized integer type macro from <cstdint>\nstd::is_same_v<decltype(UINT64_C(0)),uint_least64_t>; // C++11"
        }
      ],
      "id": "GfLCiJ5I",
      "createdAt": 1711976344583,
      "updatedAt": 1711976353308
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Optional values: std::unique_ptr, std::optional",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "If we want to represent an optional value, we can use std::unique_ptr (C++11) and heap allocation (nullptr denoting absence). However, this incurs a runtime cost and can fail (and throw).\n\nstd::optional (C++17) will not allocate dynamic memory and only incurs the cost of storing a boolean.\n\n#include <memory>\n#include <optional>\n\nstruct Data{};\n\nstd::unique_ptr<Data> dynamic_return() {\n    return std::make_unique<Data>();\n}\n\nstd::optional<Data> no_allocation() {\n    return std::make_optional<Data>();\n}\n\n\nauto x = dynamic_return();\nif (x != nullptr) { // or simply if(x)\n    // process data\n}\n\nauto y = no_allocation();\nif (y.has_value()) { // or simply if(y)\n    // process data\n}"
        }
      ],
      "id": "caBv3BtL",
      "createdAt": 1711976360078,
      "updatedAt": 1711976365902
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::front_inserter, std::back_inserter, std::inserter",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Preallocating capacity for elements is generally the performance-optimal approach. However, it adds code complexity, and we might not know the number of elements upfront.\n\nInserter adapters solve this problem by adapting the destination range and calling push_back (back_inserter), push_front (front_inserter) or insert (inserter) on each write.\n\n#include <algorithm>\n#include <vector>\n#include <list>\n\nstd::vector<int> src{1, 2, 3};\nstd::list<int> dst{4};\n\nstd::copy(src.begin(), src.end(), std::back_inserter(dst));\n// dst == {4, 1, 2, 3}\n\nstd::copy(src.begin(), src.end(), std::front_inserter(dst));\n// dst = {3, 2, 1, 4, 1, 2, 3}\n\nstd::copy(src.begin(), src.end(), \n    std::inserter(dst, std::next(dst.begin())));\n// dst = {3, 1, 2, 3, 2, 1, 4, 1, 2, 3}\n\n// Note that inserter should not be used with destination\n// ranges that invalidate iterators on insertion."
        }
      ],
      "id": "SRvxOzng",
      "createdAt": 1711976370868,
      "updatedAt": 1711976378481
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "static operator()",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Several modern C++ techniques lean on function objects for their implementation (notably to avoid ADL issues).\n\nHowever, this introduces a subtle problem. The function call operator cannot be a static method, which means that any call incurs the cost of passing the “this” pointer.\n\nC++23 addressed this problem by introducing support for a static operator().\n\n#include <utility>\n\nnamespace mynamespace {\nstruct something_fn {\n    // static method\n    static auto operator()(auto&& v) {\n        return std::forward<decltype(v)>(v);\n    }\n};\n\nstruct oldstyle_fn {\n    // normal method (incurs the penalty of passing this pointer)\n    // both in the function and on the call site\n    auto operator()(auto&& v) const {\n        return std::forward<decltype(v)>(v);\n    }\n};\n\nconstexpr inline auto something = something_fn{};\nconstexpr inline auto oldstyle = oldstyle_fn{};\n}\n\nint main() {\n    int x = mynamespace::something(10);\n    int y = mynamespace::oldstyle(10);\n}"
        }
      ],
      "id": "BOQWBS_g",
      "createdAt": 1711976388062,
      "updatedAt": 1711976394280
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::as_rvalue",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::views::as_rvalue is the view equivalent of the C++11 iterator adaptor std::move_iterator.\n\nThe elements of the view are presented as rvalues, which is useful when the source data can be consumed, thus avoiding unnecessary copies.\n\n#include <ranges>\n#include <algorithm>\n#include <vector>\n\nstruct Tattler {};\n\nstd::vector<Tattler> data{{},{},{}};\n\nfor (const auto& v : data | \n    std::views::transform([](const auto& e) {\n        return e;\n    })) { }\n// 3x copy constructor\n\nfor (auto v : data | \n    std::views::as_rvalue | \n    std::views::transform([](auto&& e) {\n        return std::forward<decltype(e)>(e); \n    })) { }\n// 3x move constructor"
        }
      ],
      "id": "R3rAQRYp",
      "createdAt": 1711976455993,
      "updatedAt": 1711976468199
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::exchange",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++14 utility std::exchange might seem simple. The utility sets the first argument to the value provided as a second argument and returns the original value.\n\nThe prototypical use case is for implementing move semantics. However, the utility comes in handy any time we would use a helper variable to store the original value.\n\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n\n// std::exchange as helper for move semantics\nstruct EraseOnMove {\n    EraseOnMove(int value) : value_(value) {}\n    EraseOnMove(EraseOnMove&& other)\n       : value_(std::exchange(other.value_, 0)) {}\n    EraseOnMove& operator=(EraseOnMove&& other) {\n        // safe for this == &other\n        value_ = std::exchange(other.value_, 0);\n        return *this;\n    }\n    int value_;\n};\n\nEraseOnMove a{10};\nEraseOnMove b(std::move(a));\n// a == {0}, b == {10}\n\n\n// std::exchange as helper for delimiting output\nstd::vector<int> data{1,2,3,4,5,6};\nstd::string delim = \"\";\nfor (auto v : data) {\n    std::cout << std::exchange(delim,\", \") << v;\n}\n// output: \"1, 2, 3, 4, 5, 6\""
        }
      ],
      "id": "XQVbDkTO",
      "createdAt": 1711976478301,
      "updatedAt": 1711976482803
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": " std::views::slide",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::views::slide is effectively an implementation of a sliding window.\n\nThe view will iterate over all continuous subranges of the given element count.\n\n#include <ranges>\n#include <vector>\n\n\nstd::vector<int> data{1,2,3,4,5,6,7,8,9};\nfor (auto window : data | std::views::slide(4)) {\n    // Iterate over all 4 element window positions:\n    // {1,2,3,4}\n    // {2,3,4,5}\n    // {3,4,5,6}\n    // {4,5,6,7}\n    // {5,6,7,8}\n    // {6,7,8,9}\n}"
        }
      ],
      "id": "85l9R2r_",
      "createdAt": 1711976489940,
      "updatedAt": 1711976495524
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Implementing custom views",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced views as part of the ranges library. Unfortunately, the support for implementing custom views was missing until C++23.\n\nIn this short article, we will go over how to implement custom views and what you should keep in mind while implementing a view.\nCompile-time composition of views\n\nView composition is at the core of views; however, typically, when we talk about the composition of views, we mean the runtime composition.\n\n#include <vector>\n#include <ranges>\n\nstd::vector<int> data{1,2,3,4,5};\nauto view = data | \n    std::views::filter([](int x) { return x % 2 == 0; }) | \n    std::views::drop(1);\n\nint first = view.front();\n// first == 4\n\nOpen the example in Compiler Explorer.\n\nEven in C++20, we can also compose views at compile time, as long as none of the views depends on a runtime argument.\n\n#include <ranges>\n#include <string>\n#include <list>\n\nconstexpr auto is_space = [](char c) { return std::isspace(c); };\n// View that drops leading space characters\nconstexpr auto trim_front = std::views::drop_while(is_space);\n// View that drops trailing space characters\nconstexpr auto trim_back = \n  std::views::reverse | trim_front | std::views::reverse;\n// A composed view that drop both leading and trailing space characters\nconstexpr auto trim = trim_front | trim_back;\n\n\nstd::string line = \"  \\t  Hello World!   \\t\";\n\nauto trimmed1 = line | trim | std::ranges::to<std::string>();\n// trimmed1 == \"Hello World!\"\n\nstd::string_view v = line;\nstd::list<char> list{v.begin(), v.end()};\n\n// Also works for other bidirectional containers\nauto trimmed2 = list | trim | std::ranges::to<std::string>();\n// trimmed2 == \"Hello World!\"\n\nOpen the example in Compiler Explorer.\n\nNote that views::drop_while is one of the views that require mutability; however, this only applies to the final composition that includes a source range.\n\nstd::list<char> list;\n\nconst auto bad = list | trim;\nchar c = bad.front(); // Wouldn't compile, requires mutability\n\nOpen the example in Compiler Explorer.\\\n\nIf your final composed view depends on a runtime argument, you could still use composition with a factory function returning a concrete instance of your composed view. The more principled approach is to build a custom view instead.\nBuilding a custom view\n\nLet’s start with a simple example of a view that exposes all elements of the underlying range. C++20 includes the std::ranges::view_interface, simplifying the job; all we have to do is implement begin() and end().\n\nYou might be tempted to implement something like the following example:\n\n#include <ranges>\n\ntemplate <typename It>\n// Inheriting from the interface will bring in the rest of methods\n// size, empty, operator[], data, front, back \nstruct all_elements : std::ranges::view_interface<all_elements<It>> {\n    // Constructor from a range:\n    all_elements(std::ranges::viewable_range auto&& rng) :\n        begin_(std::ranges::begin(rng)), end_(std::ranges::end(rng)) {}\n\n    // Required interface:\n    auto begin() const { return begin_; }\n    auto end() const { return end_; }\nprivate:\n    It begin_;\n    It end_;\n};\n\n// Deduction guide to deduce the type of iterator for begin_ and end_\nall_elements(std::ranges::viewable_range auto&& rng) \n    -> all_elements<std::ranges::iterator_t<decltype(rng)>>;\n\nOpen the example in Compiler Explorer.\n\nHowever, this implementation has a fatal flaw.\n\n// OK\nstd::vector<int> data{1,2,3,4,5};\nfor (auto v : all_elements(data)) {}\n\n// UB before C++23, OK since C++23\nfor (auto v : all_elements(std::vector<int>{1,2,3,4,5})) {}\n\n// Always UB\nauto view = all_elements(std::vector<int>{1,2,3,4,5});\nfor (auto v : view) {}\n\nOpen the example in Compiler Explorer.\n\nIf we wrap a temporary, we end up with dangling iterators.\n\nSadly, this is not something we can avoid by simply forbidding construction from temporaries since that is precisely what we will encounter when we compose views.\n\nThe good thing is that the ranges library already provides the std::ranges::views::all, which correctly handles this. Before we get to that, here is one (not practical) way you solve the problem (views::all uses a more fleshed-out version of the same idea):\n\n#include <ranges>\n\ntemplate <typename Rng>\nstruct all_elements : std::ranges::view_interface<all_elements<Rng>> {\n    // Instead of storing iterators, store either\n    // a reference to or a copy of the range\n    template <std::ranges::viewable_range Arg>\n    all_elements(Arg&& arg) : range_(std::forward<Arg>(arg)) {}\n\n    auto begin() const { return std::ranges::begin(range_); }\n    auto end() const { return std::ranges::end(range_); }\n    Rng range_;\n};\n\n// A deduction guide for r-values, store the value\ntemplate <std::ranges::viewable_range Rng>\nrequires (not std::is_lvalue_reference_v<Rng>)\nall_elements(Rng&& rng) -> all_elements<std::remove_reference_t<Rng>>;\n\n// A deduction guide for l-values\ntemplate <std::ranges::viewable_range Rng>\nrequires std::is_lvalue_reference_v<Rng>\nall_elements(Rng&& rng) -> all_elements<Rng>;\n\nOpen the example in Compiler Explorer.\n\nHowever, as I mentioned, the standard library already provides a views::all, which comes bundled with a helper type std::ranges::views::all_t.\n\n#include <ranges>\n\ntemplate <typename Rng>\nstruct all_elements : std::ranges::view_interface<all_elements<Rng>> {\n    template <std::ranges::viewable_range Arg>\n    all_elements(Arg&& arg) : range_(std::forward<Arg>(arg)) {}\n\n    auto begin() const { return std::ranges::begin(range_); }\n    auto end() const { return std::ranges::end(range_); }\n    Rng range_;\n};\n\n// Deduction guide using the all_t\n// - std::ranges::owning_view for r-values\n// - std::ranges::ref_view for l-values\ntemplate <std::ranges::viewable_range Rng> all_elements(Rng&& rng)\n -> all_elements<std::ranges::views::all_t<Rng>>;\n\nOpen the example in Compiler Explorer.\n\nWhen the argument is an r-value, the views::all_t will produce an owning_view, which takes ownership of the argument. If the argument is an l-value the result will be a ref_view which only references the argument.\n\nWhile we no longer have issues with lifetime, we also have a fairly pointless wrapper around std::views::all that already does exactly what was our initial aim. Let’s switch gears and implement a view that does some meaningful work.\nAll prefixes of a range\n\nLet’s build a view that will produce all the prefixes of a range. We can express the main idea of this view using composition and a factory function.\n\n#include <ranges>\n\nconstexpr auto make_all_prefixes = \n    [](const std::ranges::sized_range auto& rng) {\n        // zip produces tuples of iterators\n        return std::views::zip(\n                std::views::repeat(begin(rng), rng.size()+1),\n                std::views::iota(begin(rng))) |\n            // transform turns the tuples into ranges\n            std::views::transform([](auto tupple) {\n                return std::ranges::subrange(\n                    std::get<0>(tupple), std::get<1>(tupple));\n            });\n    };\n\nOpen the example in Compiler Explorer.\n\nHowever, since we are working with iterators, this factory function can only operate on l-values.\n\nstd::vector<int> data{1,2,3,4,5};\nfor (auto prefix : make_all_prefixes(data)) {\n    // iterate over\n    // {}, {1}, {1,2}, {1,2,3}, {1,2,3,4}, {1,2,3,4,5}\n}\n\nOpen the example in Compiler Explorer.\n\nWe need to wrap this factory in a view to work around this limitation, using the technique from the previous section.\n\n#include <ranges>\n\ntemplate <typename Rng, typename View>\nstruct all_prefixes_view :\n    std::ranges::view_interface<all_prefixes_view<Rng, View>> {\n\n    template <std::ranges::sized_range Arg>\n    all_prefixes_view(Arg&& arg) \n      : rng_(std::forward<Arg>(arg)), view_(make_all_prefixes(rng_)) {}\n\n    auto begin() { return view_.begin(); }\n    auto end() { return view_.end(); }\nprivate:\n    Rng rng_;\n    View view_;\n};\n\ntemplate <typename Arg>\nusing all_t = std::ranges::views::all_t<Arg>;\n\ntemplate <std::ranges::sized_range Arg> all_prefixes_view(Arg&& arg)\n-> all_prefixes_view<\n    all_t<Arg>,\n    decltype(make_all_prefixes(std::declval<all_t<Arg>>()))\n    >;\n\nOpen the example in Compiler Explorer.\n\nThe ideas are the same. We have a more complex deduction guide since the second argument of the template gets its type from the result of invoking make_all_prefixes.\n\nFinally, we need to enable composition for our view. Technically, this already works if our new view is the left argument, but to get this working completely, we need C++23 support.\n\n// Works with C++20\nfor (auto prefix : all_prefixes_view(data) | std::views::drop(1)) {\n    // iterate over\n    // {1}, {1,2}, {1,2,3}, {1,2,3,4}, {1,2,3,4,5}\n}\n\nC++23 introduced the std::ranges::range_adaptor_closure. The pipe composition support and the corresponding overloads are part of the standard library, so all we have to do is wrap our view into a functor that accepts a range as its first argument.\n\n#include <ranges>\n\nstruct all_prefixes_fn : std::ranges::range_adaptor_closure<all_prefixes_fn> {\n    template <std::ranges::sized_range Rng>\n    constexpr auto operator()(Rng&& rng) const {\n        return all_prefixes_view(std::forward<Rng>(rng));\n    }\n};\nconstexpr all_prefixes_fn all_prefixes{};\n\nstd::vector<int> data{1,2,3,4,5};\nfor (auto prefix : data | all_prefixes) {\n    // iterate over\n    // {}, {1}, {1,2}, {1,2,3}, {1,2,3,4}, {1,2,3,4,5}\n}\n\nfor (auto prefix : std::vector<int>{1,2,3,4,5} | all_prefixes) {\n    // iterate over\n    // {}, {1}, {1,2}, {1,2,3}, {1,2,3,4}, {1,2,3,4,5}\n}\n\nfor (auto prefix : data | all_prefixes | std::views::drop(1)) {\n    // iterate over\n    // {1}, {1,2}, {1,2,3}, {1,2,3,4}, {1,2,3,4,5}\n}"
        }
      ],
      "id": "3LQ0n7LN",
      "createdAt": 1711976499942,
      "updatedAt": 1711976515959
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Hardened mode of standard library implementations",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "One of the tricky parts of programming is dealing with assumptions. With C++, assumptions can be deadly, as a violated assumption will likely lead to undefined behaviour, making the program invalid.\n\nWe can mitigate this problem to a large degree with proper engineering practices. Notably, good unit test coverage combined with sanitizers can catch most bugs.\n\nSanitizers can detect language-level undefined behaviour, even if that behaviour doesn’t manifest as a test failure. However, this approach has an issue. Sanitizers do not detect library-level UB, and while this is generally fine, it can make tracing issues back to their root cause tricky.\n\nThis is where the hardened mode of stdlibc++ and libc++ comes into play.\n-fhardened\n\nWe will start with the -fhardened flag provided by GCC. Clang doesn’t support this umbrella flag; however, it does support each of the sub-features.\n\nThe TL;DR is that the -fhardened flag enables safety features that do not affect ABI. It covers a set of safety flags that address specific attacks and library-level checks (for both glibc and stdlibc++).\n\n-D_FORTIFY_SOURCE=3\n-D_GLIBCXX_ASSERTIONS\n-ftrivial-auto-var-init=zero\n-fPIE  -pie  -Wl,-z,relro,-z,now\n-fstack-protector-strong\n-fstack-clash-protection\n-fcf-protection=full (x86 GNU/Linux only)\n\nThree protections for specific attacks\n\nThree of the sub-features are designed to prevent specific attacks. I won’t go into the details, but you can easily find details for each attack by searching for the flag (high-quality sources for these topics are GCC, LLVM, RedHat and LWN).\n\n    -fstack-protector-strong\n    -fstack-clash-protection\n    -fcf-protection=full\n\nTrivial initialization (-ftrivial-auto-var-init=pattern)\n\nDefault initialization in C++ can be tricky, as it can leave variables uninitialized.\n\nint x;\nstd::cout << std::hex << \"0x\" << x << \"\\n\";\n// Undefined behaviour\n\nThis flag ensures that default initialization initializes variables with a pattern of values. GCC uses 0xFE and Clang 0xAA.\n\nint x;\nstd::cout << std::hex << \"0x\" << x << \"\\n\";\n// GCC:   0xfefefefe\n// Clang: 0xaaaaaaaa\n\nOpen the example in Compiler Explorer.\n\nThe downside of this feature is that if you require an uninitialized variable, you have to annotate it with the __attribute__ ((uninitialized)).\n\nvoid funa() {\n    int v[1024*1024];\n}\n\nvoid funb() {\n    int v[1024*1024] __attribute__ ((uninitialized));\n}\n\nGenerated assembly from GCC.\n\nfuna():\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 4194304\n        lea     rax, [rbp-4194304]\n        mov     edx, 4194304\n        mov     esi, 254\n        mov     rdi, rax\n        call    memset\n        nop\n        leave\n        ret\nfunb():\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 4194184\n        nop\n        leave\n        ret\n\nOpen the example in Compiler Explorer.\nPosition-independent executable (-fPIE -pie)\n\nThe main point of position-independent executables is that they can operate with address space layout randomization (ASLR), randomizing the positions code, which makes exploits more difficult.\n\nThe related feature is Relocation Read-Only (-Wl,-z,relro,-z,now), which prevents modification of the Global Offset Table (locations of functions from dynamically linked libraries) after the program startup.\n\nThe downside is that this prevents tools like ltrace from working.\n\n#include <iostream>\n\nint main() {\n    std::cout << \"Hello World!\\n\";\n}\n\nBinary with lazily loaded libraries.\n\n$ g++ safe.cc -g -fno-PIE -no-pie -Wl,-z,lazy\n$ ltrace -C ./a.out 1>/dev/null\nstd::ios_base::Init::Init()(0x404191, 0xffff, 0x7ffd5eeebb98, 0x403e00) = 0x7f9f058fc4b8\n__cxa_atexit(0x4010a0, 0x404191, 0x404040, 0x7f9f05b2dda0) = 0\nstd::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)(0x404080, 0x402004, 0x7ffd5eeebb98, 0x403e08) = 0x404080\nstd::ios_base::Init::~Init()(0x404191, 0, 1, 4)       = 0x7f9f05b2be80\n+++ exited (status 0) +++\n\nPosition independent executable with Relocation Read-Only.\n\n$ g++ safe.cc -g -fPIE -pie -Wl,-z,relro,-z,now\n$ ltrace -C ./a.out 1>/dev/null\n+++ exited (status 0) +++\n\nC standard library (-D_FORTIFY_SOURCE=3)\n\nThe first set of library-level checks is the fortification of the C standard library, specifically when dealing with buffers with known size.\n\nBecause of this, this flag only works when optimizations are also enabled.\n\n#include <cstring>\n\nvoid __attribute__((noinline)) fun(size_t size) {\n    static char buffer[1024]; // Buffer of known size\n    memset(buffer, 0, size);\n}\n\nint main () {\n    fun(1025);\n    return 0;\n}\n\nDetected buffer overflow.\n\n*** buffer overflow detected ***: terminated\nProgram terminated with signal: SIGSEGV\n\nOpen the example in Compiler Explorer.\nC++ Standard library\n\nThe last part of hardening is where GCC and Clang diverge. This is also where things get interesting.\n\nstdlibc++ offers two levels:\n\n    _GLIBCXX_ASSERTIONS (non-ABI breaking)\n    _GLIBCXX_DEBUG (ABI breaking)\n\nlibc++ offers three levels, all of which are non-ABI breaking:\n\n    _LIBCPP_HARDENING_MODE_FAST\n    _LIBCPP_HARDENING_MODE_EXTENSIVE\n    (roughly equivalent to _GLIBCXX_ASSERTIONS)\n    _LIBCPP_HARDENING_MODE_DEBUG\n\nNote that for libc++, you don’t define these macros. Instead, these are values for the _LIBCPP_HARDENING_MODE macro, e.g., -D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_DEBUG.\n\nWhile most of the other features enabled by -fhardened are either performance neutral or have only negligible impact on performance, _GLIBCXX_ASSERTIONS can be fairly intrusive. However, because this is also the most impactful feature for C++ development, you should use this flag, at least for your local development loop.\n\nAnd to justify the previous statement, let’s explore some of the features you get for your trouble.\n_GLIBCXX_ASSERTIONS and _LIBCPP_HARDENING_MODE_EXTENSIVE\n\nIf you are familiar with the standard library, you might know that most operations have narrow contracts. For example, using the element access operator on a vector is only defined for values [0, size). This is precisely where assertions/hardening comes in.\n\n#include <vector>\n\nint main() {\n    std::vector<int> empty;\n    empty[0] = 10; // out of bounds\n}\n\nAssertion '__n < this->size()' failed.\n\nOpen the example in Compiler Explorer.\n\nAnd we get the same level of enforcement for the other methods.\n\n#include <vector>\n\nint main() {\n    std::vector<int> empty;\n    int v = empty.front(); // also out of bounds\n}\n\nAssertion '!this->empty()' failed.\n\nOpen the example in Compiler Explorer.\n\nAnother good example is std::views::iota. You might be tempted to express a decreasing sequence; however, iota works explicitly by incrementing the initial value, and a decreasing sequence cannot be expressed.\n\n#include <ranges>\n\nint main() {\n    // Incorrect use of std::views::iota\n    // iota only generates increasing sequences\n    for (auto v : std::views::iota(4,3)) {}\n}\n\nAssertion 'bool(__value <= __bound)' failed.\n\nOpen the example in Compiler Explorer.\n\nWhile stdlibc++ and libc++ are mostly at parity, there are some differences.\n\n#include <memory>\n\nint main() {\n    auto p = std::make_shared<int>(42);\n    p.reset(p.get()); // Incorrect use of reset\n}\n\nOnly caught by stdlibc++:\n\nAssertion '__p == nullptr || __p != _M_ptr' failed.\n\nOpen the example in Compiler Explorer.\nDebug mode\n\nFinally, we need to talk about the debug mode. While the previously mentioned checks are beneficial, the debug mode is where you will find the heavy-duty checks that find subtle and hard-to-find bugs.\n\nHowever, naturally, most of the checks are very expensive. This is not an exaggeration; checks in debug can change the big-O complexity of operations.\n\nCurrently, libc++ is in the process of implementing these checks (you can follow the progress here), so I will only demonstrate using GCC.\nSide note on ABI\n\nThe stdlibc++ implementation took the ABI-breaking route by replacing containers and iterators with instrumented versions that are not ABI-compatible. This means that a mixed binary will generally not link.\n\nIf you have precompiled functions that return containers, the resulting binary will link (since return types are not encoded in the mangled name), but the result will be a corrupted binary that contains undefined behaviour.\n\n// lib.h\n#pragma once\n\n#include <vector>\n\nstd::vector<int> get_data();\n\n// lib.cc\n#include \"lib.h\"\n\nstd::vector<int> get_data() { return {1,2,3,4,5}; }\n\n// main.cc\n#include \"lib.h\"\n\nint main() {\n    std::vector<int> data = get_data();\n}\n\n$ g++ -c lib.cc\n$ g++ main.cc -D_GLIBCXX_DEBUG lib.o -o main\n$ ./main\nfree(): invalid pointer\nAborted\n\nThis is also why stdlibc++ doesn’t provide a debug version of std::string. This container is pervasively used throughout the standard library as a result type. If you want to use the debug mode with GCC, ensure you have built your entire source base with this flag.\n\nOn the other hand, libc++ is taking the non-ABI-breaking stance. This means that it will enforce whatever checks can be enforced using the ABI provided by the platform. If you want to get checks requiring container and iterator instrumentation, you will have to build your libc++ with that support.\nDebug features\n\nThe main functionality offered by the debug mode in stdlibc++ is built around container-aware iterators. In the simplest form, this includes checks for dangling iterators.\n\n#include <vector>\n\nint main() {\n    std::vector<int> data{1};\n    auto it = data.begin();\n    data.push_back(42);\n    int v = *it;\n}\n\nIn function:\n    constexpr gnu_debug::_Safe_iterator<_Iterator, _Sequence, \n    _Category>::reference gnu_debug::_Safe_iterator<_Iterator, _Sequence, \n    _Category>::operator*() const [with _Iterator = gnu_cxx::\n    normal_iterator<int*, std::vector<int, std::allocator<int> > >; \n    _Sequence = std::debug::vector<int>; _Category = \n    std::forward_iterator_tag; reference = int&]\n\nError: attempt to dereference a singular iterator.\n\nObjects involved in the operation:\n    iterator \"this\" @ 0x7ffea687e7d0 {\n      type = gnu_cxx::normal_iterator<int*, std::vector<int, std::allocator<int> > > (mutable iterator);\n      state = singular;\n      references sequence with type 'std::debug::vector<int, std::allocator<int> >' @ 0x7ffea687e800\n    }\nProgram terminated with signal: SIGSEGV\n\nOpen the example in Compiler Explorer.\n\nIterators passed to algorithms are checked to determine whether they represent a valid range.\n\n#include <vector>\n#include <numeric>\n\nint main() {\n    std::vector<int> data{1,2,3,4,5};\n    int v = std::accumulate(data.end(), data.begin(), 0);\n}\n\nIn function:\n    constexpr _Tp std::accumulate(_InputIterator, _InputIterator, _Tp) [with \n    _InputIterator = gnu_debug::_Safe_iterator<gnu_cxx::\n    normal_iterator<int*, vector<int, allocator<int> > >, \n    debug::vector<int>, random_access_iterator_tag>; _Tp = int]\n\nError: function requires a valid iterator range [first, last).\n\nObjects involved in the operation:\n    iterator \"first\" @ 0x7ffd67954750 {\n      type = gnu_cxx::normal_iterator<int*, std::vector<int, std::allocator<int> > > (mutable iterator);\n      state = past-the-end;\n      references sequence with type 'std::debug::vector<int, std::allocator<int> >' @ 0x7ffd679547b0\n    }\n    iterator \"last\" @ 0x7ffd67954780 {\n      type = gnu_cxx::normal_iterator<int*, std::vector<int, std::allocator<int> > > (mutable iterator);\n      state = dereferenceable (start-of-sequence);\n      references sequence with type 'std::debug::vector<int, std::allocator<int> >' @ 0x7ffd679547b0\n    }\nProgram terminated with signal: SIGSEGV\n\nOpen the example in Compiler Explorer.\n\nCounted algorithms are also checked.\n\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> data{1,2,3,4,5};\n    std::vector<int> out(5);\n    std::copy_n(data.begin(), 6, out.begin());\n}\n\nIn function:\n    constexpr _OIter std::copy_n(_IIter, _Size, _OIter) [with _IIter = \n    gnu_debug::_Safe_iterator<gnu_cxx::normal_iterator<int*, vector<int, \n    allocator<int> > >, debug::vector<int>, random_access_iterator_tag>; \n    _Size = int; _OIter = gnu_debug::_Safe_iterator<gnu_cxx::\n    normal_iterator<int*, vector<int, allocator<int> > >, \n    debug::vector<int>, random_access_iterator_tag>]\n\nError: attempt to subscript a dereferenceable (start-of-sequence) iterator 6 \nstep from its current position, which falls outside its dereferenceable \nrange.\n\nObjects involved in the operation:\n    iterator \"first\" @ 0x7ffd49e98670 {\n      type = gnu_cxx::normal_iterator<int*, std::vector<int, std::allocator<int> > > (mutable iterator);\n      state = dereferenceable (start-of-sequence);\n      references sequence with type 'std::debug::vector<int, std::allocator<int> >' @ 0x7ffd49e98740\n    }\nProgram terminated with signal: SIGSEGV\n\nOpen the example in Compiler Explorer.\n\nThe debug containers provide the checks from _GLIBCXX_ASSERTIONS with the verbose debug output.\n\n#include <vector>\n\nint main() {\n    std::vector<int> data{1,2,3,4,5};\n    data[5] = 2;\n}\n\nIn function:\n    constexpr std::debug::vector<_Tp, _Allocator>::reference std::\n    debug::vector<_Tp, _Allocator>::operator[](size_type) [with _Tp = int; \n    _Allocator = std::allocator<int>; reference = int&; size_type = long \n    unsigned int]\n\nError: attempt to subscript container with out-of-bounds index 5, but \ncontainer only holds 5 elements.\n\nObjects involved in the operation:\n    sequence \"this\" @ 0x7ffc08f87a70 {\n      type = std::debug::vector<int, std::allocator<int> >;\n    }\nProgram terminated with signal: SIGSEGV\n\nOpen the example in Compiler Explorer.\n\nDebug mode also covers expensive checks, such as validating that the comparator for std::sort satisfies the strict-weak-ordering requirement.\n\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> data{1,2,3,4,5};\n    std::ranges::sort(data, [](int l, int r) {\n        return l <= r; // not irreflexive\n    });\n}\n\nIn function:\n    constexpr void std::sort(_RAIter, _RAIter, _Compare) [with _RAIter = \n    gnu_debug::_Safe_iterator<gnu_cxx::normal_iterator<int*, vector<int, \n    allocator<int> > >, debug::vector<int>, random_access_iterator_tag>; \n    _Compare = ranges::detail::make_comp_proj<main()::<lambda(int, int)>, \n    std::identity>(main()::<lambda(int, int)>&, \n    std::identity&)::<lambda(auto:6&&, auto:7&&)>]\n\nError: comparison doesn't meet irreflexive requirements, assert(!(a < a)).\n\nObjects involved in the operation:\n    instance \"functor\" @ 0x7ffee62fcc20 {\n      type = std::ranges::detail::make_comp_proj<main::{lambda(int, int)#1}, std::identity>(main::{lambda(int, int)#1}&, std::identity&)::{lambda(auto:1&&, auto:2&&)#1};\n    }\n    iterator::value_type \"ordered type\"  {\n      type = int;\n    }\nProgram terminated with signal: SIGSEGV\n\nOpen the example in Compiler Explorer.\nConclusion\n\nThe debug mode provides the best checks for the development loop. However, the GCC stdlibc++ implementation is problematic due to the chosen ABI approach.\n\nI hope the LLVM libc++ debug mode will offer a more systemic approach. Notably, if we can get the ability to compile a special version of libc++ for local development, it would be a very clean solution that would provide the benefits of debug mode without affecting the rest of the Continuous Integration."
        }
      ],
      "id": "E-Rs4nWa",
      "createdAt": 1711976527907,
      "updatedAt": 1711976540092
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Linked lists",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Today we will take a short departure from the typical interview content schedule, and instead of an interview problem, we will go over a bit of theory and talk about linked lists.\n\nWhile rare in practical applications, linked lists crop up frequently in interviews. Partly this is because the node structure lends itself to formulating tricky problems, similar to trees and graphs, without the added topological complexity.\nstd::list and std::forward_list\n\nThe standard library offers two list types, std::list — a doubly-linked list and std::forward_list — a singly-linked list. Forward list exists primarily as a space optimization, saving 8 bytes per element on 64-bit architectures.\n\nBoth offer perfect iterator and reference stability, i.e. the only operation that invalidates iterators or references is the erasure of an element, and only for the removed element. The stability does extend even to moving elements between lists.\n\n#include <list>\n\nstd::list<int> first{1,2,3};\nstd::list<int> second{4,5,6};\n\n// Get iterator to the element with value 2\nauto it = std::next(first.begin());\n\n// Move the element to the begining of the second list\nsecond.splice(second.begin(), first, it);\n\n// first == {1, 3}, second == {2,4,5,6}\n\n// iterator still valid\n// *it == 2\n\nOpen the example in Compiler Explorer.\n\nThe iterator stability is one of the use cases where we would use a std::list or std::forward_list in practical applications. The only reasonable alternative would be wrapping each element in a std::unique_ptr, which does offer reference stability (but not iterator stability) irrespective of the wrapping container.\n\n#include <vector>\n#include <memory>\n\n\nstd::vector<std::unique_ptr<int>> stable;\nstable.push_back(std::make_unique<int>(1));\nstable.push_back(std::make_unique<int>(2));\nstable.push_back(std::make_unique<int>(3));\n\n// get a stable weak reference (or pointer) to an element\nint *it = stable[1].get();\nstable.erase(stable.begin()); // invalidates all iterators\n// it still valid, *it == 2\n\nOpen the example in Compiler Explorer.\n\nOf course, we do pay for this stability with performance. Linked lists are node-based containers, meaning each element is allocated in a separate node, potentially very distant from each other in memory. When we combine this with the inherent overhead of the indirection, traversing a std::list can regularly end up 5x-10x slower than an equivalent flat std::vector.\n\nAside from iterator stability, we also get access to a suite of O(1) operations, and these can potentially outweigh the inherent overhead of a std::list.\n\n#include <list>\n\nstd::list<int> data{1,2,3,4,5};\n\n// O(1) splicing between lists, or within one list\n\n// effectively rotate left by one element\ndata.splice(data.end(), data, data.begin());\n// data == {2,3,4,5,1}\n\n// O(1) erase\n\n// iterator to element with value 4\nauto it = std::next(data.begin(), 2);\ndata.erase(it);\n// data == {2,3,5,1}\n\n// O(1) insertion\n\n// effectively push_front()\ndata.insert(data.begin(), 42);\n// data = {42,2,3,5,1}\n\nOpen the example in Compiler Explorer.\n\nWe are locked out of some standard algorithms because std::list only provides bidirectional iterators and std::forward_list only forward iterators. Both lists expose custom implementations of sort, unique, merge, reverse, remove and remove_if as member functions.\n\n#include <list>\n\nstd::list<int> data{1,2,3,4,5};\n\ndata.reverse();\n// data = {5,4,3,2,1}\n\ndata.sort();\n// data = {1,2,3,4,5}\n\ndata.remove_if([](int v) { return v % 2 == 0; });\n// data == {1,3,5}\n\nOpen the example in Compiler Explorer.\n\nThe std::forward_list has an additional quirk; since we can only erase and insert after an iterator, the std::forward_list offers a modified interface.\n\n#include <forward_list>\n\nstd::forward_list<int> data{1,2,3,4,5};\n\n// before_begin() iterator\nauto it = data.before_begin();\n\n// insert and erase only possible after the iterator\ndata.insert_after(it, 42);\n// data == {42,1,2,3,4,5}\ndata.erase_after(it);\n// data == {1,2,3,4,5}\n\nOpen the example in Compiler Explorer.\nCustom lists\n\nWhen implementing a simple custom linked list, you might be tempted to use a straightforward implementation using a std::unique_ptr.\n\n#include <memory>\n\nstruct Node {\n    int value;\n    std::unique_ptr<Node> next;\n};\n\nstd::unique_ptr<Node> head = std::make_unique<Node>(20,nullptr);\nhead->next = std::make_unique<Node>(42,nullptr);\n// head->value == 20\n// head->next->value == 42\n\nOpen the example in Compiler Explorer.\n\nSadly, this approach isn’t usable. The fundamental problem here is the design. We are mixing ownership with structural information. In this case, this problem manifests during destruction. Because we have tied the ownership with the structure, the destruction of a list will be recursive, potentially leading to stack exhaustion and a crash.\n\n#include <memory>\n\nstruct Node {\n    int value;\n    std::unique_ptr<Node> next;\n};\n\n{\nstd::unique_ptr<Node> head = std::make_unique<Node>(0,nullptr);\n// Depending on the architecture/compiler, the specific number\n// of elements we can handle without crash will differ.\nNode* it = head.get();\nfor (int i = 0; i < 100000; ++i)\n    it = (it->next = std::make_unique<Node>(0,nullptr)).get();\n} // BOOM\n\nOpen the example in Compiler Explorer.\n\nIf we desire both the O(1) operations and iterator stability, the only option is to rely on manual resource management (at which point we might as well use std::list or std::forward_list).\n\nIf we want to capture the structure of a linked list with reference stability, we can rely on the aforementioned std::vector and std::unique_ptr combination.\n\n#include <vector>\n#include <memory>\n\nstruct List {\n    struct Node {\n        int value;\n        Node* next;\n    };\n    Node *head = nullptr;\n    Node *new_after(Node* prev, int value) {\n        nodes_.push_back(std::make_unique<Node>(value, nullptr));\n        if (prev == nullptr)\n            return head = nodes_.back().get();\n        else\n            return prev->next = nodes_.back().get();\n    }\nprivate:\n    std::vector<std::unique_ptr<Node>> nodes_;\n};\n\n\nList list;\nauto it = list.new_after(nullptr, 1);\nit = list.new_after(it, 2);\nit = list.new_after(it, 3);\n\n// list.head->value == 1\n// list.head->next->value == 2\n// list.head->next->next->value == 3\n\nOpen the example in Compiler Explorer.\n\nThe crucial difference from the previous approach is that the list owns all nodes, and the structure is encoded only using weak pointers.\n\nFinally, if we do not require stable iterators or references but do require O(1) operations, we can use a flat list approach. We can store all nodes directly in a std::vector. The only problematic operation, in that case, is erase(), which is inherently linear for std::vector.\n\nHowever, a linked list already inherently encodes the order of elements, so instead of erasing from the middle of a std::vector, we can always erase from the end by swapping the to-be-erased element with the last element in the std::vector.\n\n#include <vector>\n\ninline constexpr ptrdiff_t nill = -1;\n\nstruct List {  \n    struct Node {\n        int value;\n        ptrdiff_t next;\n        ptrdiff_t prev;\n    };\n    ptrdiff_t new_after(ptrdiff_t prev, int value) {\n        storage.push_back({value, nill, prev});\n        if (prev != nill)\n            storage[prev].next = std::ssize(storage)-1;\n        else\n            head = std::ssize(storage)-1;\n        return std::ssize(storage)-1;\n    }\n    void erase(ptrdiff_t idx) {\n        // move head\n        if (idx == head)\n            head = storage[idx].next;\n        // unlink the erased element\n        if (storage[idx].next != nill)\n            storage[storage[idx].next].prev = storage[idx].prev;\n        if (storage[idx].prev != nill)\n            storage[storage[idx].prev].next = storage[idx].next;\n        // relink the last element\n        if (idx != std::ssize(storage)-1) {\n            if (storage.back().next != nill)\n                storage[storage.back().next].prev = idx;\n            if (storage.back().prev != nill)\n                storage[storage.back().prev].next = idx;\n        }\n        // swap and O(1) erase\n        std::swap(storage[idx],storage.back());\n        storage.pop_back();\n    }\n    ptrdiff_t get_head() { return head; }\n    Node& at(ptrdiff_t idx) { return storage[idx]; }\nprivate:\n    ptrdiff_t head = nill;\n    std::vector<Node> storage;\n};\n\n\nList list;\nptrdiff_t idx = list.new_after(nill, 1);\nidx = list.new_after(idx, 2);\nidx = list.new_after(idx, 3);\nidx = list.new_after(idx, 4);\nidx = list.new_after(idx, 5);\n// list == {1,2,3,4,5}\n\nidx = list.get_head();\nlist.erase(idx);\n// list == {2,3,4,5}\n\nOpen the example in Compiler Explorer.\nBasic operations\n\nWhen designing a solution for a coding problem, the three most frequent operations with linked lists are:\n\n    merge two sorted lists\n    reverse a sorted list\n    scan with two iterators\n\nBoth std::list and std::forward_list come with a built-in merge operation.\n\n#include <list>\n#include <forward_list>\n\n{\nstd::list<int> left{2,4,5};\nstd::list<int> right{1,3,9};\nleft.merge(right);\n// left == {1,2,3,4,5,9}\n// right == {}\n}\n\n{\nstd::forward_list<int> left{2,4,5};\nstd::forward_list<int> right{1,3,9};\nleft.merge(right);\n// left == {1,2,3,4,5,9}\n// right == {}\n}\n\nOpen the example in Compiler Explorer.\n\nHowever, implementing one from scratch isn’t particularly complicated either. We consume the merged-in list, one element at a time, advancing the insertion position as needed.\n\n#include <forward_list>\n\nstd::forward_list dst{1, 3, 5, 6};\nstd::forward_list src{2, 4, 7};\n\nauto dst_it = dst.begin();\n\nwhile (!src.empty()) {\n    if (std::next(dst_it) == dst.end() || \n        *std::next(dst_it) >= src.front()) {\n        dst.splice_after(dst_it, src, src.before_begin());\n    } else {\n        ++dst_it;\n    }\n}\n// dst == {1,2,3,4,5,6,7}\n// src == {}\n\nOpen the example in Compiler Explorer.\n\nThe same situation applies to reversing a list. Both lists provide a built-in reverse operation with a custom implementation even simpler than merge.\n\n#include <forward_list>\n\n\nstd::forward_list<int> src{1,2,3,4,5,6,7};\nstd::forward_list<int> dst;\n\nwhile (!src.empty())\n    dst.splice_after(dst.before_begin(), src, src.before_begin());\n// dst == {7,6,5,4,3,2,1}\n// src == {}\n\ndst.reverse();\n// dst == {1,2,3,4,5,6,7}\n\nOpen the example in Compiler Explorer.\n\nFinally, scanning with two iterators is a common search technique for finding a sequence of elements that conform to a particular property. As long as this property is calculated strictly from elements entering and leaving the sequence, we do not need to access the elements currently in the sequence.\n\n#include <forward_list>\n\nstd::forward_list<int> data{4,2,1,1,1,3,5};\n\n// find the longest subsequence with sum less than 4\n\n// two iterators denoting the sequence [left, right)\nauto left = data.begin();\nauto right = data.begin();\nint sum = 0;\nint len = 0;\nint max = 0;\n\nwhile (right != data.end()) {\n    // extend right, until we break the property\n    while (sum < 4 && right != data.end()) {\n        max = std::max(max, len);\n        ++len;\n        sum += *right;\n        ++right;\n    }\n    // shrink from left, until the property is restored\n    while (sum >= 4 && left != right) {\n        sum -= *left;\n        --len;\n        ++left;\n    }\n}\n// max == 3, i.e. {1,1,1}"
        }
      ],
      "id": "t0Swg_4G",
      "createdAt": 1711976552438,
      "updatedAt": 1711976565279
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Modern documentation tools",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Today we will look at modern documentation tools.\n\nDoxygen has been the defacto standard tool for annotating C++ code and generating HTML documentation for many years. For API-reference style documentation, it is the perfect tool.\n\nHowever, lately, the preferences for documentation have been shifting towards a more example-oriented style, where the documentation focuses more on the how? and why? instead of what?.\n\nOne tool that has been used extensively is Sphinx. Sphinx was originally a documentation tool aimed at Python; however, with plugins, Sphinx can import the XML output from Doxygen and make that information embeddable and referenceable within the reStructuredText markup.\nSource code to HTML\n\nIn this article, we will go over the basics of setting up Sphinx using GitHub actions. The starting point will be source code annotated with Doxygen markup, and the endpoint will be a website with documentation.\n\nWe will go over the following:\n\n    processing the code using Doxygen\n    importing that information into Sphinx\n    automating this process using GitHub actions\n    referring to Doxygen entities inside the reStructuredText format\n    automatically generating an API reference page\n    publishing the resulting HTML on GitHub pages\n\nThe article will demonstrate the process using a simple demo repository with the code in the “src” directory and the documentation input files and configuration in the “docs” directory. The final documentation is published through GitHub pages.\nFrom Doxygen to Sphinx\n\nThere would be little point in redoing all of the code documentation in a different format; thankfully, we don’t have to. We can still document our code using the standard Doxygen syntax and then use the generated XML output as input for Sphinx.\n\nThe plugin that will allow us to do that is Breathe.\n\nIf you are setting this up from scratch and do not use Doxygen, the first step is creating the Doxygen configuration file. All we need from Doxygen is to generate the XML output; therefore, we can turn off all other outputs.\n\nThese are the settings you might want to tweak (to generate the initial config, run “doxygen -g”):\n\nPROJECT_NAME           = \"Modern Documentation\" # Adjust to your needs\nOUTPUT_DIRECTORY       = \"../docs\"              # For the demo repository\nEXTRACT_ALL            = YES\nEXTRACT_PRIVATE        = YES\nRECURSIVE              = YES\nVERBATIM_HEADERS       = NO\nGENERATE_HTML          = NO\nGENERATE_LATEX         = NO\nGENERATE_XML           = YES\n\nThe second part of the equation we need is the configuration for Sphinx. This article uses the “sphinx-book-theme”, and minor changes might be required based on your chosen theme (each theme might offer different options).\n\nThe configuration resides in two files, “conf.py” for the configuration itself:\n\n# Basic configuration\nproject = 'ModernDoc'\ncopyright = '2023, Šimon Tóth'\nauthor = 'Šimon Tóth'\n\n# Extensions to use\nextensions = [ \"breathe\" ]\n\n# Configuration for the breathe extension\n# Which directory to read the Doxygen output from\nbreathe_projects = {\"ModernDoc\":\"xml\"}\nbreathe_default_project = \"ModernDoc\"\n\n# Configuration for the theme\nhtml_theme = \"sphinx_book_theme\"\nhtml_theme_options = {\n    \"repository_url\": \"https://github.com/HappyCerberus/modern-documentation\",\n    \"use_repository_button\": True,\n}\n\nAnd “requirements.txt” to pull in the required python dependencies:\n\nbreathe==4.34.0\nsphinx==4.5.0\nsphinx_book_theme\n\nThe GitHub actions\n\nWith this configuration, we can test the documentation generation locally:\n\n> cd src\n> doxygen ../docs/Doxyfile\n> cd ../docs\n> pip install -r requirements.txt\n> sphinx-build -b html . sphinx\n\nHowever, we never want to do anything manually, so let’s integrate this with GitHub actions.\n\nname: Generate and publish documentation\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  documentation:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout the repo\n        uses: actions/checkout@v3\n      - name: Generate Doxygen documentation\n        uses: mattnotmitt/doxygen-action@v1.9.5\n        with:\n          working-directory: 'src/'\n          doxyfile-path: '../docs/Doxyfile'\n      - name: Process the Doxygen output using Sphinx\n        uses: ammaraskar/sphinx-action@master\n        with:\n          build-command: \"sphinx-build -b html . sphinx\"\n          docs-folder: 'docs/'\n      - name: Deploy to Github pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs/sphinx\n\nThe GitHub workflow will:\n\n    checkout the repository\n    generate Doxygen XML output\n    use that output to generate HTML documentation using Sphinx\n    push that generated HTML documentation to GitHub pages\n\nAlternatively, as the last step, you could commit the resulting HTML into the repository using the “stefanzweifel/git-auto-commit-action@v4” GitHub action.\n\nNote that the GITHUB_TOKEN is available automatically; however, you will need to enable write-access for GitHub actions under Settings>Actions>General>Workflow Permissions.\nThe documentation\n\nNow that we have all the bits, it’s time to focus on the documentation.\n\nAs I mentioned at the beginning of the article, the Sphinx documentation style is oriented towards example-first documentation. This means we need to write the documentation, starting from the “index.rst” file, which serves as the landing page.\n\nWhile we will talk about this later, it is worth mentioning that all other parts of the documentation need to be referenced/linked from the “index.rst” file (indirectly is OK). As we write our documentation, we can reference the Doxygen entities that were imported into Sphinx through the Breathe plugin:\n\nSome important topic\n====================\n\nWhen needed, different parts of the API can be pulled in as references:\n\n.. doxygenfunction:: function\n\nThis reStructuredText input will generate the following output (source code with the Doxygen comment):\n\nWe can also insert portions of the source code into the documentation as examples:\n\nWe can also pull in parts of the code as examples:\n\n.. literalinclude:: ../src/main.cc\n   :language: cpp\n   :lines: 4-7\n\nWill generate:\n\nSphinx will correctly interpret the advanced MarkDown used in Doxygen comments. However, if we desire, we can also go the other way and include reStructuredText as part of the Doxygen comments. The reStructuredText will, of course, not render correctly in the Doxygen-only output (if you are still using it).\n\n/** \\brief A custom type\n\nThis is a longer description for a custom type.\n\n\\verbatim embed:rst\nSome extended information:\n\n.. warning::\n\n    This is a warning.\n\nAn inline example for MyType.\n\n.. code-block:: cpp\n    :linenos:\n\n    MyType x;\n    x.foo();\n\n\\endverbatim\n*/\nstruct MyType {\n    /** \\brief Do a lot of foo */\n    void foo();\n};\n\nThis snippet will render like this:\n\nThe most typical thing you probably want to do is refer to the various Doxygen entities. The full range of supported directives with their options can be found in the Breathe plugin documentation.\nWhat about the API?\n\nWe now have complete control over when a particular piece of information from Doxygen is displayed. However, there is one downside. Doxygen was great for generating the reference API documentation, and we no longer have that unless we manually construct it from scratch, referencing every entity in our code.\n\nFortunately, we can use another plugin that automatically generates an API overview page and the related sub-pages: Exhale.\n\nTo enable it, we need to add it to the “requirements.txt” file and adjust our configuration in “conf.py”:\n\n# Extensions to use\nextensions = [ \"breathe\", \"exhale\" ]\n\n# Configuration for the exhale extensions\nexhale_args = {\n    \"containmentFolder\": \"./api\",\n    \"doxygenStripFromPath\": \"../src\",\n    \"rootFileName\": \"library_root.rst\",\n    \"rootFileTitle\": \"Library API\",\n}\n\nThe output can be further customized. However, for this demonstration, the only customization we do here is setting a custom title for the main generated page.\n\nThe plugin will automatically generate files in the reStructuredText format, which we can link to our documentation. To do that, we need to discuss the final topic: how Sphinx handles multi-file documentation.\nMulti-file documentation\n\nI already mentioned that the “index.rst” file is the core of our documentation, as it needs to reference all the files that are part of it.\n\nAlternatively, if you do not want to do that (or cannot because the content being referenced is generated dynamically), there are options for replacing the entire or parts of the navigation with custom HTML.\n\nAgain, for our demonstration, we will stick to the simple approach and reference the other files in our documentation through the table of contents.\n\n.. toctree::\n   :maxdepth: 2\n\n   self\n   api/library_root\n   other\n\nThe two things worth mentioning here are the “self”, which refers to this document and “api/library_root”, which is the file generated by Exhale (we have specified the directory and the filename in our configuration for the plugin).\n\nThe typical place to put this information is at the end of the “index.rst” file. The table of contents can also be hidden, at which point it will only serve for navigation.\n\nEach referenced file can further adjust the navigation by including a local table of contents that is then expanded recursively.\nThe nontechnical part\n\nThe aim of this article is to cover the technical part of creating modern documentation for your project. However, I would be negligent if I didn’t mention the other side of the coin: what content your documentation should have and how you should structure it.\n\nFortunately, there is a great CppCon 2021 talk on this topic from Christopher Di Bella & Sy Brand:"
        }
      ],
      "id": "1KZBJbNr",
      "createdAt": 1711976572076,
      "updatedAt": 1711976588341
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Tech debt is bad, m’kay?!",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Today we will take a bit of departure from the very focused technical topics and talk about a general Software Engineering topic: technical debt.\n\nTalking about technical debt can be very hard, as it is nontrivial to define and identify its impacts on business performance.\n\nSo often, especially during hard times like the ones we are going through, the discussion boils down to the following:\n\n    Engineer: Tech debt is bad, m’kay?!\n    Manager: Don’t care, do it anyway!\n\nBack to the basics\n\nWhen dealing with fuzzy or hard-to-define topics, it’s worth returning to the basics.\n\nFrom a business perspective, a Software Engineer is a value amplifier. Money goes in, and value comes out.\n\nThe produced value can take many forms:\n\n    it can be software directly sold to customers\n    working on features\n    it can be money saving\n    optimising the cloud bill by improving the performance of services\n    it can be money generation\n    improving algorithms that serve people more relevant products\n    it can be team amplification\n    mentoring younger Engineers that then produce more value by themselves\n\nIf we accept this abstraction, we can reframe technical debt as a source of overhead.\n\nMeaning that with higher technical debt, you either need to put more money in (i.e. more time) or, put another way, for the same amount of money, you will get less value from each of your Software Engineers.\n\nAn important benefit of this abstraction is that it is also understandable to business leaders as it relates technical debt to cost.\n\nWe have established an abstraction, but we still need to determine how to measure technical debt.\nMeasuring technical debt\n\nThe first step before attempting any improvement is always to establish a metric. Otherwise, we would never know what kind of impact (if any) our efforts have.\n\nTrying to measure technical debt directly is a fool’s errand, so let’s focus on a suitable proxy metric instead. Because of our abstraction that equates technical debt with overhead, let’s use that as our proxy.\n\nIf we measure the ratio between productive use of time and overhead activities, we should see this ratio improve as we address technical debt.\nWhat is overhead anyway?\n\nThis, of course, creates a second problem. How do we determine which activities are overhead and which are a productive use of time?\n\nSome activities are obvious overhead caused by technical debt, such as root-causing issues or trying to understand old code.\n\nHowever, some activities are not so clear-cut. For example, poor onboarding can be a significant source of technical debt, but do you count onboarding itself as overhead?\n\nLuckily, if we measure the ratio between productive and unproductive time, where exactly we draw the line isn’t that important. A good start is to pick only the core activities (working on design and code) as productive.\n\nThis will capture other “debt” as overhead, notably institutional debt in the form of excessive meetings or cumbersome procedures. And while that means that we are not measuring strictly technical debt, that is not a bad thing.\n\nThe second type of variance will arise from each person having different standards regarding what they consider overhead and how they measure and record the time spent. But, again, the actual system doesn’t matter as long as everyone is consistent with their approach.\n\nThe goal here isn’t to measure the actual amount of waste but to see the impact of systemic changes on the ratio between productive and unproductive use of time.\nBeware the plateau of despair\n\nOne trap an Engineering organisation can fall into is unmanaged technical debt.\n\nBecause technical debt is compounding, it is relatively easy to reach a point where one-off projects to address technical debt will not produce tangible results. The financial equivalent would be paying off part of your debt while your monthly income remains below your monthly interest.\n\nIn such a situation, addressing technical debt might seem pointless (especially to management).\n\nSo how do you get out of the plateau of despair?\nAddressing technical debt\n\nFinally, let’s discuss some high-level approaches to systematically addressing technical debt.\n\nThe basic idea behind all of these approaches is that they are also compounding, aiming at prevention (decreasing the rate at which we generate technical debt) while at the same time addressing some of the existing technical debt.\nGlobal automated cleanups\n\nAutomated tools, such as clang-tidy auto-fixes, can address straightforward problems. This isn’t necessarily risk-free (especially in a codebase with insufficient test coverage), but it has the benefit of being fast and fully automated.\n\nAt a minimum, all code should have the same formatting and naming style. The formatting can be enforced using clang-format, and naming can be enforced using clang-tidy.\n\nSuch solutions can be deployed as part of the code commit workflow, automatically fixing each commit before it is sent for code review.\nGating\n\nOne of the most effective tools is gating. For example, consider the following situation: your codebase is in a bad state, doesn’t have sufficient test coverage, and produces many warnings, even with the basic set of flags.\n\nAddressing this problem globally would probably take forever and would likely fail. So instead, we can use the gating approach, requiring that any new (or changed) code has 100% delta test coverage and cannot introduce new warnings.\n\nFor some metrics, such an approach can be gated automatically (such as delta test coverage), and some metrics will require a semi-automated approach using code review.\n\nEstablishing gates even for problems currently not present in the code base is typically a worthwhile effort as it prevents any future instances of that type of problem (e.g. deploying address and thread sanitisers while testing, even when the current code base compiles and runs cleanly).\nPeeling the onion\n\nFor some problems, it is worthwhile to sit down and invest in a focused effort to address this one specific problem, notably if this problem is preventing you from deploying a gate.\n\nSuch efforts can quickly spiral out of control, so it is crucial to always focus on a single problem (e.g. cleaning up a single warning) or only focus on one portion of the code base (e.g. cleaning up address sanitiser issues in a single component).\n\nOnce you have peeled the onion, do not forget to establish a gate so this problem doesn’t happen again.\nPruning and grafting\n\nThe best code is often the code that doesn’t exist. In particular, in older codebases, there is a good chance for dead branches that can be pruned from the codebase. Deleted code doesn’t need tests and cannot have bugs.\n\nOn top of deleting code, replacing code is also a great option. Is there a library with a compatible license that you can use to replace a portion of your codebase?\n\nAnswering that will probably not be clear-cut. A 3rd party library won’t be hyper-optimised for your use case, so you will need to weigh the benefit of getting rid of code against the downsides.\nConclusion\n\nFraming technical debt as a source of overhead is a context understandable to business leaders as it spells out the impact on the business.\n\nIt also allows us to establish a simple metric based on overall time spent on overhead activities. Because the goal is to observe an improvement in the ratio, there is no need for precise measurement (each team member being reasonably consistent with their labelling of what they consider overhead is good enough).\n\nOnce the metric is established, systemic solutions focusing on prevention can slowly move the codebase to a better state. Resulting in lower overhead, which will then demonstrate itself in the metric"
        }
      ],
      "id": "fUG1JoAM",
      "createdAt": 1711976597076,
      "updatedAt": 1711976620899
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Numbers are not easy",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Arguably one of the most error-prone parts of C++ is integral and floating-point expressions. As this part of the language is inherited from C, it relies heavily on fairly complex implicit conversion rules and sometimes interacts unintuitively with more static parts of C++ language.\n\nThis article will cover the rules and several surprising corner cases one can encounter when working with integral and floating-point types and expressions.\nIntegral types\n\nThere are two phases of potential type changes when working with integral types. First, promotions are applied to types of lower rank than int, and if the resulting expression still contains different integral types, a conversion is applied to arrive at a common type.\n\nThe ranks of integral types are defined in the standard:\n\n    bool\n    char, signed char, unsigned char\n    short int, unsigned short int\n    int, unsigned int\n    long int, unsigned long int\n    long long int, unsigned long long int\n\nPromotions\n\nAs mentioned, integral promotions are applied to types of lower rank than int (e.g. bool, char, short). Such operands will be promoted to int (if int can represent all the values of the type, unsigned int if not).\n\nPromotions are generally harmless and invisible but can pop up when we mix them with static C++ features (more on that later).\n\nuint16_t a = 1;\nuint16_t b = 2;\n\n// both operands promoted to int\nauto v = a - b;\n// v == -1, decltype(v) == int\n\nOpen this example in Compiler Explorer.\nConversions\n\nConversions apply after promotions when the two operands are still of different integral types.\n\nIf the types are of the same signedness, the operand of the lower rank is converted to the type of the operand with the higher rank.\n\nint a = -100;\nlong int b = 500;\n\nauto v = a + b;\n// v == 400, decltype(v) == long int\n\nOpen this example in Compiler Explorer.\nMixed signedness\n\nI left the complicated part for last. When we mix integral types of different signedness, there are three possible outcomes.\n\nWhen the unsigned operand is of the same or higher rank than the signed operand, the signed operand is converted to the type of the unsigned operand.\n\nint a = -100;\nunsigned b = 0;\nauto v = a + b;\n// v ~ -100 + (UINT_MAX + 1), decltype(v) == unsigned\n\nOpen this example in Compiler Explorer.\n\nWhen the type of the signed operand can represent all values of the unsigned operand, the unsigned operand is converted to the type of the signed operand.\n\nunsigned a = 100;\nlong int b = -200;\nauto v = a + b;\n// v = -100, decltype(v) == long int\n\nOpen this example in Compiler Explorer.\n\nOtherwise, both operands are converted to the unsigned version of the signed operand type.\n\nlong long a = -100;\nunsigned long b = 0; // assuming sizeof(long) == sizeof(long long)\nauto v = a + b;\n// v ~ -100 + (ULLONG_MAX + 1), decltype(v) == unsigned long long\n\nOpen this example in Compiler Explorer.\n\nDue to these rules, mixing integral types can sometimes lead to non-intuitive behaviour.\n\nint x = -1;\nunsigned y = 1;\nlong z = -1;\n\nauto t1 = x > y;\n// x -> unsigned, t1 == true\n\nauto t2 = z < y;\n// y -> long, t2 == true\n\nOpen this example in Compiler Explorer.\nC++20 safe integral operations\n\nThe C++20 standard introduced several tools that can be used to mitigate the issues when working with different integral types.\n\nFirstly, the standard introduced std::ssize(), which allows code that relies on signed integers to avoid mixing signed and unsigned integers when working with containers.\n\n#include <vector>\n#include <utility>\n#include <iostream>\n\nstd::vector<int> data{1,2,3,4,5,6,7,8,9};\n// std::ssize returns ptrdiff_t, avoiding mixing \n// a signed and unsigned integer in the comparison\nfor (ptrdiff_t i = 0; i < std::ssize(data); i++) {\n    std::cout << data[i] << \" \";\n}\nstd::cout << \"\\n\";\n// prints: \"1 2 3 4 5 6 7 8 9\"\n\nOpen this example in Compiler Explorer.\n\nSecond, a set of safe integral comparisons was introduced to correctly compare values of different integral types (without any value changes caused by conversions).\n\n#include <utility>\n\nint x = -1;\nunsigned y = 1;\nlong z = -1;\n\nauto t1 = x > y;\nauto t2 = std::cmp_greater(x,y);\n// t1 == true, t2 == false\n\nauto t3 = z < y;\nauto t4 = std::cmp_less(z,y);\n// t3 == true, t4 == true\n\nOpen this example in Compiler Explorer.\n\nFinally, a small utility std::in_range will return whether the tested type can represent the supplied value.\n\n#include <climits>\n#include <utility>\n\nauto t1 = std::in_range<int>(UINT_MAX);\n// t1 == false\nauto t2 = std::in_range<int>(0);\n// t2 == true\nauto t3 = std::in_range<unsigned>(-1);\n// t3 == false\n\nOpen this example in Compiler Explorer.\nFloating-point types\n\nThe rules for floating-point types are a lot simpler. The resulting type of an expression is the highest floating-point type of the two arguments, including situations when one of the arguments is an integral type (highest in order: float, double, long double).\n\nImportantly, this logic is applied per operator, so ordering matters. In this example, both expressions end up with the resulting type long double; however, in the first expression, we lose precision by first converting to float.\n\n#include <cstdint>\n\nauto src = UINT64_MAX - UINT32_MAX;\nauto m = (1.0f * src) * 1.0L;\nauto n = 1.0f * (src * 1.0L);\n// decltype(m) == decltype(n) == long double\n\nstd::cout << std::fixed << m << \"\\n\" \n    << n << \"\\n\" << src << \"\\n\";\n// prints:\n// 18446744073709551616.000000\n// 18446744069414584320.000000\n// 18446744069414584320\n\nOpen this example in Compiler Explorer.\n\nOrdering is one of the main things to remember when working with floating-point numbers (this is a general rule, not specific to C++). Operations with floating-point numbers are not associative.\n\n#include <vector>\n#include <numeric>\n#include <cmath>\n\nfloat v = 1.0f;\nfloat next = std::nextafter(v, 2.0f);\n// next is the next higher floating pointer number\nfloat diff = (next-v)/2;\n// diff is below the resolution of float\n// importantly: v + diff == v\n\nstd::vector<float> data1(100, diff);\ndata1.front() = v; // data1 == { v, ... }\nfloat r1 = std::accumulate(data1.begin(), data1.end(), 0.f);\n// r1 == v\n// we added diff 99 times, but each time, the value did not change\n\nstd::vector<float> data2(100, diff);\ndata2.back() = v; // data2 == { ..., v }\nfloat r2 = std::accumulate(data2.begin(), data2.end(), 0.f);\n// r2 != v\n// we added diff 99 times, but we did that before adding to v\n// the sum of 99 diffs is above the resolution threshold\n\nOpen this example in Compiler Explorer.\n\nAny operation with floating-point numbers of different magnitudes should be done with care.\nInteractions with other C++ features\n\nBefore I close this article, I need to note two areas where the more static C++ features can cause potential issues when interacting with the implicit behaviour of integral and floating-point types.\nReferences\n\nWhile integral types are implicitly inter-convertible, references to different integral types are not related types and will, therefore, not bind to each other. This has two consequences.\n\nFirst, trying to bind an lvalue reference to a non-matching integral type will not succeed. Second, if the destination reference can bind to temporaries (rvalue, const lvalue), the value will go through an implicit conversion, and the reference will bind to the resulting temporary.\n\nvoid function(const int& v) {}\n\nlong a = 0;\nlong long b = 0;\n// Even when long and long long have the same size\nstatic_assert(sizeof(a) == sizeof(b));\n// The two types are unrelated in the context of references\n// The following two statements wouldn't compile:\n// long long& c = a;\n// long& d = b;\n\n// OK, but dangerous, implict conversion to int\n// int temporary can bind to const int&\nfunction(a);\nfunction(b);\n\nOpen this example in Compiler Explorer.\nType deduction\n\nFinally, we need to talk about type deduction. Because type deduction is a static process, it does remove the opportunity for implicit conversions. However, this also brings potential issues.\n\n#include <vector>\n#include <numeric>\n\nstd::vector<unsigned> data{1, 2, 3, 4, 5, 6, 7, 8, 9};\n\nauto v = std::accumulate(data.begin(), data.end(), 0);\n// 0 is a literal of type int. Internally this means that\n// the accumulator (and result) type of the algorithm will be \n// int, despite iterating over a container of type unsigned.\n\n// v == 45, decltype(v) == int\n\nOpen this example in Compiler Explorer.\n\nBut at the same time, when mixed with concepts, we can mitigate implicit conversions while only accepting a specific integral type.\n\n#include <concepts>\n\ntemplate <typename T>\nconcept IsInt = std::same_as<int, T>;\n\nvoid function(const IsInt auto&) {}\n\nfunction(0); // OK\n// function(0u); // will fail to compile, deduced type unsigned"
        }
      ],
      "id": "yiVksh3d",
      "createdAt": 1711976627097,
      "updatedAt": 1711976637971
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Tree traversal algorithms",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "While the C++ standard library offers a wide range of algorithms, one type that is sadly completely missing so far is graph (and consequently tree) algorithms. While this is being worked on (see P1709), the only choice, for now, is to reproduce the standard solutions from scratch when graph algorithms come up in coding interviews.\nIntroduction\n\nBefore we start with the tree traversal algorithms, it’s worth talking about the tree data structure.\n\nThe most straightforward approach to represent a tree is using a single struct:\n\n#include <memory>\n#include <string>\n\ntemplate <typename T>\nstruct TreeNode {\n    T value = T{};\n    std::unique_ptr<TreeNode> left;\n    std::unique_ptr<TreeNode> right;\n};\n\nauto root = std::make_unique<TreeNode<std::string>>(\n  \"root node\", nullptr, nullptr);\n// root->value == \"root node\"\nroot->left = std::make_unique<TreeNode<std::string>>(\n  \"left node\", nullptr, nullptr);\n// root->left->value == \"left node\"\nroot->right = std::make_unique<TreeNode<std::string>>(\n  \"right node\", nullptr, nullptr);\n// root->right->value == \"right node\"\n\nOpen this example in Compiler Explorer.\n\nThis approach is straightforward and offers a convenient interface. For example, splicing the tree only requires calling std::swap on the source and destination std::unique_ptr.\n\nHowever, it suffers a fatal flaw. Because our data structure is recursive, and we rely on generated destructors, we end up with recursive destruction. A deep enough tree can quickly exhaust the stack during its destruction, leading to memory corruption or a crash.\n\nWe can mitigate this problem by separating the representation of the tree structure from the memory management:\n\n#include <memory>\n#include <vector>\n#include <string>\n\ntemplate <typename T>\nstruct Tree {\n    struct Node {\n        T value = T{};\n        Node* left = nullptr;\n        Node* right = nullptr;\n    };\n    Node* add(auto&& ... args) {\n        storage_.push_back(std::make_unique<Node>(\n          std::forward<decltype(args)>(args)...));\n        return storage_.back().get();\n    }\n    Node* root;\nprivate:\n    std::vector<std::unique_ptr<Node>> storage_;\n};\n\nTree<std::string> tree;\ntree.root = tree.add(\"root node\");\n// tree.root->value == \"root node\"\ntree.root->left = tree.add(\"left node\");\n// tree.root->left->value == \"left node\"\ntree.root->right = tree.add(\"right node\");\n// tree.root->right->value == \"right node\"\n\nOpen this example in Compiler Explorer.\n\nThis completely removes the recursive destruction; however, we pay for that. While we can still splice easily within a tree, splicing between trees becomes cumbersome.\n\nSince we are talking about C++, it’s worth mentioning that neither of the above approaches is performance-friendly. The biggest problem is that we are allocating each node separately, which means that they can be allocated far apart, in the worst case, each node mapping to a different cache line.\n\nOne way to address this problem is to store the nodes inline, with the information about which node is whose child stored separately:\n\n#include <memory>\n#include <vector>\n#include <optional>\n\n#include <string>\n#include <iostream>\n\ntemplate <typename T>\nstruct Tree {\n    struct Children {\n        std::optional<size_t> left = std::nullopt;\n        std::optional<size_t> right = std::nullopt;\n    };\n\n    std::vector<T> data;\n    std::vector<Children> children;\n\n    size_t add(auto&&... args) {\n        data.emplace_back(std::forward<decltype(args)>(args)...);\n        children.push_back(Children{});\n        return data.size()-1;\n    }\n    size_t add_as_left_child(size_t idx, auto&&... args) {\n        size_t cid = add(std::forward<decltype(args)>(args)...);\n        children[idx].left = cid;\n        return cid;\n    }\n    size_t add_as_right_child(size_t idx, auto&&... args) {\n        size_t cid = add(std::forward<decltype(args)>(args)...);\n        children[idx].right = cid;\n        return cid;\n    }\n};\n\n\nTree<std::string> tree;\nauto root = tree.add(\"root node\");\n// tree.data[root] == \"root node\"\nauto left = tree.add_as_left_child(root, \"left node\");\n// tree.data[left] == \"left node\", tree.children[root].left == left\nauto right = tree.add_as_right_child(root, \"right node\");\n// tree.data[right] == \"right node\", tree.children[root].right == right\n\nOpen this example in Compiler Explorer.\n\nNote that we are again adding complexity. This is because we no longer have stable addresses, and each node addition can invalidate the locations of the previous nodes (due to how std::vector handles memory). We, therefore, need to rely on indices, which on the other hand, makes serialization trivial, as indices remain stable.\nTree traversals\n\nThere are four tree traversal types that are worth remembering as they regularly come up as part of coding interviews. We will review each of them and look at some typical applications.\nPre-order traversal\n\nIn pre-order traversal, each node is visited before its children.\n\n// pre-order traversal\nvoid pre_order(Node *node, const std::function<void(Node*)>& visitor) {\n    if (node == nullptr) return;\n    visitor(node);\n    pre_order(node->left, visitor);\n    pre_order(node->right, visitor);\n}\n\nOpen this example in Compiler Explorer.\n\nBecause of this ordering, pre-order traversal is commonly used for serializing and de-serializing.\n\n// serialization using pre-order traversal\nvoid serialize(Node *node, std::ostream& s) {\n    if (node == nullptr) {\n        s << 0 << \" \";\n        return;\n    }\n    s << node->value << \" \";\n    serialize(node->left, s);\n    serialize(node->right, s);\n}\n\n// deserialization using pre-order traversal\nTree<int>::Node *deserialize_single(Tree<int>& tree, std::istream& s) {\n    int value = 0;\n    if (!(s >> value) || value <= 0) return nullptr;\n    return tree.add(value);\n}\n\nTree<int>::Node *deserialize(Tree<int>& tree, std::istream& s) {\n    auto node = deserialize_single(tree, s);\n    if (node == nullptr) return node;\n    node->left = deserialize(tree, s);\n    node->right = deserialize(tree, s);\n    return node;\n}\n\nTree<int> tree;\n// deserialize\ntree.root = deserialize(tree, std::cin);\n// serialize\nserialize(tree.root, std::cout);\nstd::cout << \"\\n\";\n\nOpen this example in Compiler Explorer.\n\nAs mentioned before, the recursive approach can be problematic due to stack exhaustion. So let’s also look at an alternative implementation using a std::stack.\n\nvoid pre_order_stack(Node* root, const std::function<void(Node*)>& visitor) {\n    std::stack<Node*> stack;\n    stack.push(root);\n    while (!stack.empty()) {\n        Node *curr = stack.top();\n        stack.pop();\n        visitor(curr);\n        // With this approach we visit \"null\" nodes, which can be useful.\n        // Alternatively we could move the condition to the push:\n        // if (curr->right != nullptr) stack.push(curr->right);\n        if (curr == nullptr) continue;\n\n        // If we want to maintain the same ordering as recursive pre-order, \n        // we need to insert in reverse.\n        stack.push(curr->right);\n        stack.push(curr->left);\n    }\n}\n\nOpen this example in Compiler Explorer.\nPost-order traversal\n\nIn post-order traversal, each node is visited after its children.\n\n// post-order traversal\nvoid post_order(Node *node, const std::function<void(Node*)>& visitor) {\n    if (node == nullptr) return;\n    post_order(node->left, visitor);\n    post_order(node->right, visitor);\n    visitor(node);\n}\n\nOpen this example in Compiler Explorer.\n\nBecause of this ordering, post-order can be used in expression trees, where we can only evaluate the parent expression if both its children were already evaluated.\n\nstruct Eventual {\n    std::optional<int> result;\n    std::function<int(const Eventual& l, const Eventual& r)> op;\n};\n\nTree<Eventual> tree;\nauto plus = [](const Eventual& l, const Eventual& r) {\n    return *l.result + *r.result;\n};\nauto minus = [](const Eventual& l, const Eventual& r) {\n    return *l.result - *r.result;\n};\nauto times = [](const Eventual& l, const Eventual& r) {\n    return *l.result * *r.result;\n};\n// encode (4-2)*(2+1)\nauto root = tree.root = tree.add(Eventual{std::nullopt, times});\nauto left = root->left = tree.add(Eventual{std::nullopt, minus});\nauto right = root->right = tree.add(Eventual{std::nullopt, plus});\nleft->left = tree.add(Eventual{4, {}});\nleft->right = tree.add(Eventual{2, {}});\nright->left = tree.add(Eventual{2, {}});\nright->right = tree.add(Eventual{1, {}});\n\npost_order(tree.root, [](Node* node) {\n    // if this node already has a result value, we don't have to do anything\n    if (node->value.result) return;\n    // if it is an operation, evaluate post-order guarantees \n    // that node->left->value and node->right->value both have result values\n    node->value.result = node->value.op(node->left->value, node->right->value);\n});\n// *tree.root->value.result == 6\n\nOpen this example in Compiler Explorer.\n\nFor a non-recursive approach, we could visit all nodes in pre-order, remembering each (for example, using a std::stack again) and then iterate over the nodes in reverse order. However, we can do better:\n\nvoid post_order_nonrecursive(Node *root, \n                             const std::function<void(Node*)>& visitor) {\n    std::stack<Node*> s;\n    Node *current = root;\n    while (true) {\n        // Explore left, but remember node & right child\n        if (current != nullptr) {\n            if (current->right != nullptr)\n                s.push(current->right);\n            s.push(current);\n            current = current->left;\n            continue;\n        }\n        // current == nullptr\n        if (s.empty()) return;\n        current = s.top();\n        s.pop();\n        // If we have the right child remembered, \n        // it would be on the top of the stack.\n        if (current->right && !s.empty() && current->right == s.top()) {\n            // if it is, we must visit it (and it's children) first\n            s.pop();\n            s.push(current);\n            current = current->right;\n        } else {\n            visitor(current);\n            current = nullptr;\n        }\n    }\n}\n\nOpen this example in Compiler Explorer.\nIn-order traversal\n\nIn in-order traversal, we visit each node in between visiting its left and right children.\n\n// in-order traversal\nvoid in_order(Node* node, const std::function<void(Node*)>& visitor) {\n    if (node == nullptr) return;\n    in_order(node->left, visitor);\n    visitor(node);\n    in_order(node->right, visitor);\n}\n\nOpen this example in Compiler Explorer.\n\nThe typical use case is when traversing trees with some order to them, and we want that order to be maintained in the traversal.\n\nFor example, in the following example, we create a simple sorted binary tree (for each node, all the nodes in the left subtree have lower or equal values, and all the nodes in the right subtree have higher values) and then traverse it in-order to produce a sorted list of numbers:\n\nvoid add_sorted(Tree<int64_t>& tree, Node* node, int64_t value) {\n    if (value <= node->value) {\n        if (node->left == nullptr)\n            node->left = tree.add(value);\n        else\n            add_sorted(tree, node->left, value);\n    } else {\n        if (node->right == nullptr)\n            node->right = tree.add(value);\n        else\n            add_sorted(tree, node->right, value);\n    }\n}\n\nTree<int64_t> tree;\n// Generate a sorted binary tree with 10 nodes\nstd::mt19937 gen(0); // change the seed for a different output\nstd::uniform_int_distribution<> dist(0,1000);\ntree.root = tree.add(dist(gen));\nfor (int i = 0; i < 9; i++) {\n    add_sorted(tree, tree.root, dist(gen));\n}\n\n// in-order traversal will print the values in sorted order\nin_order(tree.root, [](Node* node) {\n    std::cout << node->value << \" \";\n});\nstd::cout << \"\\n\";\n// stdlibc++: 424 545 549 593 603 624 715 845 848 858 \n// libc++: 9 192 359 559 629 684 707 723 763 835\n\nOpen this example in Compiler Explorer.\n\nThe non-recursive approach is similar to post-order, but we remove the complexity of remembering the right child.\n\nvoid in_order_nonrecursive(Node *root, \n                           const std::function<void(Node*)>& visitor) {\n    std::stack<Node*> s;\n    Node *current = root;\n    while (current != nullptr || !s.empty()) {\n        // Explore left\n        while (current != nullptr) {\n            s.push(current);\n            current = current->left;\n        }\n        // Now going back up the left path visit each node, \n        // then explore the right child.\n        // This works, because the left child was already \n        // visited as we go up the path.\n        current = s.top();\n        s.pop();\n        visitor(current);\n        current = current->right;\n    }\n}\n\nOpen this example in Compiler Explorer.\nRank-order traversal\n\nFinally, it’s worth mentioning the rank-order or the level-order traversal, where we traverse the nodes in the order of their distance from the root node (and typically left-to-right).\n\nWhile all the previous traversals were depth-first search based, this one is based on the breadth-first search algorithm.\n\nvoid rank_order(Node* root, const std::function<void(Node*)>& visitor) {\n    std::queue<Node*> q;\n    if (root != nullptr)\n        q.push(root);\n    while (!q.empty()) {\n        Node* current = q.front();\n        q.pop();\n        if (current == nullptr) continue;\n        visitor(current);\n        q.push(current->left);\n        q.push(current->right);\n    }\n}\n\nOpen this example in Compiler Explorer.\n\nRank-order traversal typically comes up as part of more complex problems. By default, it can be used to find the closest node to the root that satisfies particular criteria or calculate the nodes’ distances from the root.\n\nHere is an example of calculating the maximum value at each level of a tree:\n\nstd::vector<int> max_at_level(Node* root) {\n    std::vector<int> result;\n    std::queue<std::pair<Node*,size_t>> q;\n    if (root != nullptr)\n        q.push({root,0});\n    while (!q.empty()) {\n        auto [node,rank] = q.front();\n        q.pop();\n        if (result.size() <= rank)\n            result.push_back(node->value);\n        else\n            result[rank] = std::max(result[rank], node->value);\n        if (node->left != nullptr)\n            q.push({node->left,rank+1});\n        if (node->right != nullptr)\n            q.push({node->right, rank+1});\n    }\n    return result;\n}\n\nOpen this example in Compiler Explorer.\nComplexity\n\nAll the algorithms I talked about are traversals, so they inherently have O(n) time complexity. However, it’s worth mentioning the space complexity.\n\nFor the depth-first based traversals (pre-order, post-order, in-order), the space complexity is dictated by the maximum depth in the tree.\n\nFor the breadth-first rank-order traversal, the space complexity is dictated by the maximum width in the tree.\n"
        }
      ],
      "id": "RFjGrbn0",
      "createdAt": 1711976641952,
      "updatedAt": 1711976648983
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Error handling",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Exceptions\n\nExceptions are the most fundamental approach to error handling in C++. It is what the vast majority of the standard library uses to report errors, and it is also the approach that is recommended for users. Yet, it is also one of the most divisive features of C++, with major codebases (notably Google) having disabled exceptions altogether.\n\nIf we want to handle exceptions, we surround the code that can potentially throw with a try-catch block. In this example, we throw a standard std::runtime_error and catch it by its base class std::exception.\n\n#include <stdexcept>\n#include <iostream>\n\nvoid error_maker() {\n    throw std::runtime_error(\"This is a runtime error.\");\n}\n\nint main() {\n    try {\n        error_maker();\n    } catch(std::exception& e) {\n        std::cout << \"Failed: \" << e.what() << \"\\n\";\n        // prints: \"Failed: This is a runtime error.\"\n    }\n}\n\nOpen this example in Compiler Explorer.\n\nThis demonstrates one downside of exceptions: the cumbersome nature of the error-handling code.\n\nThe primary reason why exceptions are recommended is that, for many situations, there is no need for any error handling.\nStrong and weak exception guarantee\n\nBefore we demonstrate that, we need to first talk about exception guarantees. When writing any C++ code, we have essentially four options regarding exceptions:\n\n    we can completely ignore exceptions (no exception guarantee)\n    we can guarantee that our code does not throw exceptions (noexcept)\n    we can guarantee that if our code throws, it doesn’t violate any invariants (weak exception guarantee)\n    we can guarantee that if our code throws, the state doesn’t change (strong exception guarantee)\n\nThe strong exception guarantee is effectively transactional. Either the operation succeeds, or nothing changes. The weak exception guarantee permits partial changes (that do not violate invariants).\n\nLet’s demonstrate using a toy type that throws in its constructor on the 5th copy construction.\n\n#include <stdexcept>\n#include <vector>\n#include <set>\n\nstruct TroubleMaker {\n  TroubleMaker(int v) : v(v) {}\n  TroubleMaker(const TroubleMaker& other) : v(other.v) {\n    --counter;\n    if (counter == 0) throw std::runtime_error(\"making trouble!\");\n  }\n  int v;\n  friend auto operator<=>(\n    const TroubleMaker&, const TroubleMaker&) = default;\n  static int counter;\n};\n\nint TroubleMaker::counter = 1000;\n\nstd::vector<TroubleMaker> src{\n  TroubleMaker{1},TroubleMaker{2},TroubleMaker{3},\n  TroubleMaker{4},TroubleMaker{5},TroubleMaker{6},\n  TroubleMaker{7},TroubleMaker{8},TroubleMaker{9},\n};\n\n\nTroubleMaker::counter = 5;\nstd::vector<TroubleMaker> data;\ntry {\n  // This will throw, inserting the 5th element will fail\n  data.insert(data.begin(),src.begin(),src.end());\n} catch(...) {}\n\n// Strong exception guarantee, no change was made to data\n// data.size() == 0\n\n\nTroubleMaker::counter = 5;\nstd::set<TroubleMaker> weak;\ntry {\n  // This will throw, inserting the 5th element will fail\n  weak.insert(src.begin(),src.end()); // std::set::insert\n} catch(...) {}\n\n// Weak exception guarantee, first four elements were inserted\n// all std::set invariants are maintained\n// weak.size() == 4\n\nOpen this example in Compiler Explorer.\n\nThe strongest guarantee is that a piece of code will not throw.\n\n#include <iostream>\n\nstruct A {\n    // this function promises not to throw\n    void something() noexcept;\n};\n\nstruct B {\n    // this function can throw anything\n    void something();\n};\n\n// C++20 concepts can constrain on noexcept\ntemplate <typename T>\nrequires requires (T t) {\n    {t.something() } noexcept;\n}\nvoid our_function(const T&) {\n    std::cout << \"Only noexcept can enter.\\n\";\n}\n\ntemplate <typename T>\nvoid our_function(const T&) {\n    std::cout << \"I can handle anything.\\n\";\n}\n\nint main() {\n    // Call nonexcept variant\n    our_function(A{});\n    // Call handle-anything variant\n    our_function(B{});\n}\n\nOpen this example in Compiler Explorer.\n\nHowever, as is usual with C++, code that declares that it will not throw can still throw. Note, though, that it will result in program termination.\n\nvoid uh_oh() noexcept { throw 1; }\nint main() {\n    uh_oh();\n}\n/* Output:\nterminate called after throwing an instance of 'int'\n*/\n\nOpen this example in Compiler Explorer.\nRAII + exceptions\n\nAs promised, it is time to discuss the exception’s main advantage. If we would write a properly error-handle transactional operation using C-style, it might look something like this:\n\nvoid some_transactional_operation() noexcept {\n    int ret = acquire_resource();\n    if (ret)\n        return;\n    ret = construct_request();\n    if (ret) {\n        release_resource();\n        return;\n    }\n    ret = make_request();\n    if (ret) {\n        free_request();\n        release_resource();\n        return;\n    }\n    ret = construct_response();\n    if (ret) {\n        rollback_request();\n        free_request();\n        release_resource();\n        return;\n    }\n    ret = send_response();\n    if (ret) {\n        free_response();\n        rollback_request();\n        free_request();\n        release_resource();\n        return;\n    }\n    free_response();\n    free_request();\n    release_resource();\n}\n\nOpen this example in Compiler Explorer.\n\nThis is pretty error-prone and hard to read. In C++, we wouldn’t, of course, write the code like this; instead, we would write something to this effect:\n\nvoid some_transactional_operation() noexcept {\n    ResourceHandle resource;\n    if (!resource.acquire())\n        return;\n    std::unique_ptr<Request> request = construct_request();\n    if (request == nullptr)\n        return; // resource released in ResourceHandle destructor \n    int id = make_request(std::move(request)); // hand-off ownership\n    if (id == 0)\n        return;\n    std::unique_ptr<Response> response = construct_response();\n    if (response == nullptr) {\n        rollback_request(id);\n        return;\n    }\n    int ret = send_response(std::move(response)); // hand-off ownership\n    if (ret) {\n        rollback_request(id);\n        return;\n    }\n}\n\nOpen this example in Compiler Explorer.\n\nThis is a lot better. We delegate the cleanup of resources to destructors and hand off ownership where appropriate. However, you might notice an emerging pattern here.\n\n    if (error) return;\n\nAnd this is precisely what exceptions can do for us out of the box. So finally, here is a version using exceptions:\n\nvoid some_transactional_operation() {\n    // If acquire fails, it now throws, since we do not catch\n    // we will exit scope.\n    ResourceHandle resource = ResourceHandle::acquire();\n    // Memory allocation naturally throws, since we do not catch\n    // we will exit scope, triggering ResourceHandle destructor.\n    std::unique_ptr<Request> request = construct_request();\n    // New handle for request that will rollback on destruction.\n    RequestHandle id = make_request(std::move(request));\n    // Same as before, but now we also rollback the request.\n    std::unique_ptr<Response> response = construct_response();\n    // Same\n    send_response(std::move(response));\n    // Finally, release the handle, so it doesn't roll back.\n    id.release();\n}\n\nOpen this example in Compiler Explorer.\n\nThis is very clean. We have zero branching in our code, and all operations rely on RAII for cleanup. But, of course, our function, which previously was noexcept, will now throw on error.\n\nThis leads us to the final point on exceptions, which is the main downside.\nWhen exceptions become cumbersome\n\nThe ideal use case for exceptions is when we handle a sizeable transactional operation that succeeds or fails. Take an HTTP request as an example. This allows us to have only one big try{}catch(){} block on the outermost interface that handles all the errors.\n\nOf course, this brings a problem. What if we care about the different types of errors? In this approach, the exception could be coming from anywhere: it could be from our code, it could be from a 3rd party library, or it could be from the standard library.\n\nThis often means we need to have more try{}catch(){} blocks, potentially translating errors. And sometimes, this can get pretty bad:\n\nvoid our_code() {\n    bool should_retry = true;\n    while (should_retry && !timeout()) {\n        try {\n            some_code();\n        } catch (TerminalError& e) {\n            // process error\n            should_retry = false;\n        } catch (TransientError& e) {\n            // process error\n            continue;\n        }\n    }\n}\n\nOpen this example in Compiler Explorer.\n\nThis is very cumbersome, and if we don’t have uniform types of exceptions in our code and dependencies, it can be very tricky to abstract this logic into a helper function, leaving this pattern sprinkled across our code base.\n\nThere is, unfortunately, a second problem. While the happy path for exceptions is generally faster than when using error codes (as we avoid the repeated if(err) condition checks). The error path for exceptions is generally relatively slow, and treating it as a non-exceptional case can lead to performance problems.\n\nSo let’s look at alternatives.\nError codes\n\nI will skip over the C-style approach here, as we have seen it, but let’s have a look at a translated version of the previous example using error codes:\n\nvoid our_code() {\n    int err = 0;\n    while ((err = some_code()) == TransientError && !timeout());\n    if (err != 0) {\n        // final handling\n        // timeout or TerminalError\n    }\n}\n\nOpen this example in Compiler Explorer.\nstd::error_code\n\nThe first tool in the standard library for handling error codes (without resorting to int) is std::error_code.\n\nIn straightforward terms, std::error_code combines an opaque error code with an “explanation” std::error_category. The standard already provides several categories of errors, notably the std::system_category, which provides the mapping from errno to std::strerror.\n\n#include <system_error>\n#include <iostream>\n\nint main() {\n    // simulate EINTR:\n    auto err = std::error_code(int(EINTR), std::system_category());\n    if (err)\n        std::cout << \"We have an error: \" << err.message() << \"\\n\";\n        // prints: \"We have an error: Interrupted system call\"\n}\n\nOpen this example in Compiler Explorer.\n\nTo customize, users must provide an enum with the list of errors and the corresponding error category and then let the compiler know how these map to each other.\n\n#include <system_error>\n#include <string>\n#include <iostream>\n\n// Custom error enum\nenum class MyErr {\n    ITS_FINE = 0,\n    SOME_ERROR = 1,\n    SOME_OTHER_ERROR = 2,\n};\n\n// Custom category that maps MyErr->std::string\nstruct MyCategory : std::error_category {\n    const char* name() const noexcept override {\n        return \"MyCategory\";\n    }\n    std::string message( int condition ) const override {\n        using namespace std::string_literals;\n        switch(condition) {\n            case 0: return \"everything is fine\"s;\n            case 1: return \"we got some error\"s;\n            case 2: return \"something else happened\"s;\n        }\n        return \"\"s;\n    }\n};\n\n// Register our enum as an error code\n// so we can constructor error_code from it\ntemplate<> struct std::is_error_code_enum<MyErr> \n    : public std::true_type{};\n\n// Tells the compiler that MyErr pairs with MyCategory\nstd::error_code make_error_code(MyErr e) {\n    return std::error_code(static_cast<int>(e), MyCategory());\n}\n\n// And now we can use it:\nstd::error_code my_function() noexcept {\n    return MyErr::SOME_ERROR;\n}\n\nint main() {\n    if (auto err = my_function(); err) {\n        std::cout << err.message() << \"\\n\";\n        // prints: \"we got some error\"\n    }\n}\n\nOpen this example in Compiler Explorer.\n\nThe typical use of std::error_code is either in place of a return error code or as an extra argument, potentially to distinguish between a throwing and noexcept version of an API (see <filesystem>).\n\n#include <system_error>\n\n// throwing variant\nvoid something(int arg) {\n    throw std::runtime_error(\"error\");\n}\n// noexcept variant\nvoid something(int arg, std::error_code& err) noexcept {\n    err = make_error_code(std::errc::interrupted);\n}\n\nOpen this example in Compiler Explorer.\nstd::expected (C++23)\n\nUsing std::error_code maybe be inconvenient when we need to return some other type, as then we would have to return it as an output argument (as seen in the previous example).\n\nThis is when the latest addition to the C++ error-handling arsenal comes in. std::expected is either the expected return type or the unexpected type (error). The type provides an interface similar to std::optional and is biased towards the expected path.\n\n#include <iostream>\n#include <string>\n#include <expected>\nusing namespace std::string_literals;\n\nstd::expected<std::string,std::error_code> function(bool fail) {\n    if (fail)\n        return std::unexpected(make_error_code(std::errc::no_message));\n    return \"This is a string\"s;\n}\n\nint main() {\n    // query-based interface\n    std::cout << function(true).value_or(\"default string\"s) << \"\\n\";\n    // prints: \"default string\"\n\n    // pointer-style interface\n    if (auto res = function(false); res) { // same as res.has_value()\n        std::cout << *res << \"\\n\"; // same as res.value()\n        \n    }\n    // prints: \"This is a string\"\n\n    if (auto res = function(true); !res.has_value()) {\n        // error() method to access the unexpected part\n        std::cerr << res.error().message() << \"\\n\";\n    }\n}\n\nOpen this example in Compiler Explorer.\n\nTogether with the std::optional the std::expected also received the monadic interface.\n\n#include <expected>\n#include <string>\n#include <iostream>\n\nstd::expected<int,std::string> count_up(int v) {\n    if (v >= 3) {\n        return std::unexpected(\"that's to much\");\n    }\n    return v+1;\n}\n\nstd::expected<int,std::string> deep_thought(std::string err) {\n    std::clog << \"Failed to count up : \" << err << \"\\n\";\n    return 42;\n}\n\nint main() {\n    auto v = count_up(1)\n        .and_then(count_up);\n    // *v == 3\n\n    auto w = count_up(1) // 1->2\n        .and_then(count_up) // 2->3\n        .and_then(count_up) // 3->error\n        .and_then(count_up) // skipped\n        .or_else(deep_thought); // error->42\n    // *w == 42\n}\n\nOpen this example in Compiler Explorer.\nConclusion\n\nWhile not worth its section, it should be noted that std::abort() is a good way to handle terminal errors, particularly when continuing would present the danger of data corruption.\n\nIn summary:\n\n    Choose exceptions when you can keep the code free of error handling.\n    Choose error codes when: errors are frequent, or there is a need for tight error handling, or noexcept interface is preferable/needed\n    Choose std::expected if you would choose error codes and can use C++23."
        }
      ],
      "id": "3fLYlnz_",
      "createdAt": 1711976654096,
      "updatedAt": 1711976664645
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::reference_wrapper, std::ref, std::cref",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::reference_wrapper is a simple indirection wrapper that can implicitly convert to the wrapped type.\n\nstd::reference_wrapper has special interactions with std::make_pair and std::make_tuple (where the type is deduced as T&) and can force reference semantics for APIs where the default behaviour involves a copy.\n\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <random>\n\nvoid fun(const std::vector<int>&, int) {}\n\nstd::vector<int> data{1,2,3,4,5};\n\n// The result of bind_front has value semantics, \n// meaning the results are stored by copy.\nauto fn1 = std::bind_front(fun, data);\nfn1(42);\n\n// std::ref returns a std::reference_wrapper, avoiding the copy.\n// However, now fn2 cannot outlive data.\nauto fn2 = std::bind_front(fun, std::ref(data));\nfn2(42);\n\nint x{};\n// std::make_pair and std::make_tuple have special handling\n// for std::reference_wrapper\nauto t = std::make_tuple(x, std::ref(x), std::cref(x));\n// decltype(t) == std::tuple<int, int&, const int&>\n\nstd::vector<int> rand;\nstd::mt19937 rng;\n// We could wrap rng in a lambda, but we can also use\n// a std::reference_wrapper, which also provides operator()\nstd::generate_n(std::back_inserter(rand), 10, std::ref(rng));\n\n// Wouldn't compile:\n// std::reference_wrapper<int> wrap1(42); // Cannot wrap temporaries\n// std::reference_wrapper<int> wrap2; // Cannot be \"null\""
        }
      ],
      "id": "Y6tRXwQk",
      "createdAt": 1711976690269,
      "updatedAt": 1711976694238
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::tie, std::ignore",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::tie is a C++11 utility from the tuple header that creates a tuple of lvalue references to the arguments.\n\nWhile structured bindings in C++17 replaced the primary use case, std::tie remains useful when combined with std::ignore or as a tool to simplify the implementation of comparisons.\n\n#include <tuple>\n\nstd::pair<double,int> fun() { return {4.2, 42}; }\n\nint x{};\nconst double y{};\n\n// Creates a tuple of lvalue references\nauto t1 = std::tie(x, y);\n// decltype(t1) == std::tuple<int&, const double&>\n\n// std::tie can be used as a less elegant version\n// of structured bindings\ndouble i{}; int j{};\nstd::tie(i,j) = fun();\n// i == 4.2, j == 42\n\n// std::ignore can be combined with std::tie to skip over some fields\nstd::tie(std::ignore, j) = std::pair{0.0, 7};\n// i == 4.2, j == 7\n\n// We can use std::tie to re-use structured binding identifiers\nauto v = std::pair{4.2, 42};\nauto [m, n] = v; // copy of v\n// m == 4.2, n == 42\n\nstd::tie(m, n) = std::pair{1.1, 2};\n// m == 1.1, n == 2\n\nauto& [p, q] = v; // in this case we have a reference to v\nstd::tie(p, q) = std::pair{1.1, 2};\n// v == {1.1, 2}, p == 1.1, q == 2\n\n\nstruct Coord {\n    int x;\n    int y;\n\n    // We can use std::tie to simplify some operations\n    bool operator<(const Coord& other) const {\n        return std::tie(x, y) < std::tie(other.x, other.y);\n    }\n    bool operator==(const Coord& other) const {\n        return std::tie(x, y) == std::tie(other.x, other.y);\n    }\n    friend void swap(Coord& l, Coord& r) {\n        std::swap(std::tie(l.x, l.y), std::tie(r.x, r.y));\n    }\n};\n\nCoord a{1, 1}, b{1, 2};\n// (a < b) == true, (a == b) == false\nswap(a, b);\n// a == {1, 2}, b == {1, 1}"
        }
      ],
      "id": "gDnJ_B91",
      "createdAt": 1711976700007,
      "updatedAt": 1711976707524
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::forward_like",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Correctly forwarding the value category for a member of a compound type before C++23 was cumbersome.\n\nForunately C++23 introduced the std::forward_like, which makes this operation a lot simpler.\n\nThe std::forward_like is also essential when using the “deducing this” feature.\n\n#include <utility>\n\nstruct Wrapper {\n    int member;\n};\n\nvoid fun(const int&) {}\nvoid fun(int&) {}\nvoid fun(int&&) {}\n\n// Only calls fun(int&) or fun(const int&)\nvoid extract1(auto&& wrapper) {\n    fun(wrapper.member);\n}\n\n// Correct, but cumbersome\nvoid extract2(auto&& wrapper) {\n    if constexpr (std::is_rvalue_reference_v<decltype(wrapper)>) {\n        fun(std::move(wrapper.member));\n    } else {\n        fun(wrapper.member);\n    }\n}\n\n// Using C++23 forward_like\nvoid extract3(auto&& wrapper) {\n    fun(std::forward_like<decltype(wrapper)>(wrapper.member));\n}\n\n// Typical use case\nstruct MyType {\n    auto&& get(this auto&& self) {\n        // One getter variant covering all value categories\n        return std::forward_like<decltype(self)>(self.data);\n    }\n    int data;\n};\n\nWrapper w;\nextract1(w); // calls fun(int&)\nextract1(std::as_const(w)); // calls fun(const int&)\nextract1(Wrapper{}); // calls fun(int&)\n\nextract2(w); // calls fun(int&)\nextract2(std::as_const(w)); // calls fun(const int&)\nextract2(Wrapper{}); // calls fun(int&&)\n\nextract3(w); // calls fun(int&)\nextract3(std::as_const(w)); // calls fun(const int&)\nextract3(Wrapper{}); // calls fun(int&&)"
        }
      ],
      "id": "6WDffpEO",
      "createdAt": 1711976712720,
      "updatedAt": 1711976718727
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::istreambuf_iterator, std::ostreambuf_iterator",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "A simple option to handle formatted I/O is using istream and ostream iterators.\n\nHowever, both iterators will interpret special characters.\n\nTo address this, the standard library also offers istreambuf and ostreambuf iterators that instead operate on the stream buffer, without additional semantics.\n\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Open a file\nstd::ifstream in(\"./example.cpp\", std::ios::binary);\n\n// Read the content of the file into a vector\nstd::vector<char> file{std::istreambuf_iterator<char>(in), \n    std::istreambuf_iterator<char>()};\n// Default initialized iterator represents EOF\n\n// Write the content of the vector into standard output\nstd::ranges::copy(file, \n    std::ostreambuf_iterator<char>(std::cout));\n\nstruct Custom {\n    // When using istreambuf/ostreambuf iterators to implement \n    // stream extraction/insertion, make sure to correctly set\n    // eof state when end iterator is reached (and fail state \n    // when parsing fails).\n    friend std::istream& operator>>(std::istream& s, Custom&) {\n        // Do all the implementation specific operations on \n        // the stream so that it's ready for a manual read.\n        std::istream::sentry all_good{s, true};\n        if (not all_good) return s;\n\n        std::istreambuf_iterator<char> it{s};\n        std::istreambuf_iterator<char> end{};\n\n        for (int i = 0; i < 2; ++i, ++it) {\n            // If we are at eof and did not manage \n            // to read two characters.\n            if (it == end) {\n                // Set the eof flag\n                s.setstate(std::ios_base::eofbit);\n                return s;\n            }\n\n            // Check that the first two characters match the first\n            // line: #include <fstream>\n            char c = *it;\n            if (i == 0 && c != '#') {\n                s.setstate(std::ios_base::failbit);\n                return s;\n            }\n            if (i == 1 && c != 'i') {\n                s.setstate(std::ios_base::failbit);\n                return s;\n            }\n        }\n\n        return s;\n    }\n};\n\nin.seekg(0);\nCustom custom;\nin >> custom;"
        }
      ],
      "id": "T5jbzJiQ",
      "createdAt": 1711976724268,
      "updatedAt": 1711976731099
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::weak_ptr",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::weak_ptr is a smart pointer type that can be constructed from a std::shared_ptr instance.\n\nA std::weak_ptr instance does not count towards owning references and will therefore not keep the held instance alive; however, it can be safely upgraded to a std::shared_ptr.\n\n#include <memory>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n#include <iostream>\n#include <list>\n\nstruct Item {\n    // Holding a weak pointer does not imply ownership.\n    std::weak_ptr<Item> next;\n  \n    void touch_next() {\n        // Attempt to upgrade to a std::shared_ptr that will\n        // only live for the duration of the if statement.\n        if (auto owned = next.lock(); owned != nullptr)\n            std::cout << \"Next in line is \" << owned.get() << \"\\n\";\n    }  \n};\n\n{\nstd::vector<std::shared_ptr<Item>> data;\n// Fill with 16 items that loop around\nstd::generate_n(std::back_inserter(data), 16, \n                [](){ return std::make_shared<Item>(); });\nfor (size_t i = 0; i < data.size(); i++) {\n    if (i+1 < data.size())\n        data[i]->next = data[i+1]; // point to the next\n    else\n        data[i]->next = data[0]; // cycling back to the first\n}\n\ndata[5]->touch_next();\n// Example output: Next in line is 0x16ca4e0\n// data[6].get() == 0x16ca4e0\n}\n// All items are correctly destructed at this point.\n\n\nstruct Something{};\nstruct Observer {\n    // Observer can safely keep track of objects\n    // without affecting their lifetime.\n    std::list<std::weak_ptr<Something>> global_objects;\n    \n    void register_global(std::weak_ptr<Something> global) {\n        global_objects.push_back(std::move(global));\n    }\n    \n    void observe() {\n        auto it = global_objects.begin();\n        while (it != global_objects.end()) {\n            if (auto owned = it->lock(); owned != nullptr) {\n                std::cout << \"Observing \" << owned.get() << \"\\n\";\n                it++;\n            } else {\n                it = global_objects.erase(it); // already gone, drop\n            }\n        }\n    }\n};\n\nObserver observer;\nauto global1 = std::make_shared<Something>();\nauto global2 = std::make_shared<Something>();\n\nobserver.register_global(global1);\nobserver.register_global(global2);\n\nobserver.observe(); // observes both global objects\n\nglobal1.reset();\nobserver.observe(); // observes global2\n// observer.global_objects.size() == 1"
        }
      ],
      "id": "p8PQ1bIv",
      "createdAt": 1711976736232,
      "updatedAt": 1711976741760
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::unreachable",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::unreachable is a tool for injecting undefined behaviour into a program. A typical use case is in an else branch or the default case of a switch.\n\nCompilers can use this undefined behaviour and optimise the corresponding branch away.\n\nWhile we can achieve the same behaviour with [[assume(false)]], std::unreachable provides a more readable and logical name.\n\n#include <utility>\n\n__attribute__((noinline)) int fun1(int x) {\n    switch (x) {\n        case 1: return 0;\n        case 2: return 1;\n        case 4: return 2;\n        case 8: return 3;\n    }\n    return -1;\n}\n\n__attribute__((noinline)) int fun2(int x) {\n    switch (x) {\n        case 1: return 0;\n        case 2: return 1;\n        case 4: return 2;\n        case 8: return 3;\n        default: std::unreachable();\n        // same as [[assume(false)]];\n    }\n    return -1;\n}\n\n__attribute__((noinline)) int fun3(int x) {\n    return x / 4;\n}\n\n__attribute__((noinline)) int fun4(int x) {\n    if (x < 0) std::unreachable();\n    // same as [[assume(x < 0)]];\n    return x / 4; // can be optimized into x >> 2\n}"
        }
      ],
      "id": "Q4a7VnG6",
      "createdAt": 1711976764776,
      "updatedAt": 1711976769064
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Custom memory resources",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When working with C++17 memory resources, you might want to implement a custom resource.\n\nFortunately, this is straightforward. The PMR library offers an abstract base class std::pmr::memory_resource.\n\nA custom memory resource has to derive from this class and implement the private methods do_allocate, do_deallocate and do_is_equal.\n\n#include <memory_resource>\n#include <string>\n#include <print>\n#include <list>\n#include <ranges>\n\n// A simple tracing memory resource that uses an upstream resource\n// for allocation, but prints information about the allocated\n// or deallocated memory.\nstruct Tracer : std::pmr::memory_resource {\n    Tracer(std::string_view label, std::pmr::memory_resource* upstream)\n      : label_(label), up_(upstream) {}\nprivate:\n    // allocation implementation\n    void* do_allocate(\n      std::size_t bytes, std::size_t alignment) override {\n        void* ptr = up_->allocate(bytes, alignment);\n        std::println(\"[{}] allocated {}, \"\n                     \"{} bytes with {} byte allignment\",\n            label_, ptr, bytes, alignment);\n        return ptr;\n    }\n    // deallocation implementation\n    void do_deallocate(\n      void* p, std::size_t bytes, std::size_t alignment) override {\n        std::println(\"[{}] deallocating {}, \"\n                     \"{} bytes with {} byte alignment\",\n            label_, p, bytes, alignment);\n        up_->deallocate(p, bytes, alignment);\n    }\n    // used to determine whether the container using this resource\n    // can move or has to fallback to a copy\n    // we cannot move across resources\n    bool do_is_equal(\n      const std::pmr::memory_resource& other) const noexcept override {\n        // Tracer is transparent, so a Tracer(&res) == res\n        if (up_ == &other)\n            return true;\n        // Two different tracers are equivalent\n        // if they point to the same backing resource\n        if (auto* ptr = dynamic_cast<const Tracer*>(&other); \n            ptr != nullptr)\n            return up_ == ptr->up_;\n        return false;\n    }  \n\n    std::string label_;\n    std::pmr::memory_resource* up_;\n};\n\nint main() {\n    Tracer system(\"system\", std::pmr::new_delete_resource());\n    std::pmr::unsynchronized_pool_resource pool_res(&system);\n    Tracer pool(\"pool\", &pool_res);\n\n    std::pmr::list<std::pmr::string> list(&pool);\n    for (auto _ : std::views::iota(0, 128)) {\n        list.push_back(\n          \"This is going to allocate because \"\n          \"it doesn't fit into SSO.\");\n    }\n}"
        }
      ],
      "id": "LhdtiBg3",
      "createdAt": 1711976773298,
      "updatedAt": 1711976778660
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "placeholder name _",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Since C++26, we can finally avoid the cumbersome need to name objects even when the name doesn’t matter using the placeholder name _.\n\nFor variables with dynamic lifetimes, non-static members, lambda captures and structured bindings, the _ can redefine existing instances in the same scope.\n\nIf the _ has a unique meaning (no redefinition), it can still be referenced.\n\n#include <map>\n#include <mutex>\n\nstd::map<int, int> data{{1,2},{2,1},{3,4},{4,3}}; \n\n// Iterate over values, ignoring keys\nfor (auto& [_, value] : data) {\n  // {2, 1, 4, 3}\n}\n\nstd::mutex mux;\n{\n    // RAII-only objects do not need to be named\n    auto _ = std::unique_lock{mux}; \n    /*\n    critical section\n    */\n} // lock released\n\n// Multiple _ named variables with dynamic storage duration,\n// non-static member variables, bindings and captures\n// can redeclare previous _ in the same scope\nauto _ = 42;\nauto _ = 7;\n\nstruct S {\n    int _;\n    int _;\n} s{42, 7};\n\n// Unique (i.e. not re-declared) _ can still be referenced\n{\n    auto _ = [](auto _) { return _; };\n    int x = _(42);\n    // x == 42;\n}"
        }
      ],
      "id": "8-peQd4V",
      "createdAt": 1711976791243,
      "updatedAt": 1711976800967
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::invoke_r",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When using std::invoke in generic code, you can run into situations when the result type of the invocation is inconvenient.\n\nThe C++23 std::invoke_r allows the return type to be explicitly specified, avoiding cumbersome wrapping code.\n\n#include <functional>\n\nstruct Box {\n    int value;\n};\n\nBox x{42};\nauto&& a = std::invoke(&Box::value, x); // OK\nauto&& b = std::invoke(&Box::value, Box{42}); // Bad, danling reference\n\n// std::invoke_r allows the return type to be specified\nauto&& c = std::invoke_r<int>(&Box::value, Box{42}); // OK\n\n// void is also valid, discarding any potential result\nstd::invoke_r<void>(&Box::value, Box{42});\n\n\n// Collapsing covariant return types\nstruct Base {} base;\nstruct Derived : Base {} derived;\n \nBase& fun(int) { return base; }\nDerived& fun(double) { return derived; }\n\n// Wrapper for the overload set\nauto wrapped = [](auto arg) -> decltype(auto) { return fun(arg); };\n\nauto& i1 = std::invoke(wrapped, 42); // calls fun(int)\n// decltype(i1) == Base&\nauto& i2 = std::invoke(wrapped, 4.2); // calls fun(double)\n// decltype(i2) == Derived&\n\nauto& i3 = std::invoke_r<Base&>(wrapped, 42); // calls fun(int)\n// decltype(i3) == Base&\nauto& i4 = std::invoke_r<Base&>(wrapped, 4.2); // calls fun(double)\n// decltype(i4) == Base&"
        }
      ],
      "id": "AevECtNL",
      "createdAt": 1711976810914,
      "updatedAt": 1711976816762
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::elements",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 std::views::elements takes a range of tuple-like objects and produces a view over the n-th element from each tuple.\n\nThe concept of tuple-like was formalized in C++23 and includes std::array, std::complex (C++26), std::pair, std::tuple and std::ranges::subrange.\n\n#include <ranges>\n#include <vector>\n#include <array>\n\nstd::vector<std::pair<int,double>> data{{1,2.7}, {3, 4.2}, {-1, 3.3}};\n\nfor (auto v : data | std::views::elements<0>) {} // {1, 3, -1}\nfor (auto v : data | std::views::elements<1>) {} // {2.7, 4.2, 3.3}\n\nstd::array<std::array<int,3>,3> grid{1,2,3,4,5,6,7,8,9};\nfor (auto v : grid | std::views::elements<2>) {} // {3, 6, 9}"
        }
      ],
      "id": "dBWI2bJf",
      "createdAt": 1711976822158,
      "updatedAt": 1711976826584
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::shared_ptr basics",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::shared_ptr is a powerful yet heavy, ref-counted smart pointer.\n\nDifferent instances of std::shared_ptr that point to the same block can be safely handled without thread synchronization.\n\nstd::shared_ptr is useful for data handoff in multi-threaded code. A producer can relinquish ownership while ensuring that consumers do not lose access to the data.\n\n#include <vector>\n#include <thread>\n#include <random>\n#include <algorithm>\n#include <memory>\n\nstd::vector<std::jthread> runners(4);\n\n{\n// some simple data generation (not that relevant)\nstd::vector<uint32_t> data_in;\nstd::mt19937 rng;\nstd::generate_n(std::back_inserter(data_in), \n                1024*1024, std::ref(rng));\n\n// Create a shared pointer from the vector.\n// Note the const, making the data immutable.\nauto shared =\n    std::make_shared<const std::vector<uint32_t>>(std::move(data_in));\n\n// Start the threads, giving each thread a copy of the shared_ptr\nfor (auto &thread : runners) {\n    thread = std::jthread([shared]() {\n      // accessing const-methods of STL containers is thread-safe\n      for (auto v : *shared) { \n          // process data...\n      }\n    });\n}\n}\n\n// 4 runner threads are all running, but the local reference\n// to the data is no longer held.\n\n// The data will be released once all runners finish, thus releasing\n// their references to the data, i.e. the ref-count reaches zero.\n\n// std::jthread auto-joins on destruction, or we can do it explicitly:\nfor (auto &thread : runners) {\n    thread.join();\n}"
        }
      ],
      "id": "oul0heof",
      "createdAt": 1711976831728,
      "updatedAt": 1711976836947
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::replace_copy, std::replace_copy_if",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When we need to copy the content of a range, replacing some of the elements as we copy, we can use the std::replace_copy and std::replace_copy_if algorithms.\n\nBoth algorithms support projections in their range versions.\n\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> in{1,2,3,4,5};\nstd::vector<int> out(5);\n\nstd::replace_copy(in.begin(), in.end(), // copy from in\n    out.begin(), // to out\n    2, -1); // replacing elements of value 2 with -1\n// out == {1, -1, 3, 4, 5}\n\nstd::replace_copy_if(in.begin(), in.end(), // copy from in\n    out.begin(), // to out\n    [](int v) { return v % 2 != 0; }, // replacing odd elements\n    0); // with zero\n// out == {0, 2, 0, 4, 0}\n\nstd::vector<std::string> labels{\"a\", \"b\", \"hello\", \"bye\", \"e\"};\nstd::vector<std::string> out2(5);\n\n// Example with a projection\nstd::ranges::replace_copy(labels, out2.begin(),\n    1, \"---\", // Replace strings of length 1 with \"---\"\n    [](const std::string& s) { return s.length(); });\n// out2 == {\"---\", \"---\", \"hello\", \"bye\", \"---\"}"
        }
      ],
      "id": "n0-F_2wF",
      "createdAt": 1711976842814,
      "updatedAt": 1711976848949
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::forward",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::forward is a conditional r-value (specifically x-value) cast.\n\nstd::forward is primarily designed to work in conjunction with universal references and will only cast to an r-value if the template argument isn’t an l-value reference type.\n\n#include <utility>\n\nstruct X {};\n\nvoid some_func(const X&) {}\nvoid some_func(X&&) {}\n\n// Typical use case\nvoid forwarding_function(auto&& arg) {\n    // perfect forwarding, as if we called some_func directly\n    some_func(std::forward<decltype(arg)>(arg));\n}\n\n\nX x;\n// r-value cast, calls some_func(X&&)\nsome_func(std::forward<decltype(x)>(x));\n\nX&& y = X{};\n// r-value cast, calls some_func(X&&)\nsome_func(std::forward<decltype(y)>(y));\n\n// note that names of variables are always l-values\nsome_func(y); // calls some_func(const X&)\n\nX& z = x;\n// no cast, calls some_func(const X&)\nsome_func(std::forward<decltype(z)>(z));\n\nconst X& w = x;\n// no cast, calls some_func(const X&)\nsome_func(std::forward<decltype(w)>(w));"
        }
      ],
      "id": "44kfi0JC",
      "createdAt": 1711976855513,
      "updatedAt": 1711976860083
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Concepts as template arguments",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "A current limitation of concepts is that we cannot pass concepts as arguments to templates. At least not directly.\n\nThe following trick by Filip Sajdak allows us to wrap concepts in lambdas and then pass those lambdas as non-type template arguments. With the help of an indirection concept, we can then check types against this wrapped concept.\n\n#include <concepts>\n\n// Indirect concept check through a lambda\ntemplate <auto wrapper, typename T>\nconcept satisfies_wrapped_concept = requires {\n    { wrapper.template operator()<T>() };\n};\n\n// Template parametrized using a wrapped concept and a type\ntemplate <auto WrappedConcept, typename T>\n// Limit T to types that satisfy the passed in concept\nrequires satisfies_wrapped_concept<WrappedConcept, T>\nstruct Box {};\n\n// Demonstration of use:\ntemplate <typename T>\n// Box parametrized for integral types\nusing BoxForIntegrals = Box<[]<std::integral>{},T>;\ntemplate <typename T>\n// Box parametrized for floating point types\nusing BoxForFloats = Box<[]<std::floating_point>{},T>;\n\nint main() {\n    BoxForIntegrals<int> a; // OK\n    // BoxForIntegrals<float> b; // Wouldn't compile\n    BoxForFloats<float> c; // OK\n    // BoxForFloats<int> d; // Wouldn't compile\n}"
        }
      ],
      "id": "dq6jqEIN",
      "createdAt": 1711976863360,
      "updatedAt": 1711976868594
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::getenv",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "On POSIX systems, the environment variables can be accessed through the global variable char** environ. This variable is also typically passed as the third argument to main.\n\nFor a portable solution, the standard offers the std::getenv function. Note that while the function returns char*, modifying the returned string is UB.\n\n#include <cstdlib>\n#include <ranges>\n#include <print>\n\nint main() {\n    std::println(\"LD_LIBRARY_PATH:\");\n  \n    // Get the LD_LIBRARY_PATH variable\n    if (const char* record = std::getenv(\"LD_LIBRARY_PATH\");\n        record != nullptr) { // nullptr if the variable is not set\n      \n        std::string_view str = record;\n        // Iterate over the chunks, delimited by ':'\n        for (auto chunk : str | std::views::split(':')) {\n            std::println(\"\\t{}\", \n                         std::string_view(chunk.begin(), chunk.end()));\n        }\n    }\n}"
        }
      ],
      "id": "3UhcxOCH",
      "createdAt": 1711976874992,
      "updatedAt": 1711976879277
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::format_to, std::format_to_n Šimon Tóth  Šimon Tóth ·",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 <format> introduced a modern approach to text formatting.\n\nWhen formatting to a buffer or a stream, the std::string returning std::format may not be suitable.\n\nThe library offers two overloads that instead output the formatted text through an output iterator: std::format_to and std::format_to_n, which also limits the number of characters written.\n\n#include <format>\n#include <vector>\n#include <string_view>\n#include <iostream>\n#include <iterator>\n\nstd::vector<char> buffer;\nint x = 42;\n// formatting into a dynamic buffer\nstd::format_to(std::back_inserter(buffer), \"x == {}\", x);\n\nstd::string_view str1(buffer.begin(), buffer.end());\n// str1 == \"x == 42\"\n\n// Also works for output to streams\nstd::format_to(std::ostream_iterator<char>(std::cout), \"x == {}\\n\", x);\n// prints: x == 42\n\nstd::array<char, 32> static_buffer;\n// formatting into a static buffer\nstd::format_to_n(static_buffer.begin(), 32,\n    \"Today is {}, Expected temperature is {} Celsius\",\n    \"Tuesday\", 24);\n\nstd::string_view str2(static_buffer.begin(), static_buffer.end());\n// str2 == \"Today is Tuesday, Expected tempe\""
        }
      ],
      "id": "XXY2Q65y",
      "createdAt": 1711976905607,
      "updatedAt": 1711976911419
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::exit, std::atexit",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "During normal program termination, any registered callbacks using std::atexit are executed as part of the cleanup. The callbacks follow the initialization and destruction rules from C++11.\n\nFor example, if a construction of a static object was ordered before a callback is registered, the destruction of that object will be sequenced after the callback is invoked.\n\n#include <print>\n\nvoid callback_a() {\n    std::println(stderr, \"callback A\");\n}\n\nvoid callback_b() {\n    std::println(stderr, \"callback B\");\n}\n\nstruct Global {\n    ~Global() { std::println(stderr, \"~Global()\"); }\n};\n\nGlobal global;\n\nint main() {\n    std::atexit(callback_a);\n    std::atexit(callback_b);\n    // Implicit call to std::exit(0);\n    \n    // Calling std::Exit(int); or std::quick_exit(int); \n    // will not invoke the callbacks\n}\n/* Guaranteed output:\ncallback B\ncallback A\n~Global()\n*/"
        }
      ],
      "id": "N1u6NgR7",
      "createdAt": 1711976914924,
      "updatedAt": 1711976919510
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Saturation arithmetic",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++26 introduced a set of saturating arithmetic operations: addition, subtraction, multiplication, division and cast.\n\nIf the specified integral type cannot represent the result of the operation, the result is instead std::numeric_limits::min() or std::numeric_limits::max() (whichever is closer).\n\n#include <numeric>\n#include <limits>\n\nint x = std::numeric_limits<int>::max();\n// x + 1 is UB\nint y = std::add_sat(x,1); // OK\n// y == x\n\n\nint a = std::numeric_limits<int>::min();\n// a / -1 is UB\nint b = std::div_sat(a,-1); // OK\n// b == std::numeric_limits<int>::max()\n\n\nuint16_t c = std::saturate_cast<uint16_t>(-1);\n// c == 0"
        }
      ],
      "id": "DHfjqlde",
      "createdAt": 1711976924308,
      "updatedAt": 1711976929603
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::swap_ranges",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::swap_ranges algorithm does a piecewise swap of two ranges of elements.\n\nConsequently, std::swap_ranges has linear complexity but allows for swapping heterogeneous ranges.\n\nAdditionally, when working with containers that dynamically allocate memory, a swap might not be a suitable choice, especially with custom allocators or memory resources.\n\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> first{1,2,3,4};\nstd::vector<int> second{9,8,7,6};\nsecond.reserve(128);\n// first == {1,2,3,4}, second == {9,8,7,6}\n// first.capacity() == 4, second.capacity() == 128\n\nstd::ranges::swap(first, second);\n// first == {9,8,7,6}, second == {1,2,3,4}\n// first.capacity() == 128, second.capacity() == 4\n\nstd::ranges::swap_ranges(first, second);\n// first == {1,2,3,4}, second == {9,8,7,6}\n// first.capacity() == 128, second.capacity() == 4\n\n// Unlike swap, swap_ranges can swap between ranges of different types\nstd::array<int, 4> arr;\n\nstd::ranges::swap_ranges(first, arr);\n// first == {0,0,0,0}, arr == {1,2,3,4}"
        }
      ],
      "id": "0J5K-31J",
      "createdAt": 1711976934099,
      "updatedAt": 1711976938940
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::from_chars",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++17 std::from_chars is a low-level integer and floating-point parsing function.\n\nImportantly, std::from_chars doesn’t require or assume null termination and operates on a range of characters delimited using two pointers.\n\nThis behaviour is useful when parsing from data streams, memory or when working with std::string_view.\n\n#include <string_view>\n#include <charconv>\n#include <print>\n\nstd::string_view i1 = \"1234\";\nint o1{};\nstd::from_chars(i1.data(), i1.data()+i1.size(), o1);\n// o1 == 1234\n\n\n// The function returns information about potential errors\n// and the end of parsed section\nstd::string_view i2 = \"123Hello\";\nint o2{};\nauto [ptr, err] = std::from_chars(i2.data(), i2.data()+i2.size(), o2);\n// *ptr == 'H', err == Success\n// o2 == 1234\n\nstd::string_view i3 = \"-4\";\nunsigned o3{};\nauto [ptr, err] = std::from_chars(i3.data(), i3.data()+i3.size(), o3);\n// *ptr == '-', err == Invalid argument\n\nint o4{};\nauto [ptr, err] = std::from_chars(i3.data(), i3.data()+i3.size(), o4);\n// ptr == i3.end(), err == Success\n// o4 == -4\n\n\n// Base can be specified (but the function doesn't parse the prefix)\nstd::string_view i4 = \"0xFE\"; // hexadecimal\nstd::string_view i5 = \"077\";  // octal\nint o5{};\n\ni4 = i4.substr(2); // Skip the hexadecimal prefix\nstd::from_chars(i4.data(), i4.data()+i4.size(), o5, 16);\n// o5 == 0xfe\n\ni5 = i5.substr(1); // Skip the octal prefix\nstd::from_chars(i5.data(), i5.data()+i5.size(), o5, 8);\n// o5 == 077\n\n\n// Floating point support\nstd::string_view i6 = \"3.14\";\ndouble o6{};\nstd::from_chars(i6.data(), i6.data()+i6.size(), o6);\n// o6 == 3.14\n\nstd::string_view i7 = \"0.1e-15\";\ndouble o7{};\nstd::from_chars(i7.data(), i7.data()+i7.size(), o7);\n// o7 == 0.1e-15"
        }
      ],
      "id": "KRbp628d",
      "createdAt": 1711976942960,
      "updatedAt": 1711976947968
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Heterogeneous lookup in unordered containers",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "While heterogeneous lookup in ordered containers has been available since C++14, we only got heterogeneous lookup for unordered containers in C++20.\n\nTo enable heterogeneous lookup, the container must be instantiated with a hasher and an equality comparator that support all types we want to use for lookup.\n\n#include <unordered_map>\n#include <string>\n#include <cstdint>\n\nstruct string_hash {\n  // required to denote a transparent hash\n  using is_transparent = void;\n  // Hash operations required to be consistent: \n  // a == b => hash(a) == hash(b)\n  size_t operator()(const char *txt) const {\n      return std::hash<std::string_view>{}(txt);\n  }\n  size_t operator()(std::string_view txt) const {\n      return std::hash<std::string_view>{}(txt);\n  }\n  size_t operator()(const std::string &txt) const {\n      return std::hash<std::string>{}(txt);\n  }\n};\n\n// Unordered map with a transparent hasher and std::equal_to\n// (since std::string already provides operator==)\nstd::unordered_map<std::string, std::string, \n       string_hash, std::equal_to<>> string_map;\nstring_map.insert_or_assign(\"a\", \"label_a\");\nstring_map.insert_or_assign(\"b\", \"label_b\");\n\n// No conversion and therefore no allocation here:\nauto i = string_map.find(\"long_key_that_requires_allocation\");\n// i == string_map.end()\n\n\n// Custom key type:\nstruct Wrapped {\n  int64_t value;\n  static auto make(int64_t v) { return Wrapped{v}; }\nprivate:\n  // Private constructor to demonstrate that this isn't a conversion\n  Wrapped(int64_t v) : value(v) {};\n};\n\n// Custom transparent hash:\nstruct wrapped_hash {\n  using is_transparent = void;\n  size_t operator()(int64_t value) const {\n     return std::hash<int64_t>{}(value);\n  }\n  size_t operator()(const Wrapped& wrapped) const {\n      return std::hash<int64_t>{}(wrapped.value);\n  }\n};\n\n// Custom comparator:\nstruct wrapped_cmp {\n  using is_transparent = void;\n  bool operator()(int64_t left, const Wrapped& right) const {\n      return left == right.value; \n  }\n  bool operator()(const Wrapped& left, const Wrapped& right) const {\n      return left.value == right.value; \n  }\n};\n\n// Unordered map with both the hasher and comparator customized\nstd::unordered_map<Wrapped, std::string,\n       wrapped_hash, wrapped_cmp> data;\ndata.insert_or_assign(Wrapped::make(10), \"Hello World!\");\ndata.insert_or_assign(Wrapped::make(5), \"Goodbye!\");\n\n// No conversion, lookup directly using int64_t\nauto j = data.find(5z);\n// j->first == Wrapped{5}, j->second == \"Goodbye!\""
        }
      ],
      "id": "r_sssWI0",
      "createdAt": 1711976996410,
      "updatedAt": 1711977004416
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::partial_sort",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "While using std::sort to sort a range is reasonably fast, it is still wasteful if you only require the top few elements.\n\nThe std::partial_sort will only sort the top k elements with O(n*logk) time complexity and will even outperform std::nth_element if k is small compared to n.\n\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> data{3,9,8,5,1,2,7,4,6};\n\n// partially sort, so that the first three elements are sorted\nstd::partial_sort(data.begin(), data.begin()+3, data.end());\n// data == {1, 2, 3, ...}\n\n// range version with a custom comparator\nstd::ranges::partial_sort(data, data.begin()+3, std::greater<>{});\n// data == {9, 8, 7, ...}\n\n\nstruct V { int v; };\nstd::vector<V> nested{{3},{9},{8},{5},{1},{2},{7},{4},{6}};\n\n// projecting each element to the v member\nstd::ranges::partial_sort(\n nested, nested.begin()+3, std::less<>{}, &V::v);\n// nested == {{1}, {2}, {3}, ...}"
        }
      ],
      "id": "3IKqvMQ1",
      "createdAt": 1711977009451,
      "updatedAt": 1711977014443
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::bind_back",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::bind_back is a complementary utility to std::bind_front, which binds the last n arguments of a callable.\n\nA call to std::bind_back(Callable, bound args…)(call args…) is equivalent to std::invoke(Callable, call args…, bound args…).\n\n#include <functional>\n#include <iostream>\n\nauto f = [](int a, int b, int c, int d, int e, int f) {\n    std::cout << a << \" \" << b << \" \" << c << \" \" << \n        d << \" \" << e << \" \" << f << \"\\n\";\n};\nauto bound = std::bind_back(f, 1, 2, 3);\nbound(4,5,6);\n// prints: 4 5 6 1 2 3\n\n\n// Alternative to complex default arguments/wrapping lambdas\nstruct MainArg{};\nvoid do_stuff(MainArg, int option1, int option2, int option3) {}\n\nconstexpr auto do_stuff_one_way = std::bind_back(do_stuff,2,1,-3);\n// do_stuff_one_way(MainArg{});\nconstexpr auto do_stuff_another_way = std::bind_back(do_stuff,-7,6,2);\n// do_stuff_another_way(MainArg{});"
        }
      ],
      "id": "oLppQUPm",
      "createdAt": 1711977019530,
      "updatedAt": 1711977023982
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::find_end",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::find_end algorithm operates similarly to std::search; however, instead of returning the first instance of a subrange in a range, it returns the last.\n\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> haystack{1,2,3,4,5,1,2,3,4,5};\nstd::vector<int> needle{3,4};\n\nauto it = std::find_end(\n    haystack.begin(), haystack.end(),\n    needle.begin(), needle.end());\n// (it - haystack.begin()) == 7\n\n\n// Ranges version returns the found instance as a subrange\nauto rng = std::ranges::find_end(haystack, needle);\n// rng == {3,4}\n\n\n// Both versions support custom comparator\nstd::string sentence = \"Word word WORD wORD\";\nstd::string word = \"word\";\n\nauto case_sen = std::ranges::find_end(sentence, word);\n// case_sen == \"word\";\n\nauto case_ins = std::ranges::find_end(sentence, word,\n [](char l, char r){\n     return std::tolower(l) == std::tolower(r);\n });\n// case_ins == \"wORD\""
        }
      ],
      "id": "WWTiiTO8",
      "createdAt": 1711977043647,
      "updatedAt": 1711977051517
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "decltype(auto)",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "One problem you can run into with auto type-deduction is when using auto to deduce the result type of a function.\n\nThe solution can be decltype(auto), which, unsurprisingly, follows the decltype rules for determining the type.\n\n#include <type_traits>\n#include <functional>\n\n// Same as auto v = 1;, i.e. int\nauto f1() { return 1; }\n// Same as int x; auto v = x;, i.e. int\nauto f2() { static int x = 1; return x; }\n// Same as auto v = f2();, i.e. int\nauto f3() { return f2(); }\n// All three functions deduce int\n// f2 (and transitively f3) results in a copy\n\nstatic_assert(std::is_same_v<decltype(f1()), int>);\nstatic_assert(std::is_same_v<decltype(f2()), int>);\nstatic_assert(std::is_same_v<decltype(f3()), int>);\n\n\nint get_temp() { return 1; }\nint& get_var() { static int x = 1; return x; }\n\n// Same as decltype(get_temp()), i.e. int\ndecltype(auto) f4() { return get_temp(); }\n// Same as decltype(get_var()), i.e. int&\ndecltype(auto) f5() { return get_var(); }\n\nstatic_assert(std::is_same_v<decltype(get_temp()), int>);\nstatic_assert(std::is_same_v<decltype(f4()), int>);\nstatic_assert(std::is_same_v<decltype(get_var()), int&>);\nstatic_assert(std::is_same_v<decltype(f5()), int&>);\n\n\n// Notably this is importantly when working with generic callables\ndecltype(auto) wrap(auto&& arg, auto projection) {\n    return projection(std::forward<decltype(arg)>(arg));\n}\n\n// Using std::identity: wrap(int{}, identity)\n// int&& argument, forwarded and passed through as int&&\nstatic_assert(std::is_same_v<\n              decltype(wrap(int{}, std::identity{})), int&&>);\n\nint x = 42;\n// Using std::identity{}: wrap(x, identity)\n// int& argument, forwarded and passed through as int&\nstatic_assert(std::is_same_v<\n              decltype(wrap(x, std::identity{})), int&>);\n\nauto custom = [](int arg) { return arg; };\n// Using a custom projection that returns int: wrap(42, custom)\n// int&& argument, bound into int, returned as int\nstatic_assert(std::is_same_v<\n              decltype(wrap(42, custom)), int>);"
        }
      ],
      "id": "F9oD1ARV",
      "createdAt": 1711977060823,
      "updatedAt": 1711977068606
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::reverse_copy",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::reverse_copy is a simple algorithm that copies the source bidirectional range in reverse order into the output range.\n\nTypically, std::reverse_copy offers a more natural solution than using std::copy with reverse iterators.\n\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> data{1,2,3,4,5,6,7,8,9};\nstd::vector<int> out;\n\nstd::reverse_copy(data.begin(), data.end(),\n    std::back_inserter(out));\n// out == {9, 8, 7, 6, 5, 4, 3, 2, 1}\n\nout.clear();\n// same as:\nstd::copy(data.rbegin(), data.rend(), \n    std::back_inserter(out));\n// out == {9, 8, 7, 6, 5, 4, 3, 2, 1}"
        }
      ],
      "id": "Eew29S_f",
      "createdAt": 1711977113885,
      "updatedAt": 1711977117568
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::move, std::move_backward",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::move and std::move_backward algorithms are complementary algorithms to std::copy and std::copy_backward that move each element from the source range to the destination.\n\nAll variants will fall back to a copy when operating with immovable types.\n\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nstruct Movable {\n    int v = 42;\n    Movable() = default;\n    Movable(Movable&& other) : v(std::exchange(other.v, -1)) {}\n    Movable& operator=(Movable&& other) {\n        v = std::exchange(other.v, -1);\n        return *this;\n    }\n};\n\nstd::vector<Movable> data;\ndata.emplace_back(); data.emplace_back(); data.emplace_back();\n\nstd::vector<Movable> out(3);\n// std::ranges::copy(data, out.begin()); // Wouldn't compile\nstd::ranges::move(data, out.begin()); // OK\n// out == {{42}, {42}, {42}}, data == {{-1}, {-1}, {-1}}\n\n// Overlapping ranges\nstd::vector<int> rng{1,2,3,4,5,6,7,8,9};\n// The begining of output range cannot overlap with input range\n//     | input range |\n// | output range | \nstd::move(\n    rng.begin()+4, rng.end(), // input\n    rng.begin()); // output\n// rng == {5, 6, 7, 8, 9, _, _, _, _}\n\nrng = {1,2,3,4,5,6,7,8,9};\n// The begining of input range cannot overlap with output range\n// | input range | \n//    | output range |\nstd::move_backward(\n    rng.begin(), rng.end()-4, // input\n    rng.end()); // output\n// rng == {_, _, _, _, 1, 2, 3, 4, 5}\n\n// Copy-only types:\nstruct CopyOnly {};\nconst std::vector<CopyOnly> src(5); // immutable source\nstd::vector<CopyOnly> dst(5);\n\n// We cannot move from an immutable container, defaults to copy\nstd::move(src.begin(), src.end(), dst.begin());\nstd::ranges::move(src, dst.begin());"
        }
      ],
      "id": "b4qQAKYB",
      "createdAt": 1711977133601,
      "updatedAt": 1711977143374
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "auto type deduction",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When using auto, the type deduction follows the rules for template type deduction.\n\nOne practical consequence of these rules is that auto will never deduce a reference.\n\nOtherwise, the two corner cases to remember are:\n\n    auto&& is always deduced and, therefore, a universal/forwarding reference (unlike T&& inside a template)\n    the behaviour when using list initialization\n\n#include <initializer_list>\n#include <type_traits>\n#include <utility>\n\nint x{};\nconst int y{};\n\n// auto will not deduce a reference\nauto v1 = x;\n// decltype(v1) == int\n\n// unless the left side type is a reference\n// the top-level cv-qualifers are discarded\nauto v2 = y;\n// decltype(v2) == int\n\nauto &v3 = x; // OK\n// decltype(v3) == int&\n\n// if the left side type is a reference, the cv-qualifiers are kept\nauto &v4 = y;\n// decltype(v4) == const int&\n\n// auto &v5 = int{}; // Wouldn't compile\n// Cannot bind int&& to auto&\n\nconst auto &v6 = int{}; // OK\n// decltype(v6) == const int&\n\n\n// Special case: universal/forwarding reference\n// Universal references maintain value category\nauto&& u1 = x;\n// decltype(u1) == int&\n\nauto&& u2 = std::move(x); // or auto&& u2 = int{};\n// decltype(u2) == int&&\n\nauto&& u3 = y;\n// decltype(u3) == const int&\n\nauto&& u4 = std::move(y); // OK, but not a useful category\n// decltype(u4) == const int&&\n\n\n// Special case: list initialization\nauto l1 = {1}; // Copy-list initialization -> initializer list\n// decltype(l1) == std::initializer_list<int>\n\nauto l2 = {1,2,3}; // OK\n// decltype(l2) == std::initializer_list<int>\n\nauto l3{1}; // Direct list initialization -> the element type\n// decltype(l3) == int\n\n// auto l4{1,2,3}; // Wouldn't compile\n// only one element allowed for direct list initialization"
        }
      ],
      "id": "bgLGMS1q",
      "createdAt": 1711977147265,
      "updatedAt": 1711977154313
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::search_n",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::search_n is a simple algorithm that returns the first instance of n consecutive elements that match the provided value.\n\nThe range version conveniently returns the range representing the n consecutive elements, and both versions support a custom comparator.\n\n#include <algorithm>\n#include <ranges>\n#include <cmath>\n#include <vector>\n\nstd::vector<int> data{1,7,3,3,9,5,5,5,6,2};\n\n// First instance of three consecutive '5'\nauto it = std::search_n(data.begin(), data.end(), 3, 5);\n// std::views::counted(it, 3) == {5, 5, 5}\n\n// Range version returns a range\nauto rng = std::ranges::search_n(data, 2, 3);\n// rng == {3, 3}\n\n// Comparator can be customized\nstd::vector<double> approximate{2.4, 2.9, 3.0, 3.8, 3.1};\nauto floor = std::ranges::search_n(approximate, 3, 3.0,\n    [](double a, double b) {\n        return std::floor(a) == std::floor(b);\n    });\n// odd == {3.0, 3.8, 3.1}"
        }
      ],
      "id": "V6bykvlg",
      "createdAt": 1711977158521,
      "updatedAt": 1711977163909
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Explicit/Full template specialization",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "All templates can be fully specialized (unlike partial specialization, which only works for struct/class and variables).\n\nThis mechanism can be used to provide more optimized code for concrete types or as a customization point for libraries.\n\n#include <string_view>\n\n// Function templates example\ntemplate <typename X>\nvoid fun(const X&) {}\n\n// Full specialization must always fully match the base template\ntemplate <> void fun<int>(const int&) {}\ntemplate <> void fun<bool>(const bool&) {}\n\n// Wouldn't compile, argument mismatch\n// template<> void fun<double>(double) {}\n// Wouldn't compile, return type mismatch\n// template<> bool fun<double>(const double&) {}\n\n// Functions can coexist with matching specializations without conflict\n// Resolution will prefer functions over templates\n// (but prioritize number of implicit coversions over that)\nvoid fun(const int&) {}\nvoid fun(const double&) {}\n\nfun(4.2); // fun(const double&)\nfun(42); // fun(const int&)\nfun(true); // fun<bool>(const bool&) (specialization)\nfun(long{42}); // fun<long>(const long&) (base template)\n\n\n// Base template without implementation\ntemplate <typename T> struct DoSomething;\n// Full specialization for concrete type\ntemplate<> struct DoSomething<int> {\n    void do_stuff() {}\n};\n\nDoSomething<int>{}.do_stuff(); // OK\n// DoSomething<double>{}.do_stuff(); // Wouldn't compile\n\n\n// Base template provides the default value\ntemplate <typename T>\nconstexpr std::string_view label = \"unknown type\";\n\n// Full specializations for concrete types\ntemplate <>\nconstexpr std::string_view label<unsigned> = \"unsigned integer\";\n\n// label<unsigned> == \"unsigned integer\"\n// label<void> == \"unknown type\""
        }
      ],
      "id": "_ceu_jxP",
      "createdAt": 1711977167703,
      "updatedAt": 1711977172865
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::latch",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::latch is one of the simple synchronization primitives introduced with C++20.\n\nLatches are initialized to a specific count, can be atomically decreased and used to block until the count reaches zero.\n\n#include <latch>\n#include <thread>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <array>\n#include <ranges>\n\n// Simple and inefficient parallel sum\nconstexpr uint64_t chunks = 4;\nconstexpr uint64_t total = 1024*1024;\nconstexpr uint64_t chunk_size = total/chunks;\n\n// Random, but consistent input\nstd::vector<uint32_t> data;\nstd::mt19937 rng(1);\nstd::generate_n(std::back_inserter(data), total, std::ref(rng));\n\nstd::latch parallel_done(chunks);\nstd::array<uint64_t, chunks> sums;\nstd::array<std::jthread, chunks> executors;\n\nfor (auto [chunk, result, exec] : \n    std::views::zip(data | std::views::chunk(chunk_size), \n                    sums, executors)) {\n    // Start a thread for each chunk, \n    // storing the result in the corresponding slot\n    exec = std::jthread([&, chunk] {\n        result = std::ranges::fold_left(\n          chunk, 0uz, std::plus<uint64_t>{});\n        // Atomically decrement the latch\n        parallel_done.count_down();\n    });\n}\n// Block until all threads have produced a sum\nparallel_done.wait();\n\n// Final reduction, sum up the partial sums\nuint64_t sum = std::ranges::fold_left(sums, 0uz, std::plus<>{});"
        }
      ],
      "id": "Q5a3o7mO",
      "createdAt": 1711977176890,
      "updatedAt": 1711977187193
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::byteswap",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::byteswap is a simple C++23 utility from the <bit> header that swaps the order of bytes in an integral variable.\n\nIn combination with std::endian (C++20), std::byteswap offers a portable solution when serialized data is stored in a different byte order than the native endianness.\n\n#include <bit>\n#include <print>\n \nuint32_t native_endian = 0x12345678;\nuint32_t flipped_endian = std::byteswap(native_endian);\n// flipped_endian == 0x78563412\n\n// Combining with std::endian\nuint32_t value = 0x0DF0ADBA;\nif constexpr (std::endian::native != std::endian::big)\n    value = std::byteswap(value);\n// value == \"0xBAADF00D\" (on little-endian machines)"
        }
      ],
      "id": "-SX2V90U",
      "createdAt": 1711977193292,
      "updatedAt": 1711977200173
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Dependent names",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "One thing to keep in mind when implementing templated classes is the handling of dependent names.\n\nName lookup for non-dependent names is done before the template is instantiated, which can sometimes lead to surprising behaviour.\n\n#include <iostream>\nconstexpr auto printer = []{ std::cout << \"The global one.\\n\"; };\n\nstruct Printer {\n    void printer() { std::cout << \"The internal one.\\n\"; }\n};\n\n\nstruct X : Printer {\n   // Printer::printer found by non-ADL lookup\n    void fun() { printer(); }\n};\n\nX{}.fun(); // prints: \"The internal one.\"\n\n\ntemplate <typename T> struct Y : T {\n   // Non-dependent name, bound to ::printer\n    void fun() { printer(); }\n};\n\nY<Printer>{}.fun(); // prints: \"The global one.\"\n\n\ntemplate <typename T> struct Z : T {\n   // Pulling Printer::printer into current scope\n    using T::printer;\n    // Early binding will find Z::printer, which a dependent name\n    // Non-ADL lookup will then also find Z::printer,\n    // which is resolved into Printer::printer\n    void fun() { printer(); }\n};\n\nZ<Printer>{}.fun(); // prints: \"The internal one.\"\n\n\ntemplate <typename T> struct W : T {\n    // Alternative approach, dependent name because W derives from T.\n    void fun() { this->printer(); }\n};\n\nW<Printer>{}.fun(); // prints: \"The internal one.\""
        }
      ],
      "id": "CdnKUS2e",
      "createdAt": 1711977207018,
      "updatedAt": 1711977219091
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::merge",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::merge algorithm merges two sorted ranges, outputting into a third range.\n\nThe algorithm is stable. Equal elements from the first range precede elements from the second range, and the order of equal elements is otherwise unchanged.\n\n#include <vector>\n#include <algorithm>\n#include <string>\n\nstd::vector<int> first{1, 2, 5};\nstd::vector<int> second{2, 3, 4};\nstd::vector<int> out;\n\nstd::merge(\n    begin(first), end(first),   // first input range\n    begin(second), end(second), // second input range\n    std::back_inserter(out));   // output range\n// out == {1, 2, 2, 3, 4, 5}\n\n\nfirst = {5, 3, 1};\nsecond = {4, 2};\nout = {};\n\nstd::ranges::merge(first, second, \n    std::back_inserter(out),\n    std::greater<>{}); // Custom comparator \n// out = {5, 4, 3, 2, 1}\n\n\nstruct Value {\n    int x;\n    std::string label;\n    bool operator<(const Value& v) const {\n        return x < v.x;\n    }\n};\n\nstd::vector<Value> a{{0, \"a1\"}, {0, \"a2\"}, {1, \"a3\"}};\nstd::vector<Value> b{{0, \"b1\"}, {1, \"b2\"}, {1, \"b3\"}};\nstd::vector<Value> c;\n\nstd::ranges::merge(a, b, std::back_inserter(c), std::less<>{});\n// c == {\"a1\", \"a2\", \"b1\", \"a3\", \"b2\", \"b3\"}"
        }
      ],
      "id": "0ww5mtfB",
      "createdAt": 1711977224793,
      "updatedAt": 1711977230717
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::declval",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When implementing generic code that relies on decltype, you can run into a problem.\n\nIf a type cannot be default constructed, we won’t be able to spell an instantiation of that type within an expression.\n\nUsing std::declval, we can obtain an lvalue reference without creating a value.\n\nNote that std::declval can only be used in unevaluated contexts (e.g. decltype).\n\n#include <utility>\n#include <type_traits>\n#include <functional>\n\ntemplate <typename T>\nauto fun(T t) { return t+1.0; }\n\nstruct MyInt {\n    MyInt() = delete; // Not default constructible\n    friend int operator+(const MyInt&, double) { return {}; }\n    int method() { return {}; }\n};\n\n// Get the result type of fun for double and int, all OK\nstatic_assert(\n    std::is_same_v<decltype(fun(double{})), double>);\nstatic_assert(\n    std::is_same_v<decltype(fun(int{})), double>);\n\n// But we cannot spell the same for MyInt\n// static_assert(\n//    std::is_same_v<decltype(fun(MyInt{})), int>); // Wouldn't compile\n\n// std::declval allows us to declare a value without creating it\nstatic_assert(\n    std::is_same_v<decltype(fun(std::declval<MyInt>())), int>);\n\n// Same logic also applies to methods:\n\n// Wouldn't compile\n// static_assert( \n//    std::is_same_v<decltype(MyInt{}.method()), int>);\n\nstatic_assert(\n    std::is_same_v<decltype(std::declval<MyInt>().method()), int>);"
        }
      ],
      "id": "myJrXwi6",
      "createdAt": 1711977235270,
      "updatedAt": 1711977241979
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "decltype",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The decltype specifier can be used to obtain the declared type of an entity or the type of an expression.\n\nTo treat an entity (technically id-expression or class member access expression) as an expression, it can be surrounded by parenthesis.\n\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nstd::vector<int> data{1,2,3,4,5};\n\n// lvalue expression -> T&\nstatic_assert(\n    std::is_same_v<decltype(data[2]), int&>);\nstatic_assert(\n    std::is_same_v<decltype(std::as_const(data)[2]), const int&>);\n\n// prvalue expression -> T\nstatic_assert(\n    std::is_same_v<decltype(1+2), int>);\n\n// xvalue expression -> T&&\nstatic_assert(\n    std::is_same_v<decltype(std::move(data)), std::vector<int>&&>);\n\nconst struct X { int x = 42; } x;\n\n// id or member -> the declared type\nstatic_assert(\n    std::is_same_v<decltype(x), const X>);\nstatic_assert(\n    std::is_same_v<decltype(x.x), int>);\n\n// we can treat ids/members as expressions\nstatic_assert(\n    std::is_same_v<decltype((x)), const X&>);\nstatic_assert(\n    std::is_same_v<decltype((x.x)), const int&>);"
        }
      ],
      "id": "96QBvbpS",
      "createdAt": 1711977247179,
      "updatedAt": 1711977251347
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::numeric_limits",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::numeric_limits is a base template whose specializations (for integral and floating point types) expose the various properties of those numerical types (limits and behaviour).\n\nThe template can be specialized for user types.\n\n#include <limits>\n#include <string>\n#include <cstdint>\n\nstatic_assert(std::numeric_limits<int>::is_exact == true);\nstatic_assert(std::numeric_limits<double>::is_exact == false);\n\nint v = std::numeric_limits<int>::max();\n// v == 2147483647 (for 32bit int)\nstd::println(\"v == {}\", v);\n\n// Query whether a type has a numeric_limits specialization:\nstatic_assert(\n    std::numeric_limits<std::string>::is_specialized == false);\n\nint digits = std::numeric_limits<int64_t>::digits10;\n// digits == 18\n// int64_t can represent all 18 digit decimal numbers\nstd::println(\"digits == {}\", digits);"
        }
      ],
      "id": "fEJkwfev",
      "createdAt": 1711977255235,
      "updatedAt": 1711977260057
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": " std::fill, std::generate",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::fill and std::generate are simple range-fill algorithms.\n\nThe std::fill algorithm fills the supplied range with copies of the provided value.\n\nThe std::generate algorithm fills the range with the results of successively invoking the provided callable.\n\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> data(10);\n\n// Order of invocation is guaranteed\nstd::generate(data.begin(), data.end(),\n    [iota = 1] mutable {\n        return iota++;\n    });\n// data == {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\nstd::fill(data.begin(), data.end(), 42);\n// data == {42, 42, 42, 42, 42, 42, 42, 42, 42, 42}\n\nstd::vector<int> empty;\n\n// Both algorithms have a counted variant that takes \n// an iterator and the number of elements.\nstd::fill_n(std::back_inserter(empty), 5, 7);\n// empty == {7, 7, 7, 7, 7}"
        }
      ],
      "id": "eiaURriv",
      "createdAt": 1711977271070,
      "updatedAt": 1711977276108
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Standard layout types",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Standard layout class (struct, union) types offer three important benefits:\n\n    offsetof only works for standard layout types\n    pointer to a standard layout type and its first member are pointer-interconvertible\n    if a standard layout union contains standard layout structs, the common initial sequence can be accessed even through non-active members\n\n#include <type_traits>\n\n/* Standard layout type requirements:\n- no virtual methods\n- no non-static non-standard layout members or base classes\n- same access control for all non-static members\n- only one class in the hierarchy contains non-static members\n*/\n\nstruct A { int x; }; // Standard layout\nstatic_assert(std::is_standard_layout_v<A>);\n\nstruct B : A {}; // OK, only inheriting standard layout types\nstatic_assert(std::is_standard_layout_v<B>);\n\nstruct C { virtual ~C() {} }; // Not SL, virtual method\nstatic_assert(not std::is_standard_layout_v<C>);\n\nstruct D : A { int y; }; // Not SL\n                         // both D and A contain non-static members\nstatic_assert(not std::is_standard_layout_v<D>);\n\nstruct E {\n    int x;\n    static C c;\n}; // Standard layout, C is not SL, but is a static member\nstatic_assert(std::is_standard_layout_v<E>);\n\nstruct F {\n    int x;\nprivate:\n    int y;\n}; // Not SL, mixed access\nstatic_assert(not std::is_standard_layout_v<F>);\n\nA a;\nA* ptr = &a;\nint* x = reinterpret_cast<int*>(ptr); // Well defined\n*x = 42;\n// *x == ptr->x == 42\n\n\nstruct V1 { int version = 1; int data = 42; };\nstruct V2 { int version = 2; float data = 4.2; };\nunion Versioned {\n    V1 v1;\n    V2 v2;\n} v{.v2 = V2{}};\n\nswitch (v.v1.version) { // Well defined, despite v1 not being active\n    case 1: std::cout << \"Version 1\\n\"; break;\n    case 2: std::cout << \"Version 2\\n\"; break;\n}\n// prints: \"Version 2\\n\""
        }
      ],
      "id": "-LAsP8MN",
      "createdAt": 1711977280395,
      "updatedAt": 1711977288429
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::find_first_of",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::find_first_of algorithm returns the left-most element from the first range that matches any of the elements in a second range.\n\nSince neither range is ordered, the complexity is quadratic.\n\n#include <algorithm>\n#include <vector>\n#include <string>\n\nstd::vector<int> haystack{1, 2, 3, 4, 5, 6};\nstd::vector<int> needle{6, 4, 2};\n\n// find the first element in haystack matching either 2, 4, or 6\nauto it = std::find_first_of(haystack.begin(), haystack.end(), \n    needle.begin(), needle.end());\n// *it == 2\n\n\nstd::string text = \"The quick brown fox jumps over the lazy dog\";\nstd::string vowels = \"aeiou\";\nauto first = std::find_first_of(text.begin(), text.end(),\n    vowels.begin(), vowels.end(),\n        [](char l, char r) { // custom comparator\n        return std::tolower(l) == std::tolower(r);\n    });\n// *first == 'e'"
        }
      ],
      "id": "58nMa667",
      "createdAt": 1711977295655,
      "updatedAt": 1711977304328
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::out_ptr, std::inout_ptr",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::out_ptr and std::inout_ptr allow interoperability between C++ smart pointers and C-style APIs.\n\nA typical pattern in C APIs is that the (re-)allocating function accepts the handle to be allocated as either T** or void**.\n\nNote that the result of calling std::out_ptr and std::inout_ptr is meant to be a temporary that should not outlive the current expression.\n\n#include <memory>\n#include <stdexcept>\n\n// C API\nstruct Handle {};\nint create_handle(Handle** handle);\nint recreate_handle(Handle** handle);\nvoid free_handle(Handle* handle);\nint create_handle_ex(int option_a, int option_b, void** handle);\n\n{\nstd::unique_ptr<Handle, \n    decltype([](Handle* h) { free_handle(h); })> handle;\n\n// std::out_ptr for functions that create a handle\nif (int err = create_handle(std::out_ptr(handle)); err != 0)\n    throw std::runtime_error(\"couldn't create handle\");\n\n// std::inout_ptr for functions that first destroy \n// and then create a new handle\nif (int err = recreate_handle(std::inout_ptr(handle)); err != 0)\n    throw std::runtime_error(\"couldn't re-create handle\");\n\n// void** arguments are also supported\nif (int err = create_handle_ex(1, 2, std::out_ptr(handle)); err != 0)\n    throw std::runtime_error(\"couldn't create handle\");\n} // handle freed\n\n\n{ // Also supports std::shared_ptr\nstd::shared_ptr<Handle> handle;\n\nif (int err = create_handle(std::out_ptr(handle, free_handle));\n    err != 0)\n    throw std::runtime_error(\"couldn't create handle\");\n} // handle freed"
        }
      ],
      "id": "-vp8o-hC",
      "createdAt": 1711977308710,
      "updatedAt": 1711977314976
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::bind_front",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::bind_front is a simpler std::bind alternative, introduced in C++20.\n\nUnlike std::bind, it doesn’t allow for arbitrary reordering of arguments and only allows binding of the leading arguments.\n\nAs a consequence, std::bind_front doesn’t suffer from some limitations of std::bind.\n\n#include <functional>\n\nstruct Callable {\n    void operator()(auto&&...) && {}\n};\n\n\nauto plus = [](int left, int right) { return left + right; };\nauto add10 = std::bind_front(plus, 10);\n\nauto r = add10(4);\n// r == 14\n\n// std::bind_front(f, bound_args...)(call_args...)\n// is always equivalent to\n// std::invoke(f, bound_args..., call_args...)\nstd::bind_front(Callable{}, 10, 20)();\n\n// std::bind(Callable{}, 10, 20)(); // Wouldn't compile\n\nauto var = [](auto&&...) {};\n// std::bind_front doesn't fix number of arguments\nauto bound = std::bind_front(var, 10, 20);\nbound(10); // OK\nbound(10, 20, 30); // OK\n\nusing namespace std::placeholders;\nauto old_bound = std::bind(var, 10, 20, _1, _2, _3);\nold_bound(10, 20, 30); // OK\n// old_bound(10); // Wouldn't compile"
        }
      ],
      "id": "XAfFlUj5",
      "createdAt": 1711977319631,
      "updatedAt": 1711977323894
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Scope enumerations",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++11 introduced scope enumerations.\n\nEnumerators of scoped enumerations are named constants contained within the scope of the enumeration, preventing namespace pollution.\n\nAdditionally, scoped enumerations are not implicitly convertible to the underlying type.\n\n#include <utility>\n\n// The base type (unless specified) is int\nenum class Fruit {\n    apple, banana, lemon, orange, watermelon\n};\n\nenum class Citrus {\n    lemon, lime, grapefruit, orange\n};\n\n\nauto i = Fruit::banana; // decltype(i) == enum Fruit\ni = Fruit::orange; // OK\n// i = Citrus::orange; \n// Wouldn't compile, cannot convert Citrus to Fruit\n\nauto j = Citrus::grapefruit;\n\nusing enum Citrus;\nj = orange; \n// OK, lemon, lime, grapefruit and orange now awailable in local scope\n\n// using enum Fruit; // Wouldn't compile, lemon & orange would conflict\n\n// j = 42; // Wouldn't compile, no implicit conversions\nj = static_cast<Citrus>(2); // Citrus::grapefruit\n\n// C++17 direct initialization from integral value\nCitrus k{1}; // OK, k == Citrus::lime\n\nint x = static_cast<int>(j); // OK, but we are forcing int\nauto y = static_cast<std::underlying_type_t<decltype(j)>>(j); // OK\n// decltype(y) == int\nauto z = std::to_underlying(j); // C++23\n// decltype(w) == int\n// x == y == z == 2"
        }
      ],
      "id": "HajzGYJk",
      "createdAt": 1711977329483,
      "updatedAt": 1711977335048
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Unscoped Enum",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Unscoped enumerations are simple types that introduce named constants into the scope enclosing the enumeration.\n\nThe backing type is automatically selected by the compiler unless explicitly specified.\n\nNote that C++11 Scoped Enumerations are generally preferable (scheduled for tomorrow).\n\n#include <cstdint>\n#include <numeric>\n\n// Enumerators are assigned values starting from 0,\n// unless overriden, the Enumerators are assgned consecutive values\nenum Vegetables { Potato, Tomato, Carrot = 42, Pea, Onion };\n// Potato == 0, Tomato == 1, Carrot = 42, Pea == 43, Onion == 44\n\nenum Specific {\n    A = 1,\n    B = A + 42,\n    C = 1, // values may repeat\n    D = A + B + C,\n    E = std::lcm(13,7) // any constant expression\n};\n// A == 1, B == 43, C == 1, D == 45, E == 91\n\nint v = A; // Enumerators are implicitly convertible \n           // to the backing type\nSpecific w = static_cast<Specific>(1);\n// To convert from the underlying type we need a static cast\n// Note, multiple enumerators with the same value do not matter\n// because they are not distinguishable (i.e. A == C)\n\n\n// Enumerations can be anonymous \n// and explicitly specify the backing type\nenum : unsigned { GlobalConstant = 42 };\n// GlobalConstant == 42\n// std::underlying_type_t<decltype(GlobalConstant)> == unsigned\n\n\n// A type that can represent all enumeration values is picked\nenum IntLimits {\n    Min64Bit = INT64_MIN,\n    Max64Bit = INT64_MAX\n};\n// std::underlying_type_t<IntLimits> == 64bit type\n\n// If no such type exists, the enumeration is ill-formed\nenum Impossible {\n    X = INT64_MIN,\n    Y = UINT64_MAX\n};\n// Note GCC actually silently picks __int128"
        }
      ],
      "id": "wJ0neFhq",
      "createdAt": 1711977339147,
      "updatedAt": 1711977345691
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::stack",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::stack is a simple container adapter providing a stack/LIFO interface.\n\nBesides mitigating the need for recursion, std::stack can be used to implement simple undo functionality.\n\n#include <stack>\n#include <functional>\n\n// Operations that also return an undo-lambda\nauto add(int& state, int operand) {\n    state += operand;\n    return [operand](int& state) { state -= operand; };\n}\n\nauto substract(int& state, int operand) {\n    state -= operand;\n    return [operand](int& state) { state += operand; };\n}\n\nauto multiply(int& state, int operand) {\n    state *= operand;\n    return [operand](int& state) { state /= operand; };\n}\n\nauto divide(int& state, int operand) {\n    int orig = state;\n    state /= operand;\n    return [operand, rem = orig - state * operand](int& state) { \n        state *= operand;\n        state += rem;\n    };\n}\n\n// Apply operations and store the rollback in a std::stack.\nstd::stack<std::function<void(int&)>> rollback;\n\nint state = 0;\nrollback.push(add(state, 10));\n// state == 10\n\nrollback.push(divide(state, 3));\n// state == 3\n\n// revert last operation\nrollback.top()(state);\nrollback.pop();\n// state == 10\n\nrollback.push(multiply(state, 2));\n// state == 20\n\nwhile (!rollback.empty()) {\n    rollback.top()(state);\n    rollback.pop();\n}\n// state == 0"
        }
      ],
      "id": "896CUlu-",
      "createdAt": 1711977350068,
      "updatedAt": 1711977359000
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::osyncstream",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced synchronized streams.\n\nMultiple synchronized streams can be used to write to a single destination stream without introducing data races or interleaving as long as all accesses to that stream are through a synchronized stream.\n\n#include <syncstream>\n#include <iostream>\n#include <thread>\n#include <chrono>\n\n// Safe output to the same stream (here it is std::cout)\n// without introducing data races.\nauto j1 = std::jthread([](){\n    std::osyncstream(std::cout) << \n        \"We can safely write to the same stream.\\n\";\n});\nauto j2 = std::jthread([](){\n    std::osyncstream(std::cout) << \n        \"We can safely write to the same stream.\\n\";\n});\n\n// No interleaving, data are sent to std::cout \n// when osyncstream is destroyed.\nauto j3 = std::jthread([]() {\n    {\n        std::osyncstream out(std::cout);\n        out << \"This \";\n        out << \"will \";\n        out << \"not \";\n        out << \"be \";\n        out << \"interleaved.\\n\";\n    }\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(2000ms);\n    {\n        std::osyncstream(std::cout) <<\n        \"Maybe someone said something before me.\\n\";\n    }\n});\nauto j4 = std::jthread([]() {\n    std::osyncstream(std::cout) << \"Hey!\\n\";\n});\n\n/* Potential output:\nWe can safely write to the same stream.\nThis will not be interleaved.\nHey!\nWe can safely write to the same stream.\nMaybe someone said something before me.\n*/"
        }
      ],
      "id": "RecR8zjK",
      "createdAt": 1711977379474,
      "updatedAt": 1711977383947
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Rule of zero",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The “Rule of zero” is a class design principle derived from the single responsibility principle.\n\nA class should not define any special member functions unless its sole purpose is managing ownership.\n\n#include <string>\n#include <vector>\n\n// Piecewise Copy/Move constructors, Copy/Move assignments \n// and destructor will be provided by the compiler.\nstruct MyClass {\n    MyClass(const std::string& label, \n        const std::vector<int>& data) : label_(label), data_(data) {}\nprivate:\n    std::string label_;\n    std::vector<int> data_;\n};\n\nstruct MoveOnly {\n    MoveOnly(MoveOnly&&) = default;\n};\n\n// If one of the members is move-only, the copy constructor\n// and copy assignment will not be generated.\nstruct NoCopyGenerated {\n    MoveOnly moveonly_;\n};\n\nstatic_assert(not std::is_copy_constructible_v<NoCopyGenerated>);"
        }
      ],
      "id": "Zb_mAOvB",
      "createdAt": 1711977387500,
      "updatedAt": 1711977392239
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Safe integral comparisons",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced a set of safe integral comparison functions that can compare different integral types without introducing accidental conversions.\n\n#include <utility>\n\nint a = -10;\nunsigned b = 10;\nbool b1 = a < b;\n// b1 == false\n// -10 + UINT_MAX < 10 == false\n\nbool b2 = std::cmp_less(a, b);\n// b2 == true\n\nint c = -2'000'000'000;\nunsigned d = 2'294'967'296;\nbool b3 = c == d;\n// b3 == true\n// -2'000'000'000 + UINT_MAX == 2'294'967'296 (32bit)\n\nbool b4 = std::cmp_equal(c,d);\n// b4 == false\n\n// Full set of functions:\n// cmp_equal, cmp_not_equal, cmp_less, cmp_greater,\n// cmp_less_equal, cmp_greater_equal"
        }
      ],
      "id": "mKmk8l8h",
      "createdAt": 1711977407512,
      "updatedAt": 1711977413777
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Domain specific errors using std::error_code",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "If you need to represent error codes specific to your domain, you can use the std::error_code customization mechanism.\n\nA custom implementation has three parts:\n\n    an enum representing the domain-specific error codes\n    a corresponding error category that translates the error codes into text descriptions\n    a mapping from the enum type to the category type\n\n#include <system_error>\n#include <string>\n#include <iostream>\n#include <utility>\n#include <expected>\n#include <cassert>\n\n// Custom error enum\nenum class TransactionError {\n    OK = 0,\n    TemporaryError = 1,\n    PermanentError = 2,\n};\n\n// Custom category that provides text description\nstruct TransactionErrorCategory : std::error_category {\n    const char* name() const noexcept override {\n        return \"transaction\";\n    }\n    std::string message( int condition ) const override {\n        using namespace std::string_literals;\n        switch(condition) {\n            case 0: return \"ok\"s;\n            case 1: return \"temporary error, please retry\"s;\n            case 2: return \"permanent error\"s;\n        }\n        std::abort(); // unreacheable\n    }\n};\n\n// Register the enum as an error code enum\ntemplate<> struct std::is_error_code_enum<TransactionError> \n    : public std::true_type{};\n\n// Mapping from error code enum to category\nstd::error_code make_error_code(TransactionError e) {\n    static auto category = TransactionErrorCategory{};\n    return std::error_code(std::to_underlying(e), category);\n}\n\n// And now we can use it:\nstd::error_code my_function() noexcept {\n    return TransactionError::PermanentError;\n}\n// And obviously, this also works with std::expected\nstd::expected<void,std::error_code> my_other_function() noexcept {\n    return std::unexpected{TransactionError::TemporaryError};\n}\n\nint main() {\n    if (auto err = my_function(); err) {\n        std::cout << err.category().name() << \" : \"\n          << err.message() << \"\\n\";\n        // prints: \"transaction : permanent error\"\n    }\n    if (auto res = my_other_function(); !res) {\n        std::cout << res.error().category().name() << \" : \"\n          << res.error().message() << \"\\n\";\n        // prints: \"transaction : temporary error, please retry\"\n    }\n}"
        }
      ],
      "id": "H1gwRoCP",
      "createdAt": 1711977418356,
      "updatedAt": 1711977423760
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::error_code, std::error_category",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::error_code is a strong type for holding an error code.\n\nError codes are constructed from an enumeration accompanied by an explanation type derived from std::error_category.\n\nThe standard provides std::errc for system errors, std::io_errc for std::iostream and std::future_errc for std::future.\n\n#include <system_error>\n#include <future>\n#include <utility>\n\n// Helper for creating error codes that automatically asociates\n// the code with the corresponding category.\nauto err = std::make_error_code(std::errc::not_enough_memory);\n// err.category().name() == \"generic\"\n// err.message() == \"Cannot allocate memory\"\n// err.value() == ENOMEM\n\n// Same as:\nauto err_e = std::error_code(\n  std::to_underlying(std::errc::not_enough_memory),\n  std::generic_category());\n// err == err_e\n\n// Note that the text is implementation specific, \n// however, specifically for std::errc the values map to errno.\n\nauto future = std::make_error_code(\n  std::future_errc::promise_already_satisfied);\n// future.category().name() == \"future\"\n// err.message() == \"Promise already satisfied\""
        }
      ],
      "id": "PZjDfX-X",
      "createdAt": 1711977427258,
      "updatedAt": 1711977434502
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::reduce",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::reduce (C++17) is a generalized reduction algorithm, a counterpart to the left-fold std::accumulate.\n\nstd::reduce can only operate with an associative and commutative operation as the reduction is not evaluated in strict left-to-right order.\n\nHowever, consecutively, the algorithm also supports parallel execution through std::execution.\n\n#include <vector>\n#include <algorithm>\n#include <execution>\n#include <random>\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6, 7};\n\n// Basic reduce with int{} (0) as starting value \n// and std::plus<int>{} as the reduction operation\nint sum = std::reduce(data.begin(), data.end());\n// sum == 28\n\n\n// Reduce with custom init value and reduction operation\nint product = std::reduce(data.begin(), data.end(),\n                        1, std::multiplies<>{});\n// product == 5040\n\n\nstd::mt19937 gen(0);\nstd::vector<unsigned> large_data;\nstd::generate_n(std::back_inserter(large_data), 1'000'000,\n                std::ref(gen));\n\n// Automatically parallelized sum\nint64_t big_sum = std::reduce(std::execution::par,\n                              large_data.cbegin(), large_data.cend(),\n                              0z);\n// stdlibc++: big_sum == 2147988759967286"
        }
      ],
      "id": "V6Ku4AL3",
      "createdAt": 1711977438160,
      "updatedAt": 1711977444585
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Inline variables",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++17 introduced inline variables.\n\nInline variables can appear in headers as they are permitted multiple definitions (as long as there is only one per unit and all definitions are the same).\n\nOne of the notable use cases of inline variables is for customization function objects (Niebloids) since non-function symbols inhibit ADL lookup.\n\nnamespace SomeNamespace {\n    struct X {};\n    // A typical use case, non-function symbols\n    // do not participate and inhibit ADL.\n    constexpr inline auto fun = [](auto&&) {};\n    // constexpr not required, but advisable\n}\n\nnamespace OtherNamespace {\n    struct Y {};\n    void fun(auto&&) {}\n}\n\nint main() {\n    SomeNamespace::X x;\n    // fun(x); // Would not compile, does not participate in ADL.\n    SomeNamespace::fun(x); // OK\n\n    using SomeNamespace::fun;\n    OtherNamespace::Y y;\n    fun(y); // calls SomeNamespace::fun\n    // OtherNamespace::fun is only visible to ADL\n}"
        }
      ],
      "id": "nAOwuTMx",
      "createdAt": 1711977449421,
      "updatedAt": 1711977455057
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::print, std::println",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::print and std::println are the counterparts to std::format that format to a stdio FILE descriptor instead of producing a std::string.\n\nBoth std::print and std::println by default output to the standard output (stdout).\n\n#include <print>\n#include <format>\n#include <ranges>\n\n// Outputs through stdio to stdout\nstd::print(\"{} {}!\\n\", \"Hello\", \"World\");\n// Same as above\nstd::println(\"{} {}!\", \"Hello\", \"World\");\n\n// The FILE descriptor can be specified as the first argument\nstd::FILE *f = std::fopen(\"out.txt\", \"w\");\n// Output will be written to \"out.txt\"\nstd::println(f, \"{} {}!\", \"Hello\", \"World\");\nstd::fclose(f);\n\n// Standard error output\nstd::println(stderr, \"{} {}!\", \"Hello\", \"World\");\n\n// Same formatting options as std::format\nstd::println(\"The first five multiples of 17 : {:n}\", \n    std::views::iota(0,5) | \n    std::views::transform([](int v) { return v * 17; }));\n// prints:\n// The first ten multiples of 17 : 0, 17, 34, 51, 68"
        }
      ],
      "id": "Sgdx1ydn",
      "createdAt": 1711977460435,
      "updatedAt": 1711977465634
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::string",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::string is a container for storing null-terminated narrow character strings.\n\nstd::string provides very similar functionality to std::vector while maintaining the null-termination invariant on every operation.\n\nAdditionally, std::string also provides a couple of convenience methods (find, starts/ends_with, contains, substr).\n\n#include <string>\n\nstd::string str = \"Hello World?\";\n\n// Same interface as std::vector\nstr.pop_back();\nstr.push_back('!');\n// str == \"Hello World!\"\n\n// Importantly, these operations maintain null-termination\nchar c = str[str.size()]; // Unlike std::vector, this is OK\n// c == char{}, i.e. '\\0'\n\n// Convenience methods\nsize_t pos = str.find_first_of(\" ?\");\n// pos == 5\n\n// Get a C-style string\nconst char* cstring = str.c_str();\n// cstring == \"Hello World!\"\n\n// Substring, offset and count\nauto world = str.substr(6, 5);\n// world == \"World\"\n\n// Count can be omitted to take the remainder of the string\nauto WORLD = str.substr(6);\n// WORLD == \"World!\""
        }
      ],
      "id": "O-Xcv0FJ",
      "createdAt": 1711977501660,
      "updatedAt": 1711977507231
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Handling required fields with designated initializers",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When relying on designated initializers during aggregate initialization, it might be desirable to ensure that some fields are always explicitly initialized.\n\nWe can use a simple wrapper that cannot be constructed from an empty initializer list to enforce initialization.\n\n#include <string>\n\ntemplate <typename T>\nstruct RequiredField {\n    RequiredField(const T& value) : value(value) {}\n    operator T&() { return value; }\n    operator const T&() const { return value; }\n    T value;\n};\n\nstruct Options {\n    RequiredField<int> id;\n    std::string label = \"default label\";\n};\n\nOptions options = { .id = 20 };\n// options.id == 20, options.label == \"default label\"\n\n// Options opt = {.label = \"some label\"}; // Won't compile.\n// RequiredField is not constructible from empty initializer list."
        }
      ],
      "id": "_y6ckitv",
      "createdAt": 1711977511728,
      "updatedAt": 1711977519226
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Ordered containers: std::(multi_)map, std::(multi_)set",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The ordered containers std::(multi_)set and std::(multi_)map are node-based containers that offer log(n) operation complexity for lookup, insertion and removal.\n\nAs with other node-based containers, we pay for the reference and iterator stability with performance.\n\nDue to a relatively low constant overhead, ordered containers can sometimes outperform unordered containers.\n\n#include <cstdint>\n#include <string>\n#include <map>\n#include <set>\n\nstruct Blob { \n    int a;\n    int b;\n};\n\nstd::map<uint64_t,Blob> data;\n\n// insert new element if key doesn't exist\ndata.insert(std::make_pair(0z, Blob{10,20}));\n// insert if key doesn't exist, update value if key already exists\ndata.insert_or_assign(1z, Blob{1, 2});\n// if key doesn't exist, insert a new element, constructing\n// the value in-place from the arguments\ndata.try_emplace(1z, 1, 2); // 1, 2 used for the value\n\nauto it1 = data.find(0); // lookup by key\n// it1->first == 0, it1->second == {10, 20}\nauto it2 = data.find(4);\n// it2 == data.end()\n\n// iterate over elements in strict-weak ordering\nfor (auto& [key, value] : data) {}\n\n\nstruct Key {\n    uint64_t id;\n    std::string label;\n    auto operator<=>(const Key&) const = default;\n};\n\n// The key type has to support strict-weak ordering\nstd::set<Key> set{{0, \"label1\"}, {0, \"label2\"},\n                  {1, \"label1\"}, {1, \"label2\"}};\n\nbool check = set.contains({0, \"label1\"});\n// check == true"
        }
      ],
      "id": "o-0wKFCD",
      "createdAt": 1711977528299,
      "updatedAt": 1711977534765
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::string(_view)::starts_with, std::string(_view)::ends_with",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 added prefix and suffix checking methods: starts_with and ends_with to both std::string and std::string_view.\n\n#include <string>\n#include <string_view>\n\nstd::string str(\"the quick brown fox jumps over the lazy dog\");\nbool t1 = str.starts_with(\"the quick\"); // const char* overload\n// t1 == true\nbool t2 = str.ends_with('g'); // char overload\n// t2 == true\n\nstd::string_view needle = \"lazy dog\";\nbool t3 = str.ends_with(needle); // string_view overload\n// t3 == true\n\nstd::string_view haystack = \"you are a lazy cat\";\n// both starts_with and ends_with also available for string_view\nbool t4 = haystack.ends_with(needle);\n// t4 == false"
        }
      ],
      "id": "-W7CJxfg",
      "createdAt": 1711977555408,
      "updatedAt": 1711977560002
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::generator",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::generator is a coroutine type for implementing generator coroutines.\n\nThe type implements a view interface and comes with a std::pmr::generator alias for use with the PMR allocator.\n\nThe capability of yielding ranges of values makes the std::generator particularly useful for recursive traversals.\n\n#include <cstdint>\n#include <vector>\n#include <memory>\n#include <generator>\n#include <utility>\n\n// Fibonacci number generator\nstd::generator<int64_t> fibonacci(int64_t cnt) {\n    int64_t first = 0;\n    int64_t second = 1;\n    while (cnt > 0) {\n        co_yield first;\n        first = std::exchange(second, first + second);\n        --cnt;\n    }\n}\n\n// First 10 fibonacci numbers\nfor (int64_t v : fibonacci(10)) {}\n\n\nstruct Tree {\n    struct Node {\n        int64_t value;\n        Node* left;\n        Node* right;\n    };\n    Node* root;\n    std::vector<std::unique_ptr<Node>> store_;\n};\n\nTree make_tree();\n\n// In-Order tree traversal implemented using std::generator.\nstd::generator<Tree::Node*> in_order(Tree::Node* root) {\n    if (root == nullptr)\n        co_return;\n    if (root->left != nullptr)\n        co_yield std::ranges::elements_of(in_order(root->left));\n    co_yield root;\n    if (root->right != nullptr)\n        co_yield std::ranges::elements_of(in_order(root->right));\n}\n\nTree tree = make_tree();\n// Traverse the tree using in_order traversal\nfor (Tree::Node *node : in_order(tree.root)) {}"
        }
      ],
      "id": "rUJR8fu0",
      "createdAt": 1711977565633,
      "updatedAt": 1711977572455
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Aggregate initialization: designated initializers",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced designated initializers for aggregate initialization.\n\nThis allows for better control over which elements of the aggregate will be explicitly initialized.\n\n#include <string>\n\nstruct Data {\n    int a;\n    double b;\n    std::string c;\n};\n\nData x = { .b = 2.4 };\n// x == { 0, 2.4, \"\" }\n\n\n// Typical use case with default-heavy aggregate:\nstruct Configuration {\n    enum class OptionA { Enabled, Disabled };\n    OptionA option_a = OptionA::Enabled;\n\n    std::string label = \"default label\";\n\n    struct Coords { int x; int y; };\n    Coords coords = { 10, 20 };\n};\n\nConfiguration config = { .label = \"some label\" };\n// config == {OptionA::Enabled, \"some label\", {10, 20}};\n\n\n// A clunky but functional option for named agruments in C++\nstruct Arg { const std::string& label; int64_t id; };\nvoid some_func(Arg arg) {}\n\nsome_func({.label = config.label, .id = 42});"
        }
      ],
      "id": "7v4gB27A",
      "createdAt": 1711977578024,
      "updatedAt": 1711977582724
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Aggregate initialization",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Aggregate types can be initialized using special aggregate initialization.\n\nThis initializes members in their declaration order.\n\nMembers that are not explicitly initialized and do not have a default member initializer are initialized using empty copy-list-initialization (i.e. T x={}).\n\n#include <string>\n#include <vector>\n\nstruct Data {\n    int x;  \n    double y;\n    std::string label = \"Hello World!\"; // only permitted since C++14 \n    std::vector<int> arr;\n};\n\nstruct X {\n    int a;\n    int b;\n};\n\nstruct Y {\n    X x;\n    X y;\n};\n\n// Initialization is done in declaration order:\nData a = {10, 2.3};\n// a.x == 10, a.y == 2.3\n// a.label == \"Hello World!\", a.arr == std::vector<int>{}\n\n// Nested brackets can be omitted:\nY b = { 10, 20, 30 };\n// b.x == {10, 20}, b.y == {30, int{} == 0}"
        }
      ],
      "id": "GVywiCdE",
      "createdAt": 1711977593046,
      "updatedAt": 1711977598032
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::copy, std::copy_backward",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When copying ranges, we need to take care when the input and output ranges overlap.\n\nFor std::copy, only the tail of the destination range can overlap the source range; for std::copy_backward, only the head of the destination range can overlap the source range.\n\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> data{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n// OK for std::copy\n//         [ source range      ]\n// [ destination range ]\nstd::copy(data.begin() + 1, data.end(), data.begin());\n// data == {2, 3, 4, 5, 6, 7, 8, 9, 9}\n\ndata = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n// OK for std::copy_backward\n// [ source range      ]\n//         [ destination range ]\nstd::copy_backward(data.begin(), data.begin() + 8, data.end());\n// data == {1, 1, 2, 3, 4, 5, 6, 7, 8}"
        }
      ],
      "id": "O97k3O9O",
      "createdAt": 1711977603216,
      "updatedAt": 1711977607222
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "fundamental types",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Unlike some other languages, the fundamental types (bool, char, int, float…) in C++ do not receive special treatment with the following exceptions:\n\n    fundamental types have their semantics defined in the C++ standard\n    default initializing a variable of a fundamental type does not perform any initialization\n    arguments to operators for fundamental types are prvalues\n\n#include <string>\n\nint v; // left uninitialized\n\n// Only well-defined since C++17\nint x = 1;\n(x = 2) = x; // x == 1\n\n// right side evalutes: 1 (prvalue)\n// left side evaluates: ref to x (x==2)\n// assignment evaluates: ref to x (x==1)\n\nstd::string y = \"a\";\n(y = \"b\") = y; // y == \"b\"\n\n// right side evaluates: ref to y\n// left side evalutes: ref y (y==\"b\")\n// assignment evaluates: ref to y (y==\"b\")"
        }
      ],
      "id": "4zUgs1mH",
      "createdAt": 1711977610631,
      "updatedAt": 1711977616645
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::next_permutation, std::prev_permutation",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::next_permutation and std::prev_permutation algorithms reorder elements of a range into the next/previous lexicographical permutation.\n\nIf no such permutation exists, both algorithms roll over and return false.\n\n#include <algorithm>\n#include <vector>\n#include <bitset>\n\nstd::vector<int> data{1, 2, 3};\ndo {\n    // Iterate over:\n    // 123, 132, 213, 231, 312, 321\n} while(std::next_permutation(data.begin(), data.end()));\n// data == {1, 2, 3}\n\n\nstd::vector<bool> bits(4);\nbits[0] = 1;\nbits[1] = 1;\ndo {\n    // Iterate over all 4 bit numbers with 2 bits set to 1\n    // 1100, 1010, 1001, 0110, 0101, 0011\n} while (std::prev_permutation(bits.begin(), bits.end()));\n// bits == {1, 1, 0, 0}"
        }
      ],
      "id": "zcqn3aj9",
      "createdAt": 1711977620374,
      "updatedAt": 1711977624264
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::expected, monadic interface",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::expected (C++23) comes with a monadic interface. Relying on the monadic interface prevents the typical if-then-else verbose error checking.\n\nThe and_then and or_else methods expect a callable that accepts a value/error and returns a std::expected.\n\nThe transform and transform_error methods expect a callable that accepts a value/error and returns a value/error.\n\n#include <expected>\n#include <system_error>\n#include <string>\n\nstd::expected<std::string, std::error_condition> read_input();\nstd::expected<int, std::error_condition> to_int(const std::string& s);\nint add_ten(int v);\nstd::expected<int, std::error_condition> log_error(\n  const std::error_condition& err);\n\nauto result = read_input()\n    .and_then(to_int) // invoked if the expected contains a value\n    // the callable has to return a std::expected, but can change\n    // the type: std::expected<T,Err> -> std::expected<U,Err>\n    .transform(add_ten) // invoked if the expected contains a value\n    // the callable can return any type\n    // std::expected<T,Err> -> std::expected<U,Err>\n    .or_else(log_error); // invoked if the expected contains an error\n    // the callable has to return a std::expected, but can change\n    // the type: std::expected<V,T> -> std::expected<V,U>"
        }
      ],
      "id": "gGBsAYaH",
      "createdAt": 1711977627610,
      "updatedAt": 1711977631798
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::unique_ptr",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Besides being a simple smart pointer, std::unique_ptr is also an important semantic tool, marking an ownership handoff.\n\n#include <memory>\n\nstruct Data{};\n\n// Function returning a unique_ptr handing off ownership to caller.\nstd::unique_ptr<Data> producer() { return std::make_unique<Data>(); }\n\n// Function accepting a unique_ptr taking over ownership.\nvoid consumer(std::unique_ptr<Data> data) {}\n\n// Helps with Single Reponsibility Principle\n// by separating resource management from logic\nstruct Holder {\n    Holder() : data_{std::make_unique<Data>()} {}\n    // implicitly defaulted move constructor && move assignment\n    // implicitly deleted copy constructor && copy assignment\nprivate:\n    std::unique_ptr<Data> data_;\n};\n\n// shared_ptr has a fast constructor from unique_ptr\nstd::shared_ptr<Data> sptr = producer();\n\n// Even in cases when manual resource management is required,\n// a unique_ptr on the interface might be preferable:\nvoid manual_handler(std::unique_ptr<Data> ptr) {\n    Data* raw = ptr.release();\n    // manual resource management\n}"
        }
      ],
      "id": "IsHTvSZ_",
      "createdAt": 1711977635149,
      "updatedAt": 1711977641501
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::ssize, std::ranges::ssize",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::ssize is a C++20 function template that returns the size information of the passed-in range or array as a signed integer (typically std::ptrdiff_t).\n\nThe range version std::ranges::ssize instead uses the range-style “customization point object” approach while maintaining the same functionality.\n\nThis allows for simpler code when working with raw indexes.\n\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> data{1, 2, 3, 4, 5, 6};\n\n    // z is the literal suffix for signed size type\n    for (auto i = 0z; i < ssize(data); i++) {\n        int sum = 0;\n        if (i - 1 >= 0)\n            sum += data[i-1];\n        sum += data[i];\n        if (i + 1 < ssize(data))\n            sum += data[i+1];\n        std::cout << \"\" << sum << \"\\n\";\n    } // prints 3, 6, 9, 12, 15, 11\n}"
        }
      ],
      "id": "EMya0UT9",
      "createdAt": 1711977645726,
      "updatedAt": 1711977650361
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::equal, std::is_permutation",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Containers of the same type can be easily compared using comparison operators.\n\nWhen we need to compare the content of containers of different types, we can use the std::equal and std::is_permutation algorithms.\n\n#include <vector>\n#include <set>\n#include <algorithm>\n\nstd::vector<int> data1{2, 1, 3, 4, 5};\nstd::vector<int> data2{2, 4, 1, 3, 5};\n\n// Linear comparison:\nbool cmp1 = std::equal(data1.begin(), data1.end(), data2.begin());\n// cmp1 == false\nbool cmp2 = (data1 == data2);\n// cmp2 == false (same as std::equal if types match)\n\n// Elements match but are potentially out of order:\nbool cmp3 = std::is_permutation(data1.begin(), data1.end(),\n                                data2.begin());\n// cmp3 == true\n\n\nstd::set<int> data3{1, 2, 3, 4, 5};\n\n// Linear comparison:\nbool cmp4 = std::ranges::equal(data1, data3);\n// cmp4 == false\n\n// Elements match but are potentially out of order:\nbool cmp5 = std::ranges::is_permutation(data1, data3);\n// cmp5 == true"
        }
      ],
      "id": "WHfCPXGF",
      "createdAt": 1711977655186,
      "updatedAt": 1711977660223
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::bit_cast",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced a new cast that is specifically designed for type-punning: std::bit_cast.\n\nUnlike reinterpret_cast, std::bit_cast is permitted in constexpr contexts.\n\n#include <bit>\n#include <cstdint>\n\n// Constexpr implementation of fast inverse root\n// https://en.wikipedia.org/wiki/Fast_inverse_square_root\nconstexpr float fast_inverse_sqrt(float value) {\n  float half = value * 0.5f;\n  float y = value;\n\n  static_assert(sizeof(float) == sizeof(uint32_t));\n  uint32_t i = std::bit_cast<uint32_t>(y);\n  i = 0x5f3759df - (i >> 1);\n  y = std::bit_cast<float>(i);\n  return y * (1.5f - (half * y * y));\n}\n\nconstinit static float one_third = fast_inverse_sqrt(9.0);\n// one_third ~= 0.333\n\n\n// Standard layout type\nstruct X {\n    int v;\n};\n\nconstexpr static X x{42};\n// Wouldn't compile, reinterpret_cast is not a constant expression\n// constinit static int y = *reinterpret_cast<const int*>(&x);\n\n// OK\nconstinit static int y = std::bit_cast<int>(x);\n// y == 42\n\n\n// Assuming IEEE 754 binary64\nuint64_t val = 0;\ndouble zero = std::bit_cast<double>(val); // 0\n\nval |= UINT64_C(1) << 63;\ndouble negative_zero = std::bit_cast<double>(val); // -0\n\nval = 0 | (UINT64_C(0x7FF) << 52);\ndouble infinity = std::bit_cast<double>(val); // inf\n\nval |= UINT64_C(1) << 63;\ndouble negative_infinity = std::bit_cast<double>(val); // -inf"
        }
      ],
      "id": "bQs40DuN",
      "createdAt": 1711977663662,
      "updatedAt": 1711977670714
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::ranges::to",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 std::ranges::to is a simple utility that eagerly evaluates a view and stores the result in the specified container type.\n\nThe element type can be left out and will then be deduced using CTAD (matching the element type of the view).\n\n#include <ranges>\n#include <list>\n#include <vector>\n#include <spanstream>\n\nstd::list<int> data{1,2,3,4,5};\nauto v = data | std::ranges::to<std::vector>();\n// v == {1,2,3,4,5}\n// decltype(v) == std::vector<int>\n\n\n// Composed views\nstd::span<const char> text = \"42 -13 7 3 -1 91 101\";\nstd::ispanstream s(text);\nauto parsed = std::views::istream<int>(s) | \n  std::views::filter([](int e) {\n    return e >= 0;\n  }) | std::ranges::to<std::vector>();\n// parsed == {42, 7, 3, 91, 101}\n// decltype(parsed) == std::vector<int>\n\n\nstd::string str = \"hello world\";\nauto upper = str | std::views::transform([](char c) {\n    return std::toupper(c);\n}) | std::ranges::to<std::string>();\n// upper == \"HELLO WORLD\"\n\n\n// With an explicit element type\nstd::vector<double> floats{2.4,1.1,9.7,6.3};\nauto ints = floats | std::ranges::to<std::vector<int>>();\n// ints == {2, 1, 9, 6}"
        }
      ],
      "id": "uHCgXgOi",
      "createdAt": 1711977682153,
      "updatedAt": 1711977685927
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "emplace, emplace_back, emplace_front",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "In C++11, all containers received emplace variants of their typical insert/push methods.\n\nThe emplace variants can construct the element in place, saving a move or copy.\n\n#include <vector>\n#include <string>\n\nstd::vector<std::string> vec;\n{\n    std::string s(\"Hello World!\");\n    vec.push_back(s); // Copy\n    vec.push_back(std::move(s)); // Move\n}\n{\n    std::string s(\"Hello World!\");\n    vec.emplace_back(s); // Copy (same as push_back)\n    vec.emplace_back(std::move(s)); // Move (same as push_back)\n    // In-place construction, no move or copy:\n    vec.emplace_back(\"Hello World!\");\n    // Note the difference, this is still a move:\n    vec.emplace_back(std::string{\"Hello World!\"});\n}"
        }
      ],
      "id": "6uO40KdC",
      "createdAt": 1711977691186,
      "updatedAt": 1711977696299
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::as_const",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::as_const is a C++17 utility that simplifies const-casting, specifically the safe variant of adding a const qualifier.\n\nNotably, this utility is more ergonomic in generic contexts than the standard const_cast.\n\n#include <utility>\n\nvoid test(const auto&) {}\nvoid test(auto&)  {}\n\nint x = 0;\n\n// If we want to explicitly call test(const&)\n// we have to add const qualifier:\ntest(const_cast<const int&>(x)); // old style\ntest(std::as_const(x)); // shorter and can't mispell the type\n\nvoid user(auto&& x) {\n    // In generic code, ensuring that we call test(const&)\n    // is quite tricky to get right.\n    test(const_cast<const std::remove_reference_t<decltype(x)>&>(x));\n    // as_const provides a lot shorter and correct solution\n    test(std::as_const(x));\n}\n\nuser(x); // Calls test(const&) twice\nuser(10); // Same as above"
        }
      ],
      "id": "fOx5MajT",
      "createdAt": 1711977701176,
      "updatedAt": 1711977709491
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "fold expressions",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Fold expressions (C++17) enable parameter pack expansions as expressions.\n\nFold expression can fold either left or right and allow an optional init expression.\n\n#include <iostream>\n#include <utility>\n\ntemplate <int... Vs>\nint minus_left() {\n  return (... - Vs);\n  // expands into ((Vs[0] - Vs[1]) - Vs[2]) - ... - Vs[last]\n}\n\ntemplate <int... Vs>\nint minus_right() {\n  return (Vs - ...);\n  // expands into Vs[0] - ... - (Vs[last-2] - (Vs[lst-1] - Vs[last]))\n}\n\nint left =  minus_left<1, 2, 3, 4, 5>();\n// (((1 - 2) - 3) - 4) - 5\n\nint right = minus_right<1, 2, 3, 4, 5>();\n// 1 - (2 - (3 - (4 - 5)))\n\n\ntemplate <typename... Ts>\nvoid print_all(Ts&&... ts) {\n  // left-fold with std::cout as init\n  (std::cout << ... << ts) << \"\\n\";\n  // ((std::cout << ts[0]) << ts[1]) << ...\n}\n\ntemplate <typename... Ts>\nvoid print_spaced(Ts&&... ts) {\n  std::string_view delim = \"\";\n  // operator, guarantees left-to-right ordering of side-effects\n  // An immediately invoked lambda can wrap any \"step\".\n  ([&]{ std::cout << std::exchange(delim,\" \") << ts; }(), ...);\n  // expands into:\n  // []{ std::cout << std::exchange(delim,\" \") << ts[0]; }(),\n  // ([]{ std::cout << std::exchange(delim,\" \") << ts[1] << \" \"; }(),\n  //  (...))\n  std::cout << \"\\n\";\n}\n\nprint_all(1, 2.4, \"Hello World\");\n// prints \"12.4Hello World\"\n\nprint_spaced(1, 2.4, \"Hello World\");\n// prints \"1 2.4 Hello World\""
        }
      ],
      "id": "37xVofQr",
      "createdAt": 1711977741111,
      "updatedAt": 1711977746914
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "parameter pack",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "A parameter pack (C++11) is a template parameter that can represent any number of template arguments.\n\nWithout fold expressions (C++17), we have limited options for manipulating a parameter pack.\n\n#include <utility>\n#include <iostream>\n#include <type_traits>\n\n// Unimportant helpers\ntemplate <typename T> T transform(T&& t) { return t; }\ntemplate <typename... Ts> void other(Ts... ts) {}\nstruct X {};\n\n// Passing a parameter pack around\ntemplate <typename... Ts>\nvoid fun(Ts&&... ts) {\n    // Pass to another function.\n    other(ts...);\n    // Same but apply a transformation to each element.\n    other(transform(std::forward<Ts>(ts))...);\n}\n\nfun(1, 2.4, X{});\n// other(1, 2.4, X{});\n// other(transform(1), transform(2.4), transform(X{}));\n\n\n// Recursive processing\nvoid recursive() {} // terminal state (nothing to do)\n\ntemplate <typename Current, typename... Ts>\nvoid recursive(Current&& curr, Ts&&... ts) {\n    std::cout << curr << \", \"; // process first element\n    // and process the rest recursively\n    recursive(std::forward<Ts>(ts)...);\n}\n\nrecursive(1, 2.4, \"Hello World!\");\n// prints: 1, 2.4, Hello World!,\n\n// Non-recursive processing:\ntemplate <typename T>\nvoid process(T&& t) { std::cout << t << \"\\n\"; }\n\ntemplate <typename... Ts>\nvoid nonrecursive(Ts&&... ts) {\n    // Parameter packs can be expanded in initializer lists\n    int dummy[sizeof...(Ts)] = {(process(std::forward<Ts>(ts)), 0)...};\n    // (process(std::forward<Ts>(ts)), 0) is an expression that has\n    // a side-effect of calling process(), but always returns zero\n}\n\nnonrecursive(2.4, 1);\n// calls: process(2.4), process(1) (in that order [initializer_list])\n// dummy == {0, 0};\n\n\n// Multiple parameter packs can be expanded in-step\ntemplate <typename... Ts> struct pack {};\ntemplate <typename A, typename B> struct pair {};\n\ntemplate <typename... TAs>\nstruct zip {\n    template <typename... TBs>\n    struct with {\n        typedef pack<pair<TAs,TBs>...> type;\n    };\n};\n\ntypedef zip<int, double>::with<int, int>::type result_t;\n// result_t == pack<pair<int, int>, pair<double, int>>"
        }
      ],
      "id": "YG2AMus9",
      "createdAt": 1711977753315,
      "updatedAt": 1711977762191
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::views::istream",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++20 standard added another way to iterate over homogenous streams, the istream view.\n\nThe std::views::istream is the view version of std::istream_iterator, providing the expected view interface and the associated compatibility with other views.\n\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <ranges>\n#include <vector>\n\nstd::istringstream numbers(\"-10 2 4 -5 -3 9\");\n\n// Composition with other views:\nfor (auto v : std::views::istream<int>(numbers) | \n        std::views::filter([](int v) { return v >= 0; })) {\n    // process non-negative integer values from numbers\n    // i.e. {2, 4, 9}\n}\n\n\nstruct Account {\n    std::string name;\n    int value;    \n    friend std::istream& operator>>(std::istream& s, Account& p) {\n        s >> std::quoted(p.name) >> p.value;\n        return s;\n    }\n};\n\nstd::istringstream users(R\"(\n    \"user1\" 100\n    \"user2\" 101\n    \"user3\" 99\n    \"user4\" 42\n    \"user5\" 200\n    \"user6\" 150\n)\");\n\n// Process accounts from the input and keep the top three accounts:\nstd::vector<Account> top_three(3);\nstd::ranges::partial_sort_copy(\n    std::views::istream<Account>(users), // until EOF or parsing fail.\n    top_three,\n    std::greater<>{}, // greater value\n    &Account::value,  // order by Account::value\n    &Account::value); // order by Account::value\n// top_three == {{\"user5\", 200}, {\"user6\", 150}, {\"user2\", 101}}"
        }
      ],
      "id": "nmnTORT6",
      "createdAt": 1711977766335,
      "updatedAt": 1711977771191
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "[[assume(expr)]];",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 introduced the [[assume(expr)]]; attribute that can be used to introduce undefined behaviour into a program.\n\nInstead of relying on other language-level UB, the attribute can be specified with an expression the compiler can assume is true, allowing the compiler to optimize the code aggressively.\n\nIf any assumption is violated, the program is in an invalid state.\n\nint div2_version1(int a) {\n    return a/2;\n}\n\nint div2_version2(int a) {\n    // Assume positive value to allow bitshift.\n    [[assume(a >= 0)]];\n    return a/2;\n}\n\nunsigned case_version1(unsigned a) {\n    switch (a) {\n        case 0: return 1;\n        case 1: return 2;\n        case 2: return 3;\n        default:\n            return 0;\n    }\n}\n\nunsigned case_version2(unsigned a) {\n    switch (a) {\n        case 0: return 1;\n        case 1: return 2;\n        case 2: return 3;\n        default:\n            // Mark the default case as unreachable.\n            [[assume(false)]];\n            return 0;\n    }\n}"
        }
      ],
      "id": "HkMbzHV1",
      "createdAt": 1711977775610,
      "updatedAt": 1711977782308
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "C++20 (spaceship) operator<=> vs equality",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "One potentially surprising behaviour when using the C++20 (spaceship) operator<=> is that unlike the defaulted version, a custom implementation will not generate equality comparison operators.\n\nA custom operator<=> implies that the defaulted operator== wouldn’t produce correct results, and for performance reasons, using the output from operator<=> isn’t desirable.\n\n#include <compare>\n\n// Equality comparable type.\n// A defaulted operator<=> with no declared operator== \n// will generate a piecewise equality comparison.\nstruct A {\n    int x;\n    int y;\n    auto operator<=>(const A&) const = default;\n    // Same as:\n    // friend auto operator<=>(const A&, const A&) = default; \n};\n\n// Not equality comparable.\n// User defined operator<=> will only generate:\n// <, <=, >, >= operators\nstruct B {\n    int x;\n    int y;\n    auto operator<=>(const B& other) const {\n        auto cmp = x <=> other.x;\n        if (!std::is_eq(cmp)) return cmp;\n        return y <=> other.y;\n    }\n};\n\n// Equality comparable.\n// An explicitly defaulted operator== brings back\n// == and != using piecewise comparison.\nstruct C {\n    int x;\n    int y;\n    auto operator<=>(const C& other) const {\n        auto cmp = x <=> other.x;\n        if (!std::is_eq(cmp)) return cmp;\n        return y <=> other.y;\n    }\n    bool operator==(const C&) const = default;\n};"
        }
      ],
      "id": "K-sEFYRK",
      "createdAt": 1711977793299,
      "updatedAt": 1711977797972
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "thread_local",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Variables with the thread_local storage specifier do not follow the regular variable lifetime. Instead, they are constructed before (typically at) their first ODR use and destroyed at thread exit.\n\nThread local variables do not suffer the initialization overhead of static variables. A “thread local” variable is only accessible from a single thread (each thread gets its copy).\n\n#include <vector>\n#include <thread>\n\nvoid task() {\n    thread_local std::vector<int> data;\n    data.clear(); // Drop left-over elements from previous iteration,\n    // without de-allocating memory.\n  \n    // read-some data and do some processing\n}\n\nvoid runner(std::stop_token stop_token) {\n   // Check whether the associated thread requested termination.\n    while (!stop_token.stop_requested()) {\n       // If not, do stuff.\n        task();\n    }\n}\n\nint main() {\n    // Start two threads\n    std::jthread t1(runner);\n    std::jthread t2(runner);\n    // and let them run for ~5 seconds\n    using namespace std::literals::chrono_literals;\n    std::this_thread::sleep_for(5s);\n}"
        }
      ],
      "id": "xQay3Xu5",
      "createdAt": 1711977804133,
      "updatedAt": 1711977810136
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::ranges::subrange",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::ranges::subrange is a convenience wrapper that can construct a range from another range or a pair of an iterator and a sentinel.\n\nTo maintain the sized property of a range, the size can be passed as an additional argument.\n\nOne use case for std::ranges::subrange is to adapt algorithms and methods that return a pair of iterators.\n\n#include <ranges>\n#include <algorithm>\n#include <list>\n#include <set>\n\nstd::multiset<int> sorted{1,2,2,3,4,5,5,5,6,7,8,9};\n\n// multiset::equal_range() returns a pair of iterators:\nauto [left, right] = sorted.equal_range(5);\n\n// We can use ranges::subrange to turn that into a range:\nfor (auto v : std::ranges::subrange(left, right)) {\n    // Iterate over {5,5,5}\n}\n\n// std::list is a bidirectional, sized range\nstd::list<int> bidir{1,2,3,4,5};\n// OK\nstd::ranges::sized_range auto t1 = bidir;\n// OK\nstd::ranges::sized_range auto t2 = std::ranges::subrange(bidir);\n// OK, sized due to the provided size hint:\nstd::ranges::sized_range auto t3 = \n    std::ranges::subrange(begin(bidir), end(bidir), size(bidir));\n// Wouln't compile, not sized:\n/*\nstd::ranges::sized_range auto t4 = \n    std::ranges::subrange(begin(bidir), end(bidir));\n*/\n\n// More involved example relying on ranges::subrange\nstd::string_view text = R\"(This is a multi-line text\nLet's search for the lines)\";\nauto it = text.begin();\ndo {\n    auto todo = std::ranges::subrange(it, text.end());\n    auto line_break = std::ranges::find(todo, '\\n');\n    auto line = std::ranges::subrange(it, line_break);\n  \n   // Line is a subrange representing a line, we can\n    // further wrap it for more convenience:\n   // std::string_view(std::begin(line), std::end(line))\n\n    if (line_break == text.end()) break;\n    it = std::next(line_break);\n} while (true);\n// The above is mainly for demonstration, std::views::split('\\n')\n// achieves the same."
        }
      ],
      "id": "A1h7hgTA",
      "createdAt": 1711977815643,
      "updatedAt": 1711977822007
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::mismatch",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::mismatch algorithm is a find-style algorithm that operates on two ranges and returns a pair of iterators to the first two elements that do not match / for which the binary predicate returns false.\n\nWith a customized comparator, the algorithm can operate as std::find with a per-element argument.\n\n#include <algorithm>\n#include <string>\n#include <vector>\n\nstd::string text1 = \"Welcome to the underworld!\";\nstd::string text2 = \"Welcome to the overworld!\";\nauto it = std::mismatch(text1.begin(), text1.end(),\n    text2.begin());\n// *it.first == 'u', *it.second == 'o'\n\nstd::vector<double> data = {6.0, 11.0, 2.1};\nstd::vector<double> args = {1.0, 0.5, 2.0};\n// Alternative way to think about mismatch,\n// a find with per-element argument.\nauto res = std::mismatch(data.begin(), data.end(),\n    args.begin(), [](double elem, double arg) {\n        return elem*arg >= 5;\n    });\n// *res.first == 2.1, *res.second == 2.0"
        }
      ],
      "id": "y1DzQl2O",
      "createdAt": 1711977826705,
      "updatedAt": 1711977831942
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Type erasure: void*",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "One downside of relying on dynamic dispatch is the intrusive instrumentation overhead.\n\nTypes with virtual methods store a pointer to the virtual function table and are disqualified from many optimizations and conveniences (trivial copyability, aggregate initialization).\n\nFortunately, the same logic can be manually re-implemented externally using void* and function pointers.\n\n#include <memory>\n#include <string>\n#include <utility>\n#include <iostream>\n\n// Concept representing the interface (optional):\ntemplate <typename T> concept Interface = requires (T t) {\n  { t.operation() } -> std::same_as<int>;\n};\n\n// Owning variant of a generic holder\nstruct GenericHolder {\n  // Only the constructor is specific to each type:\n  template<Interface T>\n  GenericHolder(std::unique_ptr<T> ptr) {\n    // operation_ and destroy_ remember the type\n    operation_ = [](void* blob) {\n      return static_cast<T*>(blob)->operation(); \n    };\n    destroy_ = [](void* blob) {\n      delete static_cast<T*>(blob); \n    };\n    blob_ = ptr.release();\n  }\n  ~GenericHolder() {\n    if (blob_) destroy_(this->blob_);\n  }\n\n  // Move only (can be made copyable by addition of a clone_ fp)\n  GenericHolder(const GenericHolder&) = delete;\n  GenericHolder& operator=(const GenericHolder&) = delete;\n\n  // Move operations\n  GenericHolder(GenericHolder&& other)\n      : blob_(std::exchange(other.blob_, nullptr)),\n        operation_(std::exchange(other.operation_, nullptr)),\n        destroy_(std::exchange(other.destroy_, nullptr)) {}\n  GenericHolder& operator=(GenericHolder&& other) {\n      if (blob_) destroy_(blob_);\n      blob_ = std::exchange(other.blob_, nullptr);\n      operation_ = std::exchange(other.operation_, nullptr);\n      destroy_ = std::exchange(other.destroy_, nullptr);\n      return *this;\n  }\n\n  // Actual interface\n  int operation() { return operation_(this->blob_); }\n\nprivate:\n  // Generic storage, note that adding a new operation breaks ABI\n  void *blob_;\n  int (*operation_)(void*);\n  void (*destroy_)(void*);\n};\n\n// Implementations are unrelated and have no virtual methods\nstruct ImplA {\n    int operation() { return rank; }\n    int rank;\n};\n\nstruct ImplB {\n    int operation() { return std::stoi(text); }\n    std::string text;\n};\n\nvoid user(GenericHolder data) {\n    int v = data.operation();\n    std::cout << v << \"\\n\";\n}\n\nuser(GenericHolder(std::make_unique<ImplA>(10))); // OK, prints 10\nuser(GenericHolder(std::make_unique<ImplB>(\"42\"))); // OK, prints 42"
        }
      ],
      "id": "_arLEmHr",
      "createdAt": 1711977838119,
      "updatedAt": 1711977845912
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Type erasure: PIMPL",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The inheritance approach to type erasure allows users to work simultaneously with multiple implementations.\n\nHowever, if we only require one implementation at a time, we can choose a simpler and faster approach using the PIMPL pattern.\n\n#include <memory>\n#include <string>\n#include <iostream>\n\n// Header:\nstruct SomeInterface {\n    int operation() const;\n    SomeInterface();\n    SomeInterface(SomeInterface&&) = default;\n    ~SomeInterface();\nprivate:    \n    struct Implementation;\n    std::unique_ptr<Implementation> pimpl_;   \n};\n\n// User only depends on SomeInterface, implementations behind\n// SomeInterface can be swapped without affecting user.\nvoid user(SomeInterface data) {\n    int v = data.operation();\n    std::cout << v << \"\\n\";\n}\n\n// Implementation A\nstruct SomeInterface::Implementation {\n    int operation() { return rank; }\n    int rank;\n};\n\nSomeInterface::~SomeInterface() = default;\nSomeInterface::SomeInterface()\n  : pimpl_(std::make_unique<SomeInterface::Implementation>(10)) {}\n\nint SomeInterface::operation() const {\n    return pimpl_->operation();\n}\n\n// Implementation B\nstruct SomeInterface::Implementation {\n    int operation() { return std::stoi(text); }\n    std::string text;\n};\n\nSomeInterface::~SomeInterface() = default;\nSomeInterface::SomeInterface() \n  : pimpl_(std::make_unique<SomeInterface::Implementation>(\"42\")) {}\n\nint SomeInterface::operation() const {\n    return pimpl_->operation();\n}"
        }
      ],
      "id": "i81bGiZ7",
      "createdAt": 1711977865431,
      "updatedAt": 1711977874865
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Type erasure: inheritance",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Type erasure is a technique that allows the decoupling of the bit representation of implementation from the user.\n\nThis permits the user to be resilient against changes in the implementation and/or to operate on different implementations.\n\nThe simplest C++ approach to type erasure is through inheritance.\n\n#include <memory>\n#include <string>\n#include <iostream>\n\n// Abstract class, C++ doesn't have a notion of an interface:\nclass SomeInterface {\npublic:\n    // Pure virtual methods that define an interface\n    virtual int operation() = 0; \n    // Virtual destructor\n    virtual ~SomeInterface() = default;\n};\n\n// Concrete implementations have to implement all pure methods,\n// but can have any additional methods and contain arbitrary data.\nstruct ImplA : SomeInterface {\n    ImplA(int rank) : rank(rank) {}\n    int operation() override {\n        return rank;\n    }\n    int rank;\n};\n\nstruct ImplB : SomeInterface {\n    ImplB(std::string text) : text(text) {}\n    int operation() override {\n        return std::stoi(text);\n    }\n    std::string text;\n};\n\n// User only depends on SomeInterface, can accept any type\n// that implements SomeInterface:\nvoid user(std::unique_ptr<SomeInterface> data) {\n    int v = data->operation();\n    std::cout << v << \"\\n\";\n}\n\nuser(std::make_unique<ImplA>(10)); // OK, prints 10\nuser(std::make_unique<ImplB>(std::string{\"42\"})); // OK, prints 42"
        }
      ],
      "id": "gG5Y0hus",
      "createdAt": 1711977881748,
      "updatedAt": 1711977886375
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::adjacent_difference",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::adjacent_difference is a reduction/left-fold algorithm that operates on adjacent elements of a range.\n\nThe left-fold variant permits the output range to overlap with the input range (by actively caching elements).\n\nAs with other binary algorithms, the first emitted element is simply the first element from the input range.\n\n#include <numeric>\n#include <vector>\n#include <execution>\n\nstd::vector<int> data{ 1, 2, 3, 4, 5, 6, 7 };\n\n// Strict left-fold operation: result = elem - old; old = move(elem);\nstd::adjacent_difference(data.begin(), data.end(), data.begin());\n// data == {1, 1, 1, 1, 1, 1, 1}\n\n  \n// Generate Fibonacci sequence using a custom operation:\nstd::adjacent_difference(data.begin(), std::prev(data.end()),\n    std::next(data.begin()),\n    [](int l, int r) { return l+r; });\n// data == {1, 1, 2, 3, 5, 8, 13}\n\n\n// Non-linear version, output range cannot overlap input range.\nstd::vector<double> average;\nstd::adjacent_difference(std::execution::par_unseq,\n    data.begin(), data.end(),\n    std::back_inserter(average),\n    [](int curr, int prev) {\n        return (curr + prev) / 2.0;\n    });\n// average == {1, 1, 1.5, 2.5, 4, 6.5, 10.5}"
        }
      ],
      "id": "pA5dx0WC",
      "createdAt": 1711977894557,
      "updatedAt": 1711977900770
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "container::contains()",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 added the method contains() to associative and unordered containers.\n\nThis method checks for the presence of an element, simplifying the typical pattern of invoking find() and comparing against the end iterator.\n\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n\nstd::set<int> data{1, 3, 4, 5, 7};\nif (data.contains(3)) { \n  // same as: data.find(3) != data.end()\n}\n\n// Supported for associative containers: (multi_)set, (multi_)map\nstd::map<int,int> c1;\nif (c1.contains(0)) {}\n\n// And unordered containers: unordered_(multi)set, unordered_(multi)map\nstd::unordered_set<int> c2;\nif (c2.contains(0)) {}"
        }
      ],
      "id": "b17U3JkU",
      "createdAt": 1711977905841,
      "updatedAt": 1711977909282
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Implementing custom concepts",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "One way to implement custom concepts is to combine existing ones using logical AND and OR.\n\nHowever, for fully custom concepts, we might need to implement custom atomic constraints using simple, type, compound and nested requirements.\n\n#include <concepts>\n#include <string>\n\ntemplate <std::convertible_to<std::string> Text>\nstruct SomeOtherType {};\n\ntemplate <typename T>\nconcept TypeRequirements = requires {\n   // type requirement, T::value_type must name a type\n    typename T::value_type;\n   // type requirements can be template instantiations\n    typename SomeOtherType<T>; \n    // In this case, SomeOtherType<T> is only valid \n    // if T is convertible to std::string.\n};\n\ntemplate <typename T>\nconcept SimpleAndCompound = requires (T a, T b) { // optional section\n    // for creating named arguments\n\n    a + b; // simple requirement, expression a + b has to be valid\n    { a + b }; // compound version of the same\n    { a + b } noexcept; // expression valid and does not throw\n    { a + b } -> std::same_as<T>; // expression valid and returns T\n};\n\ntemplate <typename T>\nconcept Nested = requires {\n    // simplest nested requirement, always satisfied\n    requires true; \n  \n   // nested requirement\n    // std::convertible_to<T, int> must evaluate to true\n    requires std::convertible_to<T, int>;\n  \n    // Note the diference from:\n    std::convertible_to<T, int>; // simple requirement\n    // std::convertible_to<T, int> has to be\n    // a valid expression (ignores the result)\n};"
        }
      ],
      "id": "bg3pOTi-",
      "createdAt": 1711977919221,
      "updatedAt": 1711977923421
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Partial ordering of constrained function overloads",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Since C++20, functions can be constrained, establishing a partial ordering of function overloads.\n\nIf multiple candidates satisfy a function invocation, the candidate with the most specific constraint will be selected.\n\nFor practical purposes, this allows for specialized implementations that take advantage of additional features provided by the arguments.\n\n#include <concepts>\n\ntemplate <typename T> concept HasMethodA = requires (T t) {\n  { t.method_a() } -> std::integral; };\n// t.method_a() is a valid expression returning an integral type\n\ntemplate <typename T> concept HasMethodB = requires (T t) {\n  { t.method_b() } -> std::floating_point; };\n// t.method_b() is a valid expression returning a floating point type\n\ntemplate <typename T>\nconcept HasBothMethods = HasMethodA<T> && HasMethodB<T>;\n// satisfies both HasMethodA and HasMethodB concepts\n\n// For concept X = A && B, X is more specific than either A or B\n// For concept X = A || B, X is less specific than either A or B\n\nstruct X {\n    int method_a(){ return {}; }\n};\n\nstruct Y {\n    float method_b(){ return {}; }\n};\n\nstruct Z {\n    int method_a(){ return {}; }\n    float method_b(){ return {}; }\n};\n\n// Overloads with different constraints:\nvoid some_function(HasMethodA auto&&) {}\nvoid some_function(HasMethodB auto&&) {}\nvoid some_function(HasBothMethods auto&&) {}\n\nsome_function(X{}); // MethodA variant, X only satisfies HasMethodA\nsome_function(Y{}); // MethodB variant, Y only satisfies HasMethodB\nsome_function(Z{}); // BothMethods variant\n// Z satisfies HasMethodA, HasMethodB and HasBothMethods"
        }
      ],
      "id": "s9mSaTF6",
      "createdAt": 1711977929363,
      "updatedAt": 1711977935324
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Reducing implicit conversion with Concepts",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "On top of the conditional explicit specifier, C++20 gave us another tool for better control over implicit conversions.\n\nConcepts can prevent or limit the scope of implicit conversions on the accepting side.\n\n#include <concepts>\n#include <cstdint>\n\n// Prevent implicit conversions for arguments:\nvoid some_func1(int) {}\nvoid some_func2(std::same_as<int> auto) {}\n\nsome_func1(2.4); // OK, double -> int implicit conversion\nsome_func2(2.4); // Will not compile\n// auto deduces double, std::same_as<int,double> is not satisifed\n\n// Works for deduced return types:\nauto some_func3() -> int {\n    return 2.4 + 2; // OK\n}\nauto some_func4() -> std::same_as<int> auto {\n    return 2.4 + 2; // Will not compile, constraint not satisfied\n}\n\n// As well as variables:\nuint8_t a = 1, b = 2;\nuint8_t c = a + b;\nstd::same_as<uint8_t> auto d = a + b; // Will not compile\n// Integral promotion from uint8_t to int, int + int -> int"
        }
      ],
      "id": "e1S1z1dY",
      "createdAt": 1711977941157,
      "updatedAt": 1711977946333
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::vector",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::vector is the quintessential C++ data structure.\n\nIt offers random access, low memory overhead and, due to the linear layout, is cache and branch-predictor friendly. This makes it often outperform more complex data structures.\n\nWhenever picking a storage container, std::vector should be your first choice.\n\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <numeric>\n#include <random>\n#include <chrono>\n#include <iostream>\n\nusing namespace std::chrono;\n// Comparison of performance std::vector vs std::multiset for:\n// Fill with 64k random elements, then lookup 10k random elements.\n\n{\nstd::cout << \"std::vector\\n\";\nstd::mt19937 rnd(0); // Fixed seed to produce the same sequence\nstd::vector<unsigned long> data; // We could also pre-allocate\n\nauto t1 = high_resolution_clock::now();\n// Fill with random data and sort.\nstd::ranges::generate_n(std::back_inserter(data), \n    64*1024, [&rnd]() { return rnd(); });\nstd::ranges::sort(data);\n\nauto t2 = high_resolution_clock::now();\nint miss = 0;\nfor (auto i = 0; i < 10'000; i++) // lookup 10k elements\n    if (std::ranges::lower_bound(data, rnd()) == data.end())\n        ++miss;\n// Count number of misses to stop optimizer from removing this call.\n\nauto t3 = high_resolution_clock::now();\nstd::cout << \"Init \" << duration_cast<microseconds>(t2 - t1)\n    << \" Runtime \" << duration_cast<microseconds>(t3 - t2) \n    << \" Total \" << duration_cast<microseconds>(t3-t1) << \"\\n\";\n\nstd::cout << \"Number of misses: \" << miss << \"\\n\";\n}\n\n{\nstd::cout << \"std::multiset\\n\";\nstd::mt19937 rnd(0); // Fixed seed to produce the same sequence\nstd::multiset<unsigned long> data;\n\nauto t1 = high_resolution_clock::now();\n// Fill with random (but same as above) data, no need to sort.\nstd::ranges::generate_n(std::inserter(data, data.end()), \n    64*1024, [&rnd]() { return rnd(); });\n\nauto t2 = high_resolution_clock::now();\nint miss = 0;\nfor (auto i = 0; i < 10'000; i++) // lookup 10k elements\n    if (data.lower_bound(rnd()) == data.end())\n        ++miss;\n// Count number of misses to stop optimizer from removing this call.\n\nauto t3 = high_resolution_clock::now();\nstd::cout << \"Init \" << duration_cast<microseconds>(t2 - t1)\n    << \" Runtime \" << duration_cast<microseconds>(t3 - t2)\n    << \" Total \" << duration_cast<microseconds>(t3-t1) << \"\\n\";\n\nstd::cout << \"Number of misses: \" << miss << \"\\n\";\n}\n/* Example of typical output:\nstd::vector\nInit 3684us Runtime 960us Total 4645us\nNumber of misses: 2\n\nstd::multiset\nInit 12489us Runtime 1485us Total 13974us\nNumber of misses: 2\n*/"
        }
      ],
      "id": "Ga1STCpK",
      "createdAt": 1711977950078,
      "updatedAt": 1711977955965
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::stacktrace",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++23 introduced the stacktrace library. A stacktrace is represented as a container, with each entry representing one entry in the stackstrace.\n\nEach entry provides a description, source file and line number.\n\nDebug information is not required (at least for GCC).\n\n#include <iostream>\n#include <stacktrace>\n#include <format>\n\nauto fun = []() {\n   // Obtain the current stacktrace.\n    return std::stacktrace::current();\n};\n\nauto caller(auto&& c) {\n    return c();\n}\n \nint main() {\n    auto trace = caller(fun);\n    for (const auto& entry : trace) {\n        // Description, for GCC contains the name of the callable\n        std::cout << \"decription: \" << \n            entry.description() << \"\\n\";\n        // Source file and line number\n        std::cout << \"file: \" << entry.source_file() \n            << \" at line: \" << entry.source_line() << \"\\n\\n\";\n    }\n    std::cout << \"\\n\";\n\n    // Stacktrace supports stream insertion:\n    std::cout << trace << \"\\n\";\n    // And formatted output:\n    std::format_to(std::ostreambuf_iterator(std::cout),\n        \"{}\\n\", trace);\n}\n/* Example formatted output for GCC:\n   0# fun::{lambda()#1}::operator()() const at /app/example.cpp:6\n   1# auto caller<fun::{lambda()#1}&>(fun::{lambda()#1}&) at /app/example.cpp:10\n   2# main at /app/example.cpp:14\n   3#      at :0\n   4# _start at :0\n   5# \n*/"
        }
      ],
      "id": "YF0Dh-Uf",
      "createdAt": 1711977961692,
      "updatedAt": 1711977965944
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Integral conversions (different signedness)",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Mixing the signedness of integral operands can easily lead to unexpected behaviour.\n\nAfter integral promotion, if the integral operands of an operator are of different signedness, there are three possible outcomes based on the ranks and bit-width of the operands.\n\n// [A] If the unsigned operand is of the same or higher rank\n//     => the signed operand is converted to the type \n//        of the unsigned operand\nint a = -100;\nunsigned b = 0;\nauto exp1 = a + b;\n// decltype(exp1) == unsigned, exp1 == (-100 + (UINT_MAX + 1)) + 0\n\n// [B] If the type of the signed operand can represent all values\n//     of the unsigned operand\n//     => the unsigned operand is converted to the type \n//        of the signed operand\nlong c = -100;\nunsigned d = 0;\nauto exp2 = c + d;\n// decltype(exp2) == long, exp2 == -100\n\n// [C] Otherwise\n//     => both operands are converted to unsigned version\n//        of the signed argument type\nlong long e = -100;\nunsigned long f = 0; // assuming sizeof(long) == sizeof(long long)\nauto exp3 = e + f;\n// decltype(exp3) == unsigned long long\n// exp3 == (-100 + (ULLONG_MAX + 1)) + 0\n\n// Mixing signed and unsigned types can be very error-prone:\nint x = -1;\nlong y = -1;\nunsigned z = 1;\n\nbool first = x < z; // false, x -> unsigned, therefore x > z\nbool second = y < z; // true, z -> long, therefore y < z"
        }
      ],
      "id": "P__a6Hj7",
      "createdAt": 1711977970701,
      "updatedAt": 1711977975973
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Integral conversions (same signedness)",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "After integral promotion, if the integral operands of an operator are of the same signedness but different ranks, the operand of the lower rank is converted to the type of the operand with the higher rank.\n\n#include <cstdint>\n\nvoid some_func(const long&) {}\nvoid some_func(long&) {}\n\nlong x = 20;\nlong long y = 30;\nauto exp1 = x + y;\n// decltype(exp1) == long long, exp1 == 50\n\n// Note: be careful when using unconstrained generics \n// with built-in integral types.\n\n// The interactions with implicit conversion can be surprising:\nsome_func(exp1); // calls some_func(const long&)\n// long long lvalue cannot bind to long&\n// long long -(impl. conv.)-> temporary long -> some_func(const long&)\n\n{ // Potential alternatives:\n// OK, but involves a hidden implicit conversion\nlong alt1 = x + y; // long long -> long\n// Wouldn't compile, deduced type long long doesn't match\nstd::same_as<long> auto alt2 = x + y;\n}\n\nuint8_t a = 255;\nlong b = 1;\nauto exp2 = a + b;\n// decltype(exp2) == long, exp2 == 256\n// uint8_t promoted to int, then converted to long"
        }
      ],
      "id": "P6r9x7sd",
      "createdAt": 1711977986332,
      "updatedAt": 1711977991620
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Integral promotions",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Integral operands go through promotion and conversion before an operator is evaluated.\n\nPromotion is applied to operands of lower rank than int (bool, char, short). The operands are promoted to int or unsigned (if int can’t represent all values).\n\n#include <cstdint>\n\nchar x = 'A';\nauto exp1 = +x;\n// decltype(exp1) == int, exp1 == 65 (on ASCII platforms)\n\nuint8_t y = 12;\nauto exp2 = x + y;\n// decltype(exp2) == int, exp2 == 77 (on ASCII platforms)\n\nauto exp3 = -y;\n// decltype(exp3) == int, exp3 == -12\n\nuint8_t z = UINT8_MAX;\nauto exp4 = z * y;\n// decltype(exp4) == int, exp4 == 3060\n\n// Note: promotions make narrow types potentially problematic.\nuint16_t q = UINT16_MAX;\nauto err = q * q; // Undefined behaviour, signed overflow"
        }
      ],
      "id": "84T_NINN",
      "createdAt": 1711977995396,
      "updatedAt": 1711978000239
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::inner_product",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::inner_product is a left-fold reduction algorithm that, in each step, first reduces the current elements from both ranges into a single value and then folds the result into an accumulator.\n\nThe reduction and accumulation operations can be customized and, due to the strict left-to-right operation, are allowed to have state and side effects.\n\n#include <numeric>\n#include <vector>\n\n// Default operations are reduction: operator*, accumulate: operator+\nstd::vector<int> in1{1, 2, 3, 4, 5};\nstd::vector<int> in2{0, 1, 0, 1, 0};\nint res = std::inner_product(in1.begin(), in1.end(), in2.begin(), 0);\n// res == 6\n\n\nint custom = std::inner_product(in1.begin(), in1.end(), in2.begin(),\n    1, // initial accumulator\n    [](int acc, int el) { return acc * el; }, // accumulate\n    [](int first, int second) { return first+second; }); // reduce\n// custom == 225\n\n\n// The two input ranges can overlap.\n// Here we use it to count the number of rising \n// and falling edges in a signal.\nstd::vector<float> signal{1.0, 0.49, 0, 0.9, 0.1};\nauto [rising, falling] = std::inner_product(\n    signal.begin(), std::prev(signal.end()),\n    std::next(signal.begin()),\n    std::make_pair(0,0),\n    [](auto acc, auto el) {\n        return std::make_pair(\n         acc.first+el.first, \n           acc.second+el.second); \n    },\n    [](float prev, float curr) {\n        if (curr - prev > 0.5)\n   return std::make_pair(1,0); // rising edge\n        if (curr - prev < -0.5)\n           return std::make_pair(0,1); // falling edge\n        return std::make_pair(0,0); \n    });\n// rising == 1, falling == 2"
        }
      ],
      "id": "rFG_tzjd",
      "createdAt": 1711978003501,
      "updatedAt": 1711978008485
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::move",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::move is an unconditional xvalue cast, typically denoting that the state of the object being cast is no longer required and can be consumed during the expression evaluation.\n\nAs a cast, the std::move doesn’t do any moving; the moving or consumption operation is left to the operator, constructor or function that accepts the cast object.\n\n#include <utility>\n#include <stack>\n#include <vector>\n\nstruct X {};\nvoid some_func(const X& arg) {}\nvoid some_func(X&& arg) {}\n\n// Function that accepts xvalues and prvalues\nvoid example(X&& arg) {\n  // Names of variables, functions and data members are always lvalues.\n  some_func(arg); // calls some_func(const X&)\n\n  // If the above call would call some_func(X&&), arg could \n  // be silently invalidated by that call.\n\n  // However, if we actually want that, i.e. we are done with arg.\n  // We can explicitly cast arg to an xvalue.\n  some_func(std::move(arg)); // calls some_func(X&&)\n\n  // After a call to a function that accepts xvalue, assume the\n  // object is in moved-from state, i.e. the only valid operation\n  // is assigning a new value to the object (unless the type provides\n  // additional guarantees).\n}\n\nexample(X{}); // call with prvalue (temporary)\n\nstd::vector<X> data;\n{   // Typical use case for std::move\n    X some_var; // create a variable\n    some_func(some_var); // do some operations on the variable\n    // once we are done with it, we can let the final operation\n    // to consume the state\n    data.push_back(std::move(some_var));\n}\n\n\n// We can apply similar logic to getters.\nstd::stack<X> stack;\nstack.push({});\n\nauto x = stack.top(); // Copy\nauto y = std::move(stack.top()); // Move\n// However, be very careful about invalidating the internal\n// invariants of the datastructure (anything ordered).\n\n\n// Finally, applying the move cast to an immutable value produces\n// an immutable rvalue, and we cannot consume the state of\n// immutable values.\nconst X x;\nsome_func(std::move(x)); // calls some_func(const X&)\nX y = std::move(x); // Copy\n// decltype(std::move(x)) == const X&&"
        }
      ],
      "id": "N-So_lya",
      "createdAt": 1711978021562,
      "updatedAt": 1711978028335
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Implementing allocator-aware types",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "If you work with allocators, you will want to implement allocator-aware types.\n\nIf possible, you can accept an allocator as an additional constructor argument.\n\nIf this isn’t feasible, the alternative approach is to use the std::allocator_arg_t tag type as the first argument, followed by the allocator and the usual constructor arguments.\n\n#include <memory_resource>\n#include <unordered_map>\n#include <string>\n#include <vector>\n\n// Side-note, this custom hash allows us to take a std::string_view\n// as argument and use std::unordered_map methods, without\n// repeated copies and conversions between std::string,\n// std::pmr::string, or even pmr strings that do not use \n// the same backing resource.\n// For more context see Heterogenous lookup.\nstruct StringHash {\n  using is_transparent = void;\n  [[nodiscard]] size_t operator()(const char *txt) const {\n    return std::hash<std::string_view>{}(txt);\n  }\n  [[nodiscard]] size_t operator()(std::string_view txt) const {\n    return std::hash<std::string_view>{}(txt);\n  }\n  [[nodiscard]] size_t operator()(const std::string &txt) const {\n    return std::hash<std::string>{}(txt);\n  }\n  [[nodiscard]] size_t operator()(const std::pmr::string &txt) const {\n    return std::hash<std::pmr::string>{}(txt);\n  }\n};\n\n// An allocator aware type\nstruct WordCounter {\n    // The demonstration uses std::pmr for brevity, however, \n    // the same approach can be applied to static allocators, \n    // with the caveat that you would need to use\n    // std::scoped_allocator_adaptor.\n    using allocator_type = std::pmr::polymorphic_allocator<>;\n\n    // Default constructor, with an optional allocator argument\n    WordCounter(const allocator_type& alloc = {}) : counter_(alloc) {}\n    // Copy constructor\n    WordCounter(const WordCounter& other, \n                const allocator_type& alloc = {}) \n      : counter_(other.counter_, alloc) {}\n    // Move constructor, note that the move is conditional\n    // if (alloc != other.alloc), we have to default to a copy.\n    WordCounter(WordCounter&& other, \n                const allocator_type& alloc = {})\n      : counter_(std::move(other.counter_), alloc) {}\n\n    // Assignment operators remain without change\n    WordCounter& operator=(const WordCounter&) = default;\n    WordCounter& operator=(WordCounter&&) = default;\n\n    // For demonstration\n    void increment(std::string_view word) {\n        if (auto it = counter_.find(word); it != counter_.end())\n            ++(it->second);\n        else\n            counter_.emplace(word, 1);\n    }\n    void decrement(std::string_view word) {\n        if (auto it = counter_.find(word);\n            it != counter_.end() && it->second != 0)\n            --(it->second);\n    }\nprivate:\n    // Our storage that gets customized with the allocator\n    std::pmr::unordered_map<\n        std::pmr::string, uint64_t,\n        // custom hash and std::equal_to<>\n        // to allow for heterogenous lookup\n        StringHash, std::equal_to<>> counter_; \n};\n\n// If we cannot put the allocator as the last argument,\n// we can use the std::allocator_arg_t tag.\ntemplate <typename... Types>\nstruct VariadicType {\n    using allocator_type = std::pmr::polymorphic_allocator<>;\n\n    // Tag first, followed by the allocator, other arguments follow.\n    VariadicType(std::allocator_arg_t, const allocator_type& alloc, \n        Types&&... args) {}\n    // And we need to keep the non-allocator version around.\n    VariadicType(Types&&... args) {}\n\n    // For copy/move, we can use the normal style\n    VariadicType(const VariadicType&, const allocator_type = {}) {}\n    VariadicType(VariadicType&&, const allocator_type = {});\n};\n\n\nstd::pmr::monotonic_buffer_resource buffer;\n\n// We can wrap allocator aware types in containers and the outer\n// allocator will be correctly applied to the elements.\n// Note: for non-pmr, you would need std::scoped_allocator_adaptor\nstd::pmr::vector<WordCounter> counters(&buffer);\n\n// Construct WordCounter, using the allocator constructor.\n// The vector will allocate memory from the allocator.\ncounters.emplace_back();\n// The map will allocate the bucket array and the node using the \n// allocator. The string fits into small string optimization.\ncounters[0].increment(\"hello\");\n// Same as above, except the bucket array is already allocated\n// and the string also needs to allocate.\ncounters[0].increment(\"this string is long enough\");\n\nstd::pmr::vector<VariadicType<int,int,int>> variadic(&buffer);\nvariadic.emplace_back(1,2,3); // Calls the allocator constructor"
        }
      ],
      "id": "2o1qOA4o",
      "createdAt": 1711978034290,
      "updatedAt": 1711978045344
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "The PMR (Polymorphic Memory Resource) library",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++17 introduced the PMR (Polymorphic Memory Resource) library.\n\nThe memory resources in the library offer different allocation patterns and can be chained (a resource will use the parent resource to allocate its internal state/buffers).\n\nThe type erased std::pmr::polymorphic_allocator allows containers using different memory resources to be ABI compatible.\n\n#include <memory_resource>\n#include <list>\n#include <string>\n#include <array>\n\n// The library offers shorthand aliases in the pmr namespace:\nstd::pmr::list<int> list1;\n// Equivalent full type:\nstd::list<int, std::pmr::polymorphic_allocator<int>> list2;\n// decltype(list1) == decltype(list2)\nstatic_assert(std::is_same_v<decltype(list1),decltype(list2)>);\n\n// The two backend resources:\n// std::pmr::new_delete_resource - calls new/delete\n// std::pmr::null_memory_resource - throws std::bad_alloc on allocation\n\n// OK, fits into small string optimization:\nstd::pmr::string s1(\"hello world\",\n    std::pmr::null_memory_resource());\n// OK, doesn't fit into small string optimization,\n// but will call new to allocate.\nstd::pmr::string s2(\"this string is long enough\",\n    std::pmr::new_delete_resource());\ntry {\n    // Will throw, string doesn't fit into small string optimization:\n    std::pmr::string s3(\"this string is long enough\",\n        std::pmr::null_memory_resource());\n} catch (const std::bad_alloc&) {}\n\n// The monotonic_buffer_resource allocates within a buffer.\n// Once the buffer is full, another buffer will be allocated\n// using the parent resource. Only deallocates on destruction.\n\n// The default instantiation uses the new_delete_resource \n// and no initial buffer.\nstd::pmr::monotonic_buffer_resource pool1;\nstd::pmr::list<int> list3(&pool1);\n\nstd::array<std::byte, 512*1024> buffer;\n// Example of a monotonic buffer using a stack allocated buffer\n// as the initial and only memory.\nstd::pmr::monotonic_buffer_resource pool2(\n    buffer.data(), buffer.size(),\n    std::pmr::null_memory_resource());\nstd::pmr::list<int> list4(&pool2);\n\n// The pool_resource manages pools of memory that serve\n// for allocations of the same size.\nstd::pmr::unsynchronized_pool_resource pool3({\n    // The pool will allocate blocks*sizeof(chunk) at a time.\n    .max_blocks_per_chunk = 64, \n    // Larger requests than this will bypass the pool \n    // and be served directly by the upstream resource.\n    .largest_required_pool_block = 512,\n});\nstd::pmr::list<int> list5(&pool3);\n\n// The polymorphic_allocator correctly handles nested containers.\nstd::pmr::list<std::pmr::string> list6(&pool3);\nlist6.emplace_back(\"this string is long enough\");\n// Both the node and string will be allocated in the pool.\n\n// The library also offers std::pmr::synchronized_pool_resource,\n// which is a thread safe version."
        }
      ],
      "id": "tyuP5DDE",
      "createdAt": 1711978050100,
      "updatedAt": 1711978056593
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::future<void>, std::shared_future<void>",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "If you require simple one-shot signalling between threads (and are stuck in pre-C++20 times), the void specializations of std::future and std::shared_future can serve as solid high-level choices for 1:1 and 1:N signalling.\n\n#include <thread>\n#include <future>\n\n// Our runner with two stages, executes first stage eagerly,\n// but waits for signal to continue to the second stage.\nauto wait_for_signal = [](auto future) {\n  // first stage\n  future.wait(); // wait on signal\n  // second stage\n};\n\n{ // 1:1 example\nstd::promise<void> sender;\nauto t = std::jthread(wait_for_signal, sender.get_future());\n// First stage eagerly executing\nsender.set_value(); // Unblock the second stage by sending a signal\n}\n\n{ // 1:N example\nstd::promise<void> sender;\n// Reminder, promise::get_future() can only be called once\nstd::shared_future<void> receiver(sender.get_future());\n\n// Start four threads, each running our two-stage runner\nstd::vector<std::jthread> runners;\nstd::generate_n(std::back_inserter(runners), 4, [&]{\n    return std::jthread(wait_for_signal, receiver);\n});\n// First stage eagerly executing for all four threads\nsender.set_value(); // Unblock the second stage by sending a signal\n}"
        }
      ],
      "id": "siA2TrwV",
      "createdAt": 1711978061693,
      "updatedAt": 1711978067883
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "The <bit> header",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++20 introduced the <bit> header with a group of functions for manipulating and querying bits in unsigned integers.\n\nThese functions were previously only available as compiler extensions.\n\n#include <bit>\n#include <cstdint>\n\nuint64_t x = 42u;\n// How many bits to represent a value?\nint bitcnt = std::bit_width(x);\n// bitcnt == 6\n\n// floor: largest power of two <= value\n// ceil: smallest power of two >= value\nuint64_t floor = std::bit_floor(x);\nuint64_t ceil = std::bit_ceil(x);\n// x     ==  0b101010\n// floor ==  0b100000\n// ceil  == 0b1000000\n\n// Counting consecutive 0s/1s from left and right\nuint16_t y = 0b1110000000001111;\nint ones_left = std::countl_one(y);\nint ones_right = std::countr_one(y);\n// ones_left == 3, ones_right == 4\n\nuint16_t z = 0b0001111111110000;\nint zeros_left = std::countl_zero(z);\nint zeros_right = std::countr_zero(z);\n// zeros_left == 3, zeros_right == 4\n\n// Bitwise rotations\nuint16_t i = 0b1000100010001000;\nuint16_t a = std::rotl(i, 1);\n// a == 0b0001000100010001\nuint16_t b = std::rotl(i, 2);\n// b == 0b0010001000100010\nuint16_t c = std::rotr(i, 1);\n// c == 0b0100010001000100\nuint16_t d = std::rotr(i, 2);\n// d == 0b0010001000100010\n\n// Counting number of one-bits anywhere\nconstexpr uint64_t FLAG_A = 1 << 0;\nconstexpr uint64_t FLAG_B = 1 << 1;\nconstexpr uint64_t FLAG_C = 1 << 2;\n\nbool exclusive = std::has_single_bit(FLAG_C);\n// exclusive == true\nint cnt = std::popcount(FLAG_A | FLAG_C);\n// cnt == 2"
        }
      ],
      "id": "XlYOe8IB",
      "createdAt": 1711978074483,
      "updatedAt": 1711978084056
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Trivially copyable types",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Trivially copyable types are an important performance concept in C++.\n\nA trivially copyable object can be treated as a block of bits and copied using primitive memory operations (e.g. memcpy and memmove).\n\n// Trivially copyable class-types:\n// - one eligible trivial copy/move-constr. or copy/move-assign.\n// - no eligible non-trivial copy/move-constr. and copy/move-assign.\n// - non-deleted trivial destructor\n\n// Trivial special member function (constr., assign., destr.):\n// - implicit or defaulted\n// - no virtual members or bases\n// - recursively trivial:\n//   - all bases and non-static members have corresponding\n//     trivial constr./assign./destr.\n\n// Trivially copyable example:\n// ✔ implicit copy&move constructors && copy&move assignments\n// ✔ implicit destructor\n// ✔ no virtual members or bases\n// ✔ all members are trivially copyable\n// ✔ all bases are trivially copyable\nstruct X {\n    X() { std::iota(data.begin(), data.end(), 1); }\n    std::span<int> get_buff() { return data; }\nprivate:\n    std::array<int, 42> data;\n};\n\n// Trivially copyable despite being move-only:\n// ✔ defaulted move-constructor && move-assignment\n// ✔ implicit destructor\n// ✔ no virtual members or bases\n// ✔ all members are trivially copyable\n// ✔ all bases are trivially copyable\nstruct Y {\n    Y(const Y&) = delete;\n    Y& operator=(const Y&) = delete;\n    Y(Y&&) = default;\n    Y& operator=(Y&&) = default;\nprivate:\n    int x;\n    float y;\n};\n\n// Not trivially copyable\n// ❌ std::string is not trivially copyable\nstruct Z {\n    std::string text;\n};"
        }
      ],
      "id": "bDJAnbr1",
      "createdAt": 1711978087819,
      "updatedAt": 1711978092786
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Explicit object parameter (a.k.a. deducing this)",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++23 explicit object parameter (a.k.a. deducing this) introduces the ability to name the previously implicit “this” argument explicitly.\n\nThis allows for different spellings of method variants (lvalue, const lvalue, rvalue).\n\nCombined with type deduction, it finally allows spelling all three variants as one generic method (significantly reducing code duplication).\n\n// Old spelling\nstruct Old {\n    // Also can be spelled as: \"void method() {}\"\n    void method() & { /* lvalue */ } \n    // Also can be spelled as: \"void method() const {}\"\n    void method() const& { /* immutable lvalue */ }\n    void method() && { /* rvalue */ }\n};\n\n// New spelling\nstruct New {\n    void method(this New&) { /* lvalue */ }\n    void method(this const New&) { /* immutable lvalue */ }\n    void method(this New&&) { /* rvalue */ }\n};\n\n// One deduced method that handles all three cases\nstruct Universal {\n    void method(this auto&& self) {\n      // Will deduce one of:\n      // Universal&, const Universal& or Universal&&\n    }\n};\n\n// A practical example of the above\nstruct Practical {\n    // Single getter that handles all three variants\n    auto&& get(this auto&& self) {\n        // Based on the type of this, forward as lvalue, or rvalue\n        return std::forward_like<decltype(self)>(self.value);\n    }\nprivate:\n    int value = 0;\n};\n\n// We can also spell a copy\nstruct Object {\n    // Operate on a copy of the object\n    void method(this Object self) {}\n};\n\n// The deduction path can also be used as CRTP replacement\nstruct InjectMethod {\n    // Because self is deduced, it will be the static type \n    // at the call site, i.e. the derived type.\n    void do_stuff(this const auto& self) {\n        puts(\"I did stuff.\");\n        self.do_other_stuff();\n    }\n};\n\nstruct Derived : InjectMethod {\n    void do_other_stuff() const {\n        puts(\"And then other stuff.\");\n    }\n};"
        }
      ],
      "id": "MPbEfEu7",
      "createdAt": 1711978097951,
      "updatedAt": 1711978106519
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::reverse_iterator",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "std::reverse_iterator is an iterator adapter that adapts (at least bidirectional) iterators for reverse iteration.\n\nNote that to correctly model begin() and end(), the pointed-to element is offset by one.\n\n    begin(), which points to the first element, maps to rend(), which points one before\n    end(), which points to one after maps to rbegin(), which points to the last element\n\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> data{1, 2, 3, 4, 5, 6};\n\n// bidirectional containers provide rbegin() and rend() methods\n// that return a reverse iterators\nfor (auto it = data.rbegin(); it != data.rend(); it++) {\n    // iterates over { 6, 5, 4, 3, 2, 1 }\n}\n\n// Reverse iterators are offset by one element\nauto rbegin = std::make_reverse_iterator(data.end());\n// end points outside of the array, rbegin points to the last element\nauto rend = std::make_reverse_iterator(data.begin());\n// begin points to the first element, rend points outside of the array\n\n// reverse iterator to the first element in original order, \n// last element in reverse order\nauto it  = std::make_reverse_iterator(std::next(data.begin()));\n// *it == 1\n\n// Reverse iteration comes handy with linear algorithms\n// that operate left-to-right\nstd::string text = \"racecar\";\nbool is_palindrome = std::equal(\n        text.begin(), text.end(), // left-to-right\n        text.rbegin()); // right-to-left\n// is_palindrome == true"
        }
      ],
      "id": "gxTD8XF_",
      "createdAt": 1711978111625,
      "updatedAt": 1711978119066
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Mixing integral and floating point types",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When mixing integers with floating point types in arithmetic expressions, the result of the expression is always a floating point type.\n\nIf multiple floating point types are present, the result of the expression is the highest present floating point type: float, double or long double (in that order).\n\n#include <cstdint>\n\nauto exp1 = 2 * 1.2;\n// int * double, decltype(exp1) == double\n\nint64_t x = 20;\nfloat y = 0.2;\nauto exp2 = x + y; // same as INT64_C(20) + .2f\n// int64_t + float, decltype(exp2) == float\n\nauto exp3 = 0.2f * 3 + 2.1;\n// float * int + double, decltype(exp3) == double"
        }
      ],
      "id": "KaCILay-",
      "createdAt": 1711978122966,
      "updatedAt": 1711978126870
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::set_union, std::set_intersection, std::set_difference, std::set_symmetric_difference",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The four algorithms: std::set_union, std::set_intersection, std::set_difference and std::set_symmetric_difference provide the corresponding set operations on top of sorted ranges.\n\nBecause C++ objects can be both equivalent yet distinct, there is additional complexity in which elements are selected.\n\n#include <string>\n#include <algorithm>\n#include <vector>\n\nstruct E {\n    int v;\n    std::string label;\n    auto operator<=>(const E& other) const {\n        return v <=> other.v;\n    }\n};\n\nstd::vector<E> in1{{1,\"a\"},{2,\"a-1\"},{2,\"a-2\"}};\nstd::vector<E> in2{{2,\"b-1\"},{2,\"b-2\"},{2,\"b-3\"},{3,\"b\"}};\nstd::vector<E> out;\n\n// Intersection, common elements are picked from the first range\nstd::set_intersection(in1.begin(), in1.end(),\n    in2.begin(), in2.end(),\n    std::back_inserter(out));\n// out == {{2,\"a-1\"},{2,\"a-2\"}}\n\nout.clear();\n// Union, overlapping elements are picked from the first range,\n// non-overlapping elements are picked from their source range.\nstd::set_union(in1.begin(), in1.end(),\n    in2.begin(), in2.end(),\n    std::back_inserter(out));\n// out == {{1,\"a\"},{2,\"a-1\"},{2,\"a-2\"},{2,\"b-3\"},{3,\"b\"}}\n\nout.clear();\n// Difference, overlapping elements are skipped,\n// non-overlapping elements are picked from the first range.\nstd::set_difference(in1.begin(), in1.end(),\n    in2.begin(), in2.end(),\n    std::back_inserter(out));\n// out == {{1,\"a\"}}\n\nout.clear();\n// Symmetric difference, overlapping elements are skipped,\n// non-overlapping elements are picked from their source range.\nstd::set_symmetric_difference(in1.begin(), in1.end(),\n    in2.begin(), in2.end(),\n    std::back_inserter(out));\n// out == {{1,\"a\"},{2,\"b-3\"},{3,\"b\"}}"
        }
      ],
      "id": "QYlJxPQC",
      "createdAt": 1711978130994,
      "updatedAt": 1711978135678
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "auto(), auto{}",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The C++23 added a new use case for the auto keyword. auto can now produce a prvalue copy of an argument.\n\nauto(arg) being equivalent to T(arg) and auto{arg} being equivalent to T{arg}, with the benefit that we do not have to get access to T (using T = std::decay_t<decltype(arg)>;).\n\nDue to C++17 direct initialization, auto will never produce excessive copies.\n\n#include <vector>\n#include <algorithm>\n\nstruct S {};\n\nstd::vector<int> data{1,2,2,1};\nstd::erase(data, data[0]); // OOPS\n// data == {2,1} (implementation specific result)\n\ndata = {1,2,2,1};\nstd::erase(data, auto(data[0])); // correct\n// data == {2,2}\n\n// direct initialization, all the way through, no copies\nauto v = auto(auto(auto(S{})));"
        }
      ],
      "id": "dz4M0Zqw",
      "createdAt": 1711978140254,
      "updatedAt": 1711978144372
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::enable_shared_from_this",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "When working with objects managed by std::shared_ptr, we might need to give out access to the shared ownership of this object (e.g. when working with callbacks) without access to a std::shared_ptr that holds the ownership.\n\nThe std::enable_shared_from_this mixin provides the method shared_from_this(), which returns a std::shared_ptr with access to the shared ownership.\n\n#include <memory>\n#include <future>\n#include <cassert>\n\nstruct SharedObject : std::enable_shared_from_this<SharedObject> {\n    std::future<void> spawn() {\n        // Spawn an asynchronous lambda giving \n        // it a shared_ptr to this object.\n        return std::async(std::launch::async, \n                          [handle = shared_from_this()]{\n            // The std::shared_ptr will keep the instance alive,\n            // at least until this lambda completes.\n        });\n    }\n  \n    // Give shared ownership of this object to the caller.\n    std::shared_ptr<SharedObject> give_ownership() {\n        return shared_from_this();\n    }\n};\n\n\nstd::future<void> sync_point;\n{\nauto ptr = std::make_shared<SharedObject>();\n\n// Without std::enabled_shared_from_this we couldn't easily obtain\n// a handle to the instance of the object without having access\n// to the original shared_ptr.\nSharedObject& obj = *ptr;\nauto ptr2 = obj.give_ownership();\n// Both shared pointers point to the same object (and share counters)\nassert(ptr.get() == ptr2.get());\n\n// Spawn an asynchronous operation.\nsync_point = ptr->spawn();\n}\n// At this point the original ptr handle is dead.\n// Synchronize with the async lambda.\nsync_point.wait();\n\n// The original object has to be held under a shared_ptr.\n// Calls to shared_from_this() on objects that are not\n// held by a shared_ptr will throw std::bad_weak_ptr.\nSharedObject obj;\ntry {\n    // This will throw\n    auto handle = obj.give_ownership();\n} catch (const std::bad_weak_ptr& err) {\n    // Catch the exception...\n}"
        }
      ],
      "id": "v8feXCQp",
      "createdAt": 1711978149580,
      "updatedAt": 1711978155515
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::count, std::count_if",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::count and std::count_if are linear search (counting) algorithms that return the number of elements matching either a provided value or a provided predicate.\n\nBoth variants support a parallel version through std::execution.\n\n#include <algorithm>\n#include <vector>\n#include <execution>\n\nstd::vector<int> data{1, 2, 1, 2, 3, 1, 2, 3, 4};\n\n// Count elements matching a value:\nauto cnt = std::count(data.begin(), data.end(), 2);\n// cnt == 3\n\n// Count elements matching a predicate:\nauto even = std::count_if(data.begin(), data.end(),\n    [](int v) { return v % 2 == 0; });\n// even == 4\n\n// Both variants support parallel execution:\nauto even_par = std::count_if(std::execution::par_unseq,\n    data.begin(), data.end(),\n    [](int v) { return v % 2 == 0; });\n// even_par == 4"
        }
      ],
      "id": "hFWzptXv",
      "createdAt": 1711978158951,
      "updatedAt": 1711978162606
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::abort, std::terminate",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Termination is likely the most sensible reaction when a program reaches an irrecoverable state, notably when invariants are violated.\n\nThe standard ways to terminate are std::abort (C) and std::terminate (C++).\n\nBoth approaches allow for custom handlers (albeit very limited in the case of std::abort).\n\n#include <string_view>\n#include <cstdlib>\n#include <csignal>\n#include <unistd.h> // for write()\n\nvoid abort_handler(int) {\n    std::string_view msg = \"Abort handler invoked\\n\";\n    // Signal handlers are extremely limited, one of\n    // the few ways to iteract with the outside\n    // environment is using write() which requires POSIX.\n    write(2, msg.data(), msg.length());\n    // We can prevent abnormal program termination by:\n    // std::_Exit(EXIT_FAILURE);\n}\n\nint main() {\n    // Setup a custom handler for the abort signal:\n    std::signal(SIGABRT, abort_handler);\n    // Trigger termination:\n    abort();\n}\n\nOpen the std::abort example in Compiler Explorer.\n\n#include <exception>\n#include <iostream>\n\nvoid terminate_handler() {\n    std::cerr << \"Terminate handler invoked.\\n\";\n    if (std::current_exception() != nullptr) {\n        std::cerr << \"We have an exception in flight:\\n\";\n        try {\n            throw; // rethrow\n        } catch (const std::exception& e) {\n            std::cerr << e.what() << \"\\n\";\n        }\n    }\n    // Terminate handler cannot exit \n    // i.e. the program must terminate in some way\n    // for normal exit:\n    // std::_Exit(EXIT_FAILURE);\n    // for abnormal exit:\n    abort(); // This could chain to the SIGABRT handler\n}\n\nint main() {\n    // Setup the handler:\n    std::set_terminate(terminate_handler);\n    try {\n        // Throw an exception to demonstrate \n        // the availability in the terminate handler.\n        throw std::runtime_error(\"Something...\");\n    } catch (...) {\n        // Terminate the program\n        std::terminate();\n    }\n}"
        }
      ],
      "id": "oHi6gwpd",
      "createdAt": 1711978166145,
      "updatedAt": 1711978174868
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Lambda to function pointer",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "Lambdas with empty capture are still function objects but can be implicitly converted to function pointers.\n\nIn some contexts (notably when type deduction is involved), it can be helpful to force this conversion.\n\nOne approach is static_cast, but the unary plus operator offers a more concise approach.\n\n#include <iostream>\n\ntemplate <typename Callback>\nstruct X {\n    Callback call;\n};\n\n// Each lambda expression produces a unique distinct type.\nX x1([]() { std::cout << \"Hello World!\\n\"; });\nX x2([]() { std::cout << \"Hello Universe!\\n\"; });\nstatic_assert(!std::is_same_v<decltype(x1),decltype(x2)>);\n\n// unary + operator does not work on lambdas but does work on pointers\n// it forces the lambda -> function pointer implicit conversion\nX x3(+[]() { std::cout << \"Hello World!\\n\"; });\nX x4(+[]() { std::cout << \"Hello Universe!\\n\"; });\nstatic_assert(std::is_same_v<decltype(x3),decltype(x4)>);\n\n// static_cast approach\nX x5(static_cast<void(*)()>([]() { std::cout << \"Same old.\\n\"; }));\nstatic_assert(std::is_same_v<decltype(x4), decltype(x5)>);"
        }
      ],
      "id": "Rnwllu0T",
      "createdAt": 1711978189843,
      "updatedAt": 1711978195219
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::packaged_task",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "The std::packaged_task is a C++11 callable wrapper, similar to std::function, providing direct access to a std::future.\n\nThe std::packaged_task provides a more natural and simpler workflow than manually setting up and passing through a std::promise.\n\n#include <thread>\n#include <future>\n\n{ // with packaged_task\nauto c = std::packaged_task{[](){\n    return 42;\n}};\n\nauto future = c.get_future();\n// Start a new thread with the task:\nauto t = std::jthread(std::move(c));\n\n// Block until the packaged task finishes:\nint v = future.get();\n// v == 42\n}\n\n{ // equivalent code using a std::function and std::promise:\nstd::promise<int> p;\nauto future = p.get_future();\nauto c = std::function([](std::promise<int> promise){\n    promise.set_value(42);\n});\n\n// Start a new thread with the task:\nauto t = std::jthread(std::move(c), std::move(p));\n\n// Block until the task finishes:\nint v = future.get();\n// v == 42\n}"
        }
      ],
      "id": "wu7YWmxl",
      "createdAt": 1711978200178,
      "updatedAt": 1711978204656
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "[[deprecated]]",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++14 introduced the [[deprecated]] attribute that can be used to mark symbols as deprecated, resulting in a warning from the compiler when the symbol is used.\n\nAdditional text can be included with the attribute and will be visible as part of the generated warning.\n\n// Marking a function with the deprecated attribute \n// will produce a warning when the function is called.\n[[deprecated]]\nvoid old_api() {}\n\n// Optional text that will be included in the warning.\n[[deprecated(\"Use new_api() instead.\")]]\nvoid another_old_api() {}\n\n// Prefix:\n[[deprecated]] int v; // variable\n[[deprecated]] typedef int Int; // typedef\n[[deprecated]] void fun() {} // function\nstruct Z { [[deprecated]] int z; }; // members\n\n// Infix:\nstruct [[deprecated]] X {}; // struct/class/union\ntemplate <typename T> struct [[deprecated]] Y {}; // templates\ntemplate <typename T> [[deprecated]] void fn() {}\nnamespace [[deprecated]] Nsp {} // namespace\nenum [[deprecated]] Enum {}; // enumeration\n\n// Suffix:\nusing Uint [[deprecated]] = unsigned; // type alias\nenum { Potato [[deprecated]] = 42 }; // enumerator\n\n\nold_api();\n// warning: 'void old_api()' is deprecated\nanother_old_api();\n// warning: 'void another_old_api()' is deprecated: \n//          Use new_api() instead."
        }
      ],
      "id": "k24Z54Ke",
      "createdAt": 1711978210460,
      "updatedAt": 1711979307420
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "unicode konverze conversion string2wstring wstring2string",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <locale>\n#include <codecvt>\n#include <string>\n\nstd::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;\nstd::string narrow = converter.to_bytes(wide_utf16_source_string);\nstd::wstring wide = converter.from_bytes(narrow_utf8_source_string);\n"
        }
      ],
      "id": "5rUYJ9l6",
      "createdAt": 1711990699830,
      "updatedAt": 1711990948473
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "WinMain no console",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <windows.h> // nutne\n\nint APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, PSTR cmdline, int cmdshow)\n{\n    return MessageBox(NULL, \"hello, world\", \"caption\", 0);\n}\n\nlinker option\n\"-mwindows\""
        }
      ],
      "id": "Xt8UtU6x",
      "createdAt": 1712035339347,
      "updatedAt": 1712160555904
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "sleep 1/60 second",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <thread>\n#include <chrono>\n\n// Wait 1/60 second\nstd::this_thread::sleep_for(std::chrono::duration<double>(1.0/60));\n"
        }
      ],
      "id": "Y8mqtEKI",
      "createdAt": 1712035788472,
      "updatedAt": 1712035842704
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "miGUI - myGlyph - cz support",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "// Support for CZ language \n    static ImVector<ImWchar> myRange;\n    ImFontGlyphRangesBuilder myGlyph;\n    ImWchar base_ranges[] = // not zero-terminated\n    {\n        // https://www.unicode.org/charts/\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\n        0x0100, 0x017F, // Latin Extended-A\n        0x0180, 0x024F, // Latin Extended-B\n        0x2000, 0x20FF // General Punctuation\n    };\n    // also possible to use with exactly specified ranges\n    // myGlyph.AddText((const char *)\"přílišžluťoučkýkůňúpělďábelskéódy\");\n    myGlyph.AddRanges(base_ranges); \n    myGlyph.BuildRanges(&myRange);        \n    io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\Albertsthal Typewriter.ttf\", 38.0f, nullptr, myRange.Data);"
        }
      ],
      "id": "vI_8iySW",
      "createdAt": 1712088073851,
      "updatedAt": 1712088718730
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "TO DO cmake default template project",
      "content": [
        {
          "label": "Fragment 1",
          "language": "makefile",
          "value": "cmake_minimum_required(VERSION 3.5.0)\nproject(Trans4Me VERSION 0.1.0 LANGUAGES C CXX)\n\ninclude(CTest)\nenable_testing()\n\n# Nastavení projektu pro Unicode\n# add_definitions(-DUNICODE -D_UNICODE)\n\n# list fo source files \nset(SRC_FILES \n    Tran4Me.cpp\n    ${PROJECT_SOURCE_DIR}/gtranslator/gtranslator.cpp\n    ${PROJECT_SOURCE_DIR}/myui/myui_sdl2_opengl3.hpp\n    c:/Projects/_Dep/imgui/docking/imgui/imgui.cpp\n)\n\n# Použijte přepínač WIN32 pro skrytí konzolového okna\nadd_executable(Tran4Me WIN32 ${SRC_FILES})\n\n# # list fo header paths \ntarget_include_directories(Tran4Me PUBLIC\n    ${PROJECT_SOURCE_DIR}/\n    ${PROJECT_SOURCE_DIR}/myui\n    c:/Projects/_Dep/imgui/docking/imgui\n    c:/Projects/_Dep/imgui/docking/imgui/backends\n    c:/Projects/_Dep/sdl/SDL-release-2.30.1-install/include/SDL2/\n)\n\n# Nastavení cesty k statickým knihovnám SDL2\nset(SDL2_PATH \"c:\\\\Projects\\\\_Dep\\\\sdl\\\\SDL-release-2.30.1-install\\\\\")\n# Nastavení cesty k statické knihovně SDL2\nfind_library(SDL2_LIBRARIES SDL2 PATHS ${SDL2_PATH}/lib NO_DEFAULT_PATH)\n# Přidání přepínače pro statické propojení libstdc++ a libgcc\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -static-libstdc++\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -static-libgcc\")\n\ntarget_link_libraries(Tran4Me PUBLIC\n    gdi32\n    dwmapi\n    opengl32\n    shell32\n    curl\n    SDL2\n    SDL2main\n)\n\nset(CPACK_PROJECT_NAME ${PROJECT_NAME})\nset(CPACK_PROJECT_VERSION ${PROJECT_VERSION})\ninclude(CPack)"
        }
      ],
      "id": "mxrwdkEN",
      "createdAt": 1712143050642,
      "updatedAt": 1713002134944
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": "Spustí CMAKE build pomocí klávesy F5",
      "name": "cmake F5 launch.json for VSCode",
      "content": [
        {
          "label": "Fragment 1",
          "language": "json",
          "value": "{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(gdb) Launch by cmake\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            // Resolved by CMake Tools:\n            \"program\": \"${command:cmake.launchTargetPath}\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [\n                {\n                    // add the directory where our target was built to the PATHs\n                    // it gets resolved by CMake Tools:\n                    \"name\": \"PATH\",\n                    \"value\": \"${env:PATH}:${command:cmake.getLaunchTargetDirectory}\"\n                },\n                {\n                    \"name\": \"OTHER_VALUE\",\n                    \"value\": \"Something something\"\n                }\n            ],\n            \"externalConsole\": true,\n            \"MIMode\": \"gdb\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ]\n        }\n    ]\n}"
        }
      ],
      "id": "mp6jsfmw",
      "createdAt": 1712157115401,
      "updatedAt": 1717193597107
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "enum class vs plain enum",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "C++ has two kinds of enum:\n\n    enum classes\n    Plain enums\n\nHere are a couple of examples on how to declare them:\n\n enum class Color { red, green, blue }; // enum class\n enum Animal { dog, cat, bird, human }; // plain enum \n\nWhat is the difference between the two?\n\n    enum classes - enumerator names are local to the enum and their values do not implicitly convert to other types (like another enum or int)\n\n    Plain enums - where enumerator names are in the same scope as the enum and their values implicitly convert to integers and other types\n\nExample:\n\nenum Color { red, green, blue };                    // plain enum \nenum Card { red_card, green_card, yellow_card };    // another plain enum \nenum class Animal { dog, deer, cat, bird, human };  // enum class\nenum class Mammal { kangaroo, deer, human };        // another enum class\n\nvoid fun() {\n\n    // examples of bad use of plain enums:\n    Color color = Color::red;\n    Card card = Card::green_card;\n\n    int num = color;    // no problem\n\n    if (color == Card::red_card) // no problem (bad)\n        cout << \"bad\" << endl;\n\n    if (card == Color::green)   // no problem (bad)\n        cout << \"bad\" << endl;\n\n    // examples of good use of enum classes (safe)\n    Animal a = Animal::deer;\n    Mammal m = Mammal::deer;\n\n    int num2 = a;   // error\n    if (m == a)         // error (good)\n        cout << \"bad\" << endl;\n\n    if (a == Mammal::deer) // error (good)\n        cout << \"bad\" << endl;\n\n}\n\nConclusion:\nenum classes should be preferred because they cause fewer surprises that could potentially lead to bugs.\n"
        }
      ],
      "id": "3XanD13Z",
      "createdAt": 1712167348521,
      "updatedAt": 1712167520693
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "TRNwKjeZ",
      "tagsIds": [],
      "description": null,
      "name": "UpWork Profile",
      "content": [
        {
          "label": "Fragment 1",
          "language": "markdown",
          "value": "I am very glad that I can offer you through this platform my IT experience and services. I can write a customized application for you, manage the Windows operating system, or Linux based on Debian. I can also install and help you remotely with your task, or I can advise you otherwise or train you in an area in which I have knowledge. My 20 years of experience allows me to offer a wide portfolio of IT services.\n\nThank you for choosing me and looking forward to mutual cooperation."
        }
      ],
      "id": "A7O2Yfso",
      "createdAt": 1712296159142,
      "updatedAt": 1712449293462
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "std::lock_guard",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "/** @brief A simple scoped lock type.\n   *\n   * A lock_guard controls mutex ownership within a scope, releasing\n   * ownership in the destructor.\n   *\n   * @headerfile mutex\n   * @since C++11\n   */\n  template<typename _Mutex>\n    class lock_guard\n    {\n    public:\n      typedef _Mutex mutex_type;\n\n      explicit lock_guard(mutex_type& __m) : _M_device(__m)\n      { _M_device.lock(); }\n\n      lock_guard(mutex_type& __m, adopt_lock_t) noexcept : _M_device(__m)\n      { } // calling thread owns mutex\n\n      ~lock_guard()\n      { _M_device.unlock(); }\n\n      lock_guard(const lock_guard&) = delete;\n      lock_guard& operator=(const lock_guard&) = delete;\n\n    private:\n      mutex_type&  _M_device;\n    };"
        }
      ],
      "id": "Qk75qRrV",
      "createdAt": 1712384170011,
      "updatedAt": 1712384179412
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Kontrola přiřazeného oprávnění pro guest user v uživatelské databází:",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Kontrola přiřazeného oprávnění pro guest user v uživatelské databází:\nUSE MyDB\nSELECT class ,\nclass_desc ,\nmajor_id ,\nminor_id ,\ngrantee_principal_id ,\ngrantor_principal_id ,\ntype ,\npermission_name ,\nstate ,\nstate_desc\nFROM sys.database_permissions\nWHERE grantee_principal_id = USER_ID('guest')\nAND state = N'G'\nAND type = N'CO"
        }
      ],
      "id": "LknSfNZ9",
      "createdAt": 1712516846226,
      "updatedAt": 1712520693079
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Kontrola sysadmin a dbcreator fixed server role:",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Kontrola sysadmin a dbcreator fixed server role:\nSELECT member.name ,\nroles.name\nFROM sys.server_role_members srm\nINNER JOIN sys.server_principals member ON srm.member_principal_id =\nmember.principal_id\nINNER JOIN sys.server_principals roles ON srm.role_principal_id =\nroles.principal_id\nWHERE roles.name IN ( N'sysadmin', N'dbcreator' )"
        }
      ],
      "id": "hvz1ZCk7",
      "createdAt": 1712516885274,
      "updatedAt": 1712520694763
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- SELECT @@VERSION",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "SELECT @@VERSION"
        }
      ],
      "id": "OSTVhU8c",
      "createdAt": 1712516950276,
      "updatedAt": 1712520667441
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- výpis co public role může spouštět",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Příkaz vrátí result set s procedurami, které může public role spouštět\nSELECT o.name AS [name] ,\npermission_name\nFROM sys.database_permissions r\nLEFT JOIN sys.database_Principals u ON r.grantee_principal_id = u.principal_id\nLEFT JOIN sys.all_objects o ON o.object_id = r.major_id\nWHERE o.name IN ( 'xp_regaddmultistring', 'xp_regdeletekey',\n'xp_regdeletevalue', 'xp_regenumvalues', 'xp_regenumkeys',\n'xp_regread', 'xp_regremovemultistring', 'xp_regwrite',\n'xp_instance_regaddmultistring',\n'xp_instance_regdeletekey', 'xp_instance_regdeletekey',\n'xp_instance_regenumkeys', 'xp_instance_regenumvalues',\n'xp_instance_regread', 'xp_instance_regremovemultistring',\n'xp_instance_regwrite', 'sp_runwebtask' )\nAND USER_NAME(r.grantee_principal_id) = 'public'"
        }
      ],
      "id": "oCxwumd0",
      "createdAt": 1712516969538,
      "updatedAt": 1712520662907
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Skript pro výpis SQL login",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Skript pro výpis SQL loginů a aplikování politiky pro komplexnost hesel:\nSELECT name ,\nis_policy_checked\nFROM sys.sql_logins"
        }
      ],
      "id": "gkOMN98O",
      "createdAt": 1712517103534,
      "updatedAt": 1712520690464
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Kontrola vlastníků databází:",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Kontrola vlastníků databází:\nSELECT d.name ,\nsp.name\nFROM sys.databases d\nINNER JOIN sys.server_principals sp ON d.owner_sid = sp.sid"
        }
      ],
      "id": "GknquFz0",
      "createdAt": 1712517143375,
      "updatedAt": 1712520671100
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Kontrola sysadmin a dbcreator fixed server role:",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Kontrola sysadmin a dbcreator fixed server role:\nSELECT member.name ,\nroles.name\nFROM sys.server_role_members srm\nINNER JOIN sys.server_principals member ON srm.member_principal_id =\nmember.principal_id\nINNER JOIN sys.server_principals roles ON srm.role_principal_id =\nroles.principal_id\nWHERE roles.name IN ( N'sysadmin', N'dbcreator' )"
        }
      ],
      "id": "p65orWlD",
      "createdAt": 1712517189046,
      "updatedAt": 1712520687603
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Server Configurations Options",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Server Configurations Options\nSELECT value_in_use ,\nname ,\n[description]\nFROM sys.configurations\nWHERE name = N'remote admin connections'\nOR name = N'Database Mail XPs'\nOR name = N'Ad Hoc Distributed Queries'\nOR name = N'cross db ownership chaining'\nOR name = N'scan for startup procs'\nOR name = N'remote access'\nOR name = N'xp_cmdshell'"
        }
      ],
      "id": "TusZrfrp",
      "createdAt": 1712517264288,
      "updatedAt": 1712520684893
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- remote admin connections",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "-- remote admin connections\nEXEC sp_configure 'remote admin connections', 1;\nGO\nRECONFIGURE;\nGO"
        }
      ],
      "id": "9yNg1XBz",
      "createdAt": 1712517405910,
      "updatedAt": 1712517673493
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Oprávnění pro obnovu, připojení a odpojení databáze",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "USE myDatabase\nSELECT member.name ,\nroles.name\nFROM sys.database_role_members drm\nINNER JOIN sys.database_principals member ON drm.member_principal_id =\nmember.principal_id\nINNER JOIN sys.database_principals roles ON drm.role_principal_id =\nroles.principal_id\nWHERE roles.name = N'db_owner'"
        }
      ],
      "id": "WIxz0d_W",
      "createdAt": 1712517557926,
      "updatedAt": 1712520682949
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Kontrola přiřazení do fixed server role:",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Kontrola přiřazení do fixed server role:\nSELECT member.name ,\nroles.name\nFROM sys.server_role_members srm\nINNER JOIN sys.server_principals member ON srm.member_principal_id =\nmember.principal_id\nINNER JOIN sys.server_principals roles ON srm.role_principal_id =\nroles.principal_id\nWHERE member.name LIKE '%\\Guest'"
        }
      ],
      "id": "AO0iJPqM",
      "createdAt": 1712517603467,
      "updatedAt": 1712520681166
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Kontrola přiřazení guest uživatele do databázové role:",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Kontrola přiřazení guest uživatele do databázové role:\nSELECT member.name ,\nroles.name\nFROM sys.database_role_members drm\nINNER JOIN sys.database_principals member ON drm.member_principal_id =\nmember.principal_id\nINNER JOIN sys.database_principals roles ON drm.role_principal_id =\nroles.principal_id\nWHERE member.name = N'guest'"
        }
      ],
      "id": "s4y3MnHT",
      "createdAt": 1712517738468,
      "updatedAt": 1712520673472
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Skript pro výpis proxy pro CmdExec a Active Scripting",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "--Skript pro výpis proxy pro CmdExec a Active Scripting\nSELECT sp.name ,\nss.subsystem\nFROM [msdb].[dbo].[syssubsystems] ss\nINNER JOIN msdb.dbo.sysproxysubsystem sps ON sps.subsystem_id =\nss.subsystem_id\nINNER JOIN msdb.dbo.sysproxies sp ON sp.proxy_id = sps.proxy_id\nWHERE ss.subsystem IN ( 'ActiveScripting', 'CmdExec' )"
        }
      ],
      "id": "M9nOijiY",
      "createdAt": 1712517802796,
      "updatedAt": 1712520675762
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Kontrola na testovací a demo databáze:",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "-- Kontrola na testovací a demo databáze:\nSELECT name\nFROM sys.databases\nWHERE name LIKE N'%AdventureWorks%'\nOR name LIKE N'%Contoso%'\nOR name LIKE N'%Northwind%'"
        }
      ],
      "id": "VzjEwpIT",
      "createdAt": 1712517868282,
      "updatedAt": 1712517871537
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3a0scZOU",
      "tagsIds": [],
      "description": null,
      "name": "-- Nastavení minimal a maximal memory:",
      "content": [
        {
          "label": "Fragment 1",
          "language": "mysql",
          "value": "-- Nastavení minimal a maximal memory:\nEXEC sys.sp_configure N'show advanced options', N'1' RECONFIGURE WITH OVERRIDE\nGO\nEXEC sys.sp_configure N'min server memory (MB)', N'2048'\nEXEC sys.sp_configure N'max server memory (MB)', N'6144'\nGO\nRECONFIGURE WITH OVERRIDE\nGO\nEXEC sys.sp_configure N'show advanced options', N'0' RECONFIGURE WITH OVERRIDE"
        }
      ],
      "id": "YzrZRYhD",
      "createdAt": 1712517887380,
      "updatedAt": 1712517898844
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Duration - trvání operace",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "auto zacatek = chrono::high_resolution_clock::now();\nfunkce(mandelbrotova_mnozina);\nauto konec = chrono::high_resolution_clock::now();\nchrono::duration<double, std::milli> trvani = chrono::duration_cast<chrono::milliseconds>(konec - zacatek);\ncout << \"Funkce trvala \" << trvani.count() << \" milisekund\" << endl;"
        }
      ],
      "id": "B5pRSeim",
      "createdAt": 1712685319421,
      "updatedAt": 1712685377355
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "cmake C++ version",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vala",
          "value": "# Set C++ version\n\tset_target_properties(${PROJECT_NAME} PROPERTIES\n\tCXX_STANDARD 17\n\tCXX_STANDARD_REQUIRED ON\n)"
        }
      ],
      "id": "i5EEXqkj",
      "createdAt": 1712826416094,
      "updatedAt": 1714727741045
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Lambda funkce",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "int x = 5;\nauto lambda = [&]() {\n    cout << \"Value of x captured by reference: \" << x << endl;\n    x++; // Modifikace proměnné x v okolním kontextu\n};\n\nlambda(); // Volání lambda funkce\n\n[&] (Capture by Reference):\nSymbol [&] označuje, že lambda funkce chce mít přístup k proměnným z okolí (tzv. \"capture\") pomocí odkazů (referencí). To znamená, že lambda funkce bude mít možnost číst a modifikovat (pokud není const) proměnné z vnějšího kontextu, které jsou zachyceny pomocí [&], aniž by se do kopírovaly do lambda funkce.\n\nNapříklad, pokud vaše lambda funkce pingPongFn byla definována v určité funkci nebo kontextu, a pokud se používá [&], může tato lambda funkce přistupovat k proměnným z této funkce nebo kontextu prostřednictvím odkazů, aniž by potřebovala kopírovat tyto proměnné do lambda funkce.\n\nPokud bychom místo toho použili [] (prázdné závorky) nebo [=], to by znamenalo jiný způsob zachycení proměnných:\n\n    []: Prázdné závorky znamenají, že lambda funkce nemá žádný přístup k proměnným z okolí.\n    [=]: Capture by value znamená, že lambda funkce může přistupovat k proměnným z okolí, ale pouze k jejich hodnotám, a tyto hodnoty jsou zkopírovány do lambda funkce.\n    \n    #include <iostream>\n\nint main() {\n    int x = 10;\n    int y = 20;\n\n    // Lambda funkce zachycená pomocí [=]\n    auto lambda = [=]() {\n        std::cout << \"Value of x (captured by value): \" << x << std::endl;\n        std::cout << \"Value of y (captured by value): \" << y << std::endl;\n        // x++; // Nelze změnit, protože x je zachyceno jako hodnota\n    };\n\n    // Zavolání lambda funkce\n    lambda();\n\n    return 0;\n}\n\nV tomto příkladu máme main() funkci, ve které jsou definovány proměnné x a y. Poté je vytvořena lambda funkce lambda s capture mode [=], což znamená, že lambda funkce zachycuje proměnné x a y kopírováním jejich hodnot.\n\nUvnitř lambda funkce lambda můžeme číst hodnoty proměnných x a y, ale nelze je změnit, protože jsou zachyceny jako kopie (hodnoty) a ne jako odkazy. Pokud bychom se pokusili odkomentovat řádek x++;, dostali bychom chybu kompilace, protože x je read-only (jen pro čtení) v lambda funkci, která je zachycena pomocí [=]."
        }
      ],
      "id": "aIlTg_SY",
      "createdAt": 1712922786239,
      "updatedAt": 1712922942388
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "cmake library and library caller (lib.a or [ lib.dll.a, lib.dll ])",
      "content": [
        {
          "label": "Fragment 1",
          "language": "gherkin",
          "value": "#######################################################################\n### Lib\ncmake_minimum_required(VERSION 3.5.0)\nproject(Lib VERSION 0.1.0 LANGUAGES C CXX)\n\ninclude(CTest)\nenable_testing()\n#lib.a\n#add_library(Lib Lib.cpp)\n#lib.dll\nadd_library(Lib SHARED Lib.cpp)\n\nset(CPACK_PROJECT_NAME ${PROJECT_NAME})\nset(CPACK_PROJECT_VERSION ${PROJECT_VERSION})\ninclude(CPack)\n#######################################################################\n### Caller\ncmake_minimum_required(VERSION 3.5.0)\nproject(Caller VERSION 0.1.0 LANGUAGES C CXX)\n\ninclude(CTest)\nenable_testing()\n\nadd_executable(Caller main.cpp)\n\ntarget_include_directories(Caller PUBLIC\n    ${PROJECT_SOURCE_DIR}/\n    ${PROJECT_SOURCE_DIR}/../lib/\n)\n\ntarget_link_libraries(Caller PUBLIC\n#for gcc type library\n#   ${PROJECT_SOURCE_DIR}/../lib/build/libLib.a\n#for windows type library\n    ${PROJECT_SOURCE_DIR}/../lib/build/libLib.dll.a \n)\n\nset(CPACK_PROJECT_NAME ${PROJECT_NAME})\nset(CPACK_PROJECT_VERSION ${PROJECT_VERSION})\ninclude(CPack)\n"
        }
      ],
      "id": "LvHUkmwF",
      "createdAt": 1712999736883,
      "updatedAt": 1714727798731
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "C++ library and library caller (lib.a or [ lib.dll.a, lib.dll ])",
      "content": [
        {
          "label": "Fragment 1",
          "language": "json",
          "value": ""
        }
      ],
      "id": "lSLqKYvF",
      "createdAt": 1713000077719,
      "updatedAt": 1713000200565
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "cmake static libstdc++ libgcc",
      "content": [
        {
          "label": "Fragment 1",
          "language": "makefile",
          "value": "# Přidání přepínače pro statické propojení libstdc++ a libgcc\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -static-libstdc++\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -static-libgcc\")\n"
        }
      ],
      "id": "TGMaheiV",
      "createdAt": 1713039854059,
      "updatedAt": 1713039889688
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "cmake wxWidget minimal",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "knihovny jsou zde a jsou i v path:\nc:\\Projects\\_Dep\\wx\\latest\\wxWidgets\\build-x86_64-msw_cmake\\lib\\gcc_x64_dll\\\n\n// c_cpp_properties.json\n{\n    \"configurations\": [\n        {\n            \"name\": \"Win32\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\",\n                \"c:/Projects/_Dep/wx/latest/wxWidgets/include/\",\n                \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake/lib/gcc_x64_dll/\",\n                \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake/lib/gcc_x64_dll/mswu/\"\n            ],\n            \"defines\": [\n                \"_DEBUG\",\n                \"UNICODE\",\n                \"_UNICODE\"\n            ],\n            \"windowsSdkVersion\": \"10.0.22621.0\",\n            \"cStandard\": \"c11\",\n            \"cppStandard\": \"c++11\",\n            \"intelliSenseMode\": \"gcc-x64\",\n            \"configurationProvider\": \"ms-vscode.cmake-tools\",\n            \"compilerPath\": \"C:/tools/msys64/ucrt64/bin/g++.exe\"\n        }\n    ],\n    \"version\": 4\n}\n\n// cmake settings\ncmake_minimum_required(VERSION 3.5.0)\nproject(MyWxMinimalTemplate VERSION 0.1.0 LANGUAGES C CXX)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# list fo source files \nset(SRC_FILES \n    minimal.cpp\n)\n\nif(WIN32)\n    # Include a RC file for windows\n    list(APPEND SRC_FILES sample.rc)\nelseif(APPLE)\n    # Add an icon for the apple .app file\n    list(APPEND SRC_FILES ../../src/osx/carbon/wxmac.icns)\nendif()\n\nadd_executable(${PROJECT_NAME} WIN32 MACOSX_BUNDLE ${SRC_FILES})\n\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n\"c:/Projects/_Dep/wx/latest/wxWidgets/include/\"\n\n#    utf-16 strings\n    \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake/lib/gcc_x64_dll/\" \n#    \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake/lib/gcc_x64_dll/mswu/\" #release\n     \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake/lib/gcc_x64_dll/mswud/\" #debug\n\n#    utf-8 strings\n#    \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake_utf8/lib/gcc_x64_dll/\"\n#    \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake_utf8/lib/gcc_x64_dll/mswu/\" #release\n#    \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake_utf8/lib/gcc_x64_dll/mswud/\" #debug\n)\n\ntarget_link_libraries(${PROJECT_NAME} PUBLIC\n#    utf-16 strings\n#    \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake/lib/gcc_x64_dll/libwxmsw33u.a\" #release\n     \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake/lib/gcc_x64_dll/libwxmsw33ud.a\" #debug\n#    unicode utf-8 strings\n#    \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake_utf8/lib/gcc_x64_dll/libwxmsw33u.a\" #release\n#    \"c:/Projects/_Dep/wx/latest/wxWidgets/build-x86_64-msw_cmake_utf8/lib/gcc_x64_dll/libwxmsw33ud.a\" #debug\n\n)\n\nset(CPACK_PROJECT_NAME ${PROJECT_NAME})\nset(CPACK_PROJECT_VERSION ${PROJECT_VERSION})\ninclude(CPack)\n\n// minimal.cpp \n/////////////////////////////////////////////////////////////////////////////\n// Name:        minimal.cpp\n// Purpose:     Minimal wxWidgets sample\n// Author:      Julian Smart\n// Modified by:\n// Created:     04/01/98\n// Copyright:   (c) Julian Smart\n// Licence:     wxWindows licence\n/////////////////////////////////////////////////////////////////////////////\n\n// ============================================================================\n// declarations\n// ============================================================================\n\n// ----------------------------------------------------------------------------\n// headers\n// ----------------------------------------------------------------------------\n\n\n\n// For compilers that support precompilation, includes \"wx/wx.h\".\n#include \"wx/wxprec.h\"\n\n\n\n// for all others, include the necessary headers (this file is usually all you\n// need because it includes almost all \"standard\" wxWidgets headers)\n#ifndef WX_PRECOMP\n    #include \"wx/wx.h\"\n#endif\n\n// ----------------------------------------------------------------------------\n// resources\n// ----------------------------------------------------------------------------\n\n// the application icon (under Windows it is in resources and even\n// though we could still include the XPM here it would be unused)\n#ifndef wxHAS_IMAGES_IN_RESOURCES\n    #include \"../sample.xpm\"\n#endif\n\n// ----------------------------------------------------------------------------\n// private classes\n// ----------------------------------------------------------------------------\n\n// Define a new application type, each program should derive a class from wxApp\nclass MyApp : public wxApp\n{\npublic:\n    // override base class virtuals\n    // ----------------------------\n\n    // this one is called on application startup and is a good place for the app\n    // initialization (doing it here and not in the ctor allows to have an error\n    // return: if OnInit() returns false, the application terminates)\n    virtual bool OnInit() override;\n};\n\n// Define a new frame type: this is going to be our main frame\nclass MyFrame : public wxFrame\n{\npublic:\n    // ctor(s)\n    MyFrame(const wxString& title);\n\n    // event handlers (these functions should _not_ be virtual)\n    void OnQuit(wxCommandEvent& event);\n    void OnAbout(wxCommandEvent& event);\n\nprivate:\n    // any class wishing to process wxWidgets events must use this macro\n    wxDECLARE_EVENT_TABLE();\n};\n\n// ----------------------------------------------------------------------------\n// constants\n// ----------------------------------------------------------------------------\n\n// IDs for the controls and the menu commands\nenum\n{\n    // menu items\n    Minimal_Quit = wxID_EXIT,\n\n    // it is important for the id corresponding to the \"About\" command to have\n    // this standard value as otherwise it won't be handled properly under Mac\n    // (where it is special and put into the \"Apple\" menu)\n    Minimal_About = wxID_ABOUT\n};\n\n// ----------------------------------------------------------------------------\n// event tables and other macros for wxWidgets\n// ----------------------------------------------------------------------------\n\n// the event tables connect the wxWidgets events with the functions (event\n// handlers) which process them. It can be also done at run-time, but for the\n// simple menu events like this the static method is much simpler.\nwxBEGIN_EVENT_TABLE(MyFrame, wxFrame)\n    EVT_MENU(Minimal_Quit,  MyFrame::OnQuit)\n    EVT_MENU(Minimal_About, MyFrame::OnAbout)\nwxEND_EVENT_TABLE()\n\n// Create a new application object: this macro will allow wxWidgets to create\n// the application object during program execution (it's better than using a\n// static object for many reasons) and also implements the accessor function\n// wxGetApp() which will return the reference of the right type (i.e. MyApp and\n// not wxApp)\nwxIMPLEMENT_APP(MyApp);\n\n// ============================================================================\n// implementation\n// ============================================================================\n\n// ----------------------------------------------------------------------------\n// the application class\n// ----------------------------------------------------------------------------\n\n// 'Main program' equivalent: the program execution \"starts\" here\nbool MyApp::OnInit()\n{\n    wxSetEnv(\"WX_UNICODE\", \"1\"); // Zapnutí Unicode\n\n    // call the base class initialization method, currently it only parses a\n    // few common command-line options but it could be do more in the future\n    if ( !wxApp::OnInit() )\n        return false;\n\n    // create the main application window\n    MyFrame *frame = new MyFrame(\"Minimal wxWidgets App\");\n\n    // and show it (the frames, unlike simple controls, are not shown when\n    // created initially)\n    frame->Show(true);\n\n    // success: wxApp::OnRun() will be called which will enter the main message\n    // loop and the application will run. If we returned false here, the\n    // application would exit immediately.\n    return true;\n}\n\n// ----------------------------------------------------------------------------\n// main frame\n// ----------------------------------------------------------------------------\n\n// frame constructor\nMyFrame::MyFrame(const wxString& title)\n       : wxFrame(nullptr, wxID_ANY, title)\n{\n    // set the frame icon\n    SetIcon(wxICON(sample));\n    Centre(wxCENTER_ON_SCREEN);\n\n#if wxUSE_MENUBAR\n    // create a menu bar\n    wxMenu *fileMenu = new wxMenu;\n\n    // the \"About\" item should be in the help menu\n    wxMenu *helpMenu = new wxMenu;\n    helpMenu->Append(Minimal_About, \"&About\\tF1\", \"Show about dialog\");\n\n    fileMenu->Append(Minimal_Quit, \"E&xit\\tAlt-X\", \"Quit this program\");\n\n    // now append the freshly created menu to the menu bar...\n    wxMenuBar *menuBar = new wxMenuBar();\n    menuBar->Append(fileMenu, \"&File\");\n    menuBar->Append(helpMenu, \"&Help\");\n\n    // ... and attach this menu bar to the frame\n    SetMenuBar(menuBar);\n#else // !wxUSE_MENUBAR\n    // If menus are not available add a button to access the about box\n    wxSizer* sizer = new wxBoxSizer(wxHORIZONTAL);\n    wxButton* aboutBtn = new wxButton(this, wxID_ANY, \"About...\");\n    aboutBtn->Bind(wxEVT_BUTTON, &MyFrame::OnAbout, this);\n    sizer->Add(aboutBtn, wxSizerFlags().Center());\n    SetSizer(sizer);\n#endif // wxUSE_MENUBAR/!wxUSE_MENUBAR\n\n#if wxUSE_STATUSBAR\n    // create a status bar just for fun (by default with 1 pane only)\n    CreateStatusBar(2);\n    SetStatusText(\"Welcome to wxWidgets Tomas!\");\n#endif // wxUSE_STATUSBAR\n}\n\n\n// event handlers\n\nvoid MyFrame::OnQuit(wxCommandEvent& WXUNUSED(event))\n{\n    // true is to force the frame to close\n    Close(true);\n}\n\nvoid MyFrame::OnAbout(wxCommandEvent& WXUNUSED(event))\n{\n    wxMessageBox(wxString::Format\n                 (\n                    \"Welcome to %s!\\n\"\n                    \"\\n\"\n                    \"This is the minimal wxWidgets sample\\n\"\n                    \"running under %s.\",\n                    wxVERSION_STRING,\n                    wxGetOsDescription()\n                 ),\n                 \"About wxWidgets minimal sample\",\n                 wxOK | wxICON_INFORMATION,\n                 this);\n}\n"
        }
      ],
      "id": "KhbL1bnC",
      "createdAt": 1713040150758,
      "updatedAt": 1713045222227
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "new exception",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "\n// newexcp.cpp -- výjimka bad_alloc\n#include <iostream>\n#include <new>\n#include <cstdlib>\nusing namespace std;\nstruct Big\n{\n    double stuff[20000];\n};\nint main()\n{\n    Big *pb;\n    try\n    {\n        cout << \"Zkousim pozadat o velky blok pameti:\\n\";\n        pb = new Big[10000000000]; // 1,600,000,000 bytes\n        cout << \"Ted jsem za prikazem new:\\n\";\n    }\n    catch (bad_alloc &ba)\n    {\n        cout << \"Zachycena vyjimka!\\n\";\n        cout << ba.what() << endl;\n        exit(EXIT_FAILURE);\n    }\n    if (pb != 0)\n    {\n        pb[0].stuff[0] = 4;\n        cout << pb[0].stuff[0] << endl;\n    }\n    else\n        cout << \"pb je nulovy ukazatel\\n\";\n    delete[] pb;\n    return 0;\n}"
        }
      ],
      "id": "ZyIVSfAv",
      "createdAt": 1713178387476,
      "updatedAt": 1713178393333
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "exc - error2",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "// error2.cpp -- návrat chybového kódu\n#include <iostream>\n#include <cfloat> // (nebo float.h) pro DBL_MAX\nbool hmean(double a, double b, double *ans);\nint main()\n{\n    double x, y, z;\n    std::cout << \" Zadejte dve cisla: \";\n    while (std::cin >> x >> y)\n    {\n        if (hmean(x, y, &z))\n            std::cout << \"Harmonicky prumer cisel \" << x << \" a \" << y\n                      << \" je \" << z << std::endl;\n        else\n            std::cout << \" Jedna hodnota nesmi byt \"\n                      << \"opakem druhe - opakujte.\\n\";\n        std::cout << \"Zadejte dalsi mnozinu cisel <k pro ukonceni>: \";\n    }\n    std::cout << \"Nashledanou!\\n\";\n    return 0;\n}\nbool hmean(double a, double b, double *ans)\n{\n    if (a == -b)\n    {\n        *ans = DBL_MAX;\n        return false;\n    }\n    else\n    {\n        *ans = 2.0 * a * b / (a + b);\n        return true;\n    }\n}"
        }
      ],
      "id": "FFzNItlN",
      "createdAt": 1713178444068,
      "updatedAt": 1713178504809
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "exc - error3",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "// error3.cpp -- využití výjimky\n#include <iostream>\ndouble hmean(double a, double b);\nint main()\n{\n    double x, y, z;\n    std::cout << \" Zadejte dve cisla: \";\n    while (std::cin >> x >> y)\n    {\n        try\n        { // začátek pokusného bloku\n            z = hmean(x, y);\n        }                     // konec pokusného bloku\n        catch (int i) // začátek handleru výjimky\n        {\n            std::cout << i << std::endl;\n            std::cout << \"Zadejte novou dvojici cisel: \";\n            continue;\n        } // konec handleru\n        catch (const char *s) // začátek handleru výjimky\n        {\n            std::cout << s << std::endl;\n            std::cout << \"Zadejte novou dvojici cisel: \";\n            continue;\n        } // konec handleru\n        std::cout << \"Harmonicky prumer cisel \" << x << \" a \" << y\n                  << \" je \" << z << std::endl;\n        std::cout << \"Zadejte dalsi mnozinu cisel <k pro ukonceni>: \";\n    }\n    std::cout << \"Nashledanou!\\n\";\n    return 0;\n}\ndouble hmean(double a, double b)\n{\n    if (a == -b)\n        throw \"Neplatne parametry ve funkci hmean(): a = -b neni povoleno\";\n    return 2.0 * a * b / (a + b);\n}"
        }
      ],
      "id": "atoxX0xN",
      "createdAt": 1713178455279,
      "updatedAt": 1713178507433
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "exc - error4",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "// error4.cpp -- použitítřídy výjimek\n#include <iostream>\n#include <cmath> // nebo math.h, v Unixu možná –lm\n#include \"exc_mean.hpp\"\n\n// function prototypes\ndouble hmean(double a, double b); // throw(bad_hmean) removed since c++17;\ndouble gmean(double a, double b); // throw(bad_gmean) removed since c++17;\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    double x, y, z;\n    cout << \"Zadejte dve cisla: \";\n    while (cin >> x >> y)\n    {\n        try\n        { // začátek bloku try\n            z = hmean(x, y);\n            cout << \"Harmonicky prumer cisel \" << x << \" a \" << y\n                 << \" je \" << z << endl;\n            cout << \"Geometricky prumer cisel \" << x << \" a \" << y\n                 << \" je \" << gmean(x, y) << endl;\n            cout << \"Zadejte dalsi mnozinu cisel <k pro ukonceni>: \";\n        } // konec bloku try\n        catch (bad_hmean &bg)\n        { // začátek záchytného bloku            bg.mesg();\n            cout << \"Opakujte.\\n\";\n            continue;\n        } // konec záchytného bloku\n        catch (bad_gmean &hg)\n        { // začátek záchytného bloku\n            cout << hg.mesg();\n            cout << \"Použité hodnoty: \" << hg.v1 << \", \"\n                 << hg.v2 << endl;\n            cout << \"Bohuzel, dal se nedostanete. \";\n            break;\n        } // konec záchytného bloku\n    }\n    cout << \"Nashledanou!\\n\";\n    return 0;\n}\n\ndouble hmean(double a, double b) // throw(bad_hmean) removed since c++17\n{\n    if (a == -b)\n        throw bad_hmean(a, b);\n    return 2.0 * a * b / (a + b);\n}\n\ndouble gmean(double a, double b) // throw(bad_gmean) removed since c++17\n{\n    if (a < 0 || b < 0)\n        throw bad_gmean(a, b);\n    return std::sqrt(a * b);\n}"
        }
      ],
      "id": "Cymi9Fr1",
      "createdAt": 1713178461938,
      "updatedAt": 1713178509780
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "exc - error5",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "// error5.cpp -- vracení zásobníku\n#include <iostream>\n#include <cmath> // nebo math.h, uzivatele unixu mozna priznak -lm\n#include <cstring>\n#include \"exc_mean.hpp\"\nclass demo\n{\nprivate:\n    char word[40];\n\npublic:\n    demo(const char *str)\n    {\n        std::strcpy(word, str);\n        std::cout << \"demo \" << word << \" vytvoren\\n\";\n    }\n    ~demo()\n    {\n        std::cout << \"demo \" << word << \" zrusen\\n\";\n    }\n    void show() const\n    {\n        std::cout << \"demo \" << word << \" zije!\\n\";\n    }\n};\n// prototypy funkcí\ndouble hmean(double a, double b); // throw(bad_hmean);\ndouble gmean(double a, double b); // throw(bad_gmean);\ndouble means(double a, double b); // (bad_hmean, bad_gmean);\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    double x, y, z;\n    demo d1(\"Nalezeno v main()\");\n    cout << \"Zadejte dve cisla: \";\n    while (cin >> x >> y)\n    {\n        try\n        { // start of try block\n            z = means(x, y);\n            cout << \"Prumer prumeru \" << x << \" a \" << y\n                 << \" je \" << z << endl;\n            cout << \"Zadejte dalsi dvojici: \";\n        }                     // konec bloku try\n        catch (bad_hmean &bg) // zacatek bloku catch\n        {\n            bg.mesg();\n            cout << bg.what() << endl;\n            cout << \"Opakujte.\\n\";\n            continue;\n        }\n        catch (bad_gmean &hg)\n        {\n            cout << hg.mesg() << endl;\n            cout << hg.what();\n            cout << \"Pouzite hodnoty: \" << hg.v1 << \", \"\n                 << hg.v2 << endl;\n            cout << \"Lituji, hra skoncila.\\n\";\n            break;\n        } // konec bloku catch\n    }\n    d1.show();\n    cout << \"Nashledanou!\\n\";\n    return 0;\n}\n\ndouble hmean(double a, double b) //throw(bad_hmean)\n{\n    if (a == -b)\n        throw bad_hmean(a, b);\n    return 2.0 * a * b / (a + b);\n}\n\ndouble gmean(double a, double b) //throw(bad_gmean)\n{\n    if (a < 0 || b < 0)\n        throw bad_gmean(a, b);\n    return std::sqrt(a * b);\n}\n\ndouble means(double a, double b) //throw(bad_hmean, bad_gmean)\n{\n    double am, hm, gm;\n    demo d2(\"Nalezeno v means()\");\n    am = (a + b) / 2.0; // aritmeticky prumer\n    try\n    {\n        hm = hmean(a, b);\n        gm = gmean(a, b);\n    }\n    // chybi zde handle pro bad_gmean, ale i \n    // pri teto vyjimce se vrati zpet a handler v main zafunguje\n    catch (bad_hmean &bg) // zacatek bloku catch\n    {   \n        bg.mesg();\n        bg.what();\n        std::cout << \"Zachyceno v means()\\n\";\n        throw; // znovuvyvolani vyjimky a vraceni se do main\n    }\n    d2.show();\n    return (am + hm + gm) / 3.0;\n}"
        }
      ],
      "id": "fDx5jYRT",
      "createdAt": 1713178481261,
      "updatedAt": 1713178511759
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "exc - exc_mean.h",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "// exc_mean.h -- třídy výjimek pro hmean(), gmean()\n\n#include <iostream>\n\nclass bad_hmean : public std::exception\n{\n    double v1;\n    double v2;\n\npublic:\n    bad_hmean(double a = 0, double b = 0) : v1(a), v2(b) {}\n    const char *what() { return \"chybné argumenty v hmean()\"; }\n    void mesg();\n};\n\ninline void bad_hmean::mesg()\n{\n    std::cout << \"hmean(\" << v1 << \", \" << v2 << \"): \"\n              << \"chybne argumenty: a = -b\\n\";\n}\n\nclass bad_gmean : public std::exception\n{\npublic:\n    double v1;\n    double v2;\n    bad_gmean(double a = 0, double b = 0) : v1(a), v2(b) {}\n    const char *what() { return \"chybné argumenty v gmean()\"; }\n    const char *mesg();\n};\n\ninline const char *bad_gmean::mesg()\n{\n    return \"argumenty gmean() musi byt >= 0\\n\";\n}"
        }
      ],
      "id": "IlcK120n",
      "createdAt": 1713178521383,
      "updatedAt": 1713178531619
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": "used in MyWebServer Template",
      "name": "cmake cross Win32 Linux template ***",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vala",
          "value": "cmake_minimum_required(VERSION 3.5.0)\nproject(StartProject VERSION 0.1.0 LANGUAGES C CXX)\n\ninclude(CTest)\nenable_testing()\n\nif(UNIX AND NOT APPLE)\n    set(LINUX TRUE)\nendif()\n\nset(SRC_FILES\n    ${PROJECT_SOURCE_DIR}/src/App.cpp\n    ${PROJECT_SOURCE_DIR}/src/AppComponent.hpp\n    ${PROJECT_SOURCE_DIR}/dto/DTOs.hpp\n    ${PROJECT_SOURCE_DIR}/controller/MyController.hpp\n    \n)\n\nadd_executable(StartProject ${SRC_FILES})\n\nif(WIN32)\n    target_include_directories(StartProject PUBLIC\n        ${PROJECT_SOURCE_DIR}/\n        \"c:/tools/msys64/ucrt64/include/oatpp-1.3.0/oatpp/\"\n    )\n    target_link_libraries(StartProject PUBLIC\n\n        \"c:/tools/msys64/ucrt64/lib/oatpp-1.3.0/liboatpp.a\"\n        \"c:/tools/msys64/ucrt64/lib/oatpp-1.3.0/liboatpp-test.a\"\n        ws2_32\n    )\nendif(WIN32)\n\nif(LINUX)\n    target_include_directories(StartProject PUBLIC\n        ${PROJECT_SOURCE_DIR}/\n        \"/usr/local/include/oatpp-1.3.0/oatpp/\"\n    )\n    target_link_libraries(StartProject PUBLIC\n        \"/usr/local/lib/oatpp-1.3.0/liboatpp.a\"\n        \"/usr/local/lib/oatpp-1.3.0/liboatpp-test.a\"\n    )\nendif(LINUX)\n\nset(CPACK_PROJECT_NAME ${PROJECT_NAME})\nset(CPACK_PROJECT_VERSION ${PROJECT_VERSION})\ninclude(CPack)\n"
        }
      ],
      "id": "nL8cLd6W",
      "createdAt": 1714722043111,
      "updatedAt": 1714728472878
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "cmake cpp cheatsheet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vala",
          "value": "\ncmake\nMinimal CMakeLists.txt\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nproject(example)\nadd_executable(a.out a.cpp b.cpp)\n\nWildcard Sourse Files\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nfile(GLOB src \"*.cpp\")\n\nproject(example)\nadd_executable(a.out ${src})\n\nSet CXXFLAGS\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nfile(GLOB src \"*.cc\")\n\nproject(example)\nset(CMAKE_CXX_FLAGS \"-Wall -Werror -O3\")\nadd_executable(a.out ${src})\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nfile(GLOB src \"*.cc\")\n\nproject(example)\nadd_executable(a.out ${src})\ntarget_compile_options(a.out PRIVATE -Werror)\n\nSet CXXFLAGS with Build Type\n\n# common\nset(CMAKE_CXX_FLAGS \"-Wall -Werror -O3\")\n# debug\nset(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS} -g\")\n# release\nset(CMAKE_C_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS} -O3 -pedantic\")\n\nBuild Debug/Release\n\n$ cmake -DCMAKE_BUILD_TYPE=Release ../\n$ cmake -DCMAKE_BUILD_TYPE=Debug ../\n\nBuild with Type\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nproject(example)\nadd_executable(a.out a.cc)\n\nif(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n  target_compile_options(a.out PRIVATE -g -O0 -Wall)\nelse()\n  target_compile_options(a.out PRIVATE -O3 -Wall -Werror)\nendif()\n\nInstead of checking CMAKE_BUILD_TYPE, modern CMake prefers to use generator expressions to examine conditions.\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nproject(example)\nadd_executable(a.out a.cc)\ntarget_compile_options(a.out PRIVATE\n  $<IF:$<CONFIG:Debug>, -g -O0 -Wall, -O3 -Wall -Werror>\n)\n\nVersion File\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nfile(GLOB src \"*.cpp\")\n\nproject(example VERSION 1.0)\nconfigure_file(version.h.in version.h)\n\nadd_executable(a.out ${src})\ntarget_include_directories(a.out PUBLIC \"${PROJECT_BINARY_DIR}\")\n\nversion.h.in\n\n#pragma once\n\n#define VERSION_MAJOR @example_VERSION_MAJOR@\n#define VERSION_MINOR @example_VERSION_MINOR@\n\nBuild/Link a static library\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nfile(GLOB src \"*.cpp\")\n\nproject(example VERSION 1.0)\nconfigure_file(version.h.in version.h)\n\nadd_executable(a.out ${src})\nadd_library(b b.cpp)\ntarget_link_libraries(a.out PUBLIC b)\ntarget_include_directories(a.out PUBLIC \"${PROJECT_BINARY_DIR}\")\n\nBuild/Link a shared library\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nfile(GLOB src \"*.cpp\")\n\nproject(example VERSION 1.0)\nconfigure_file(version.h.in version.h)\n\nadd_executable(a.out ${src})\nadd_library(b SHARED b.cpp)\ntarget_link_libraries(a.out PUBLIC b)\ntarget_include_directories(a.out PUBLIC \"${PROJECT_BINARY_DIR}\")\n\nSubdirectory\n\nsubdirectory fib/\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nfile(GLOB src \"*.cpp\")\nadd_library(b SHARED b.cpp)\ntarget_include_directories(b PUBLIC \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\nproject dir\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nfile(GLOB src \"*.cpp\")\n\nproject(example VERSION 1.0)\nconfigure_file(version.h.in version.h)\n\nadd_executable(a.out ${src})\nadd_subdirectory(fib)\ntarget_link_libraries(a.out PUBLIC b)\ntarget_include_directories(a.out PUBLIC\n    \"${PROJECT_BINARY_DIR}\"\n    \"${PROJECT_BINARY_DIR/fib}\"\n)\n\nPUBLIC & PRIVATE\n\n    PUBLIC - only affect the current target, not dependencies\n\n    INTERFACE - only needed for dependencies\n\ncmake_minimum_required(VERSION 3.10)\n\nproject(example)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nfind_package(Boost)\n\nadd_executable(a.out a.cpp)\nadd_library(b STATIC b.cpp b.h)\n\ntarget_include_directories(a.out PRIVATE \"${CMAKE_CURRENT_SOURCE_DIR}\")\ntarget_include_directories(b PRIVATE \"${Boost_INCLUDE_DIR}\")\ntarget_link_libraries(a.out INTERFACE b) # link b failed\n\nGenerator Expression\n\ncmake_minimum_required(VERSION 3.10)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\nproject(example)\n\nset(target fib)\nadd_library(${target} src/fib.cc)\ntarget_compile_options(${target} PRIVATE -Wall -Werror -Wextra)\ntarget_include_directories(${target}\n  PUBLIC\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n    $<INSTALL_INTERFACE:include>\n  PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/src\n)\n\nInstall\n\ncmake_minimum_required(VERSION 3.10)\nproject(a)\nadd_library(b_static STATIC b.cc)\nadd_library(b_shared SHARED b.cc)\nadd_executable(a a.cc b.cc)\n\ninclude(GNUInstallDirs)\nset(INSTALL_TARGETS a b_static b_shared)\ninstall(TARGETS ${INSTALL_TARGETS}\n  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n)\ninstall(FILES b.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\nRun a command at configure time\n\nexecute_process(\n    COMMAND git submodule update --init --recursive\n    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n    RESULT_VARIABLE GIT_SUBMOD_RESULT\n)\n\nOption\n\n# $ make -p build\n# $ cd build\n# $ cmake -DBUILD_TEST=ON ../\n\noption(BUILD_TEST \"Build test\" OFF)\nif (BUILD_TEST)\n    message(\"Build tests.\")\nelse()\n    message(\"Ignore tests.\")\nendif()\n\nAlias a Library\n\nWhen a CMakeLists.txt export Foo in namespace Foo::, it also need to create an alias Foo::Foo.\n\nadd_library(Foo::Foo ALIAS Foo)\n\n"
        }
      ],
      "id": "PCXxO2x1",
      "createdAt": 1714727927012,
      "updatedAt": 1714727945723
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "Check Int Type",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <type_traits>\ntemplate <typename T>\nint checkParam(T param)\n{\n    if (std::is_same<T, short unsigned int>::value)\n    {\n        std::cout << \"Druhý parametr je typu short unsigned int.\" << std::endl;\n        return 0;\n    }\n    else\n    {\n        std::cout << \"Druhý parametr není typu short unsigned int.\" << std::endl;\n        return 1;\n    }\n}\n"
        }
      ],
      "id": "JocYNKaz",
      "createdAt": 1714746277107,
      "updatedAt": 1714746283615
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "h_XqOL4T",
      "tagsIds": [],
      "description": null,
      "name": "extractCurrentAppPath",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "    extractCurrentAppPath(char *appPath[]) const\n    {\n        std::string exePathString = static_cast<std::string>(appPath[0]);\n        size_t index = exePathString.find_last_of(\"\\\\/\") + 1;\n        return exePathString.substr(0, index);\n    }"
        }
      ],
      "id": "VLUDpbZ1",
      "createdAt": 1714749056439,
      "updatedAt": 1714749064069
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": null,
      "name": "cmake SDL2 ttf mixer",
      "content": [
        {
          "label": "Fragment 1",
          "language": "makefile",
          "value": "cmake_minimum_required(VERSION 3.5.0)\nproject(Twini-Golf VERSION 0.1.0 LANGUAGES C CXX)\n\ninclude(CTest)\nenable_testing()\n\nset(SRC_FILES \n    ${PROJECT_SOURCE_DIR}/src/main.cpp\n    ${PROJECT_SOURCE_DIR}/src/ball.cpp\n    ${PROJECT_SOURCE_DIR}/src/entity.cpp\n    ${PROJECT_SOURCE_DIR}/src/hole.cpp\n    ${PROJECT_SOURCE_DIR}/src/renderwindow.cpp\n    ${PROJECT_SOURCE_DIR}/src/tile.cpp\n    ${PROJECT_SOURCE_DIR}/res/gfx\n    ${PROJECT_SOURCE_DIR}/res/sfx\n    ${PROJECT_SOURCE_DIR}/res/font\n)\n\n# Použijte přepínač WIN32 pro skrytí konzolového okna\nadd_executable(${PROJECT_NAME} ${SRC_FILES})\n\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${PROJECT_SOURCE_DIR}/\n    ${PROJECT_SOURCE_DIR}/src/\n    ${PROJECT_SOURCE_DIR}/font\n    ${PROJECT_SOURCE_DIR}/gfx\n    ${PROJECT_SOURCE_DIR}/sfx\n)\n\ntarget_link_libraries(${PROJECT_NAME} PUBLIC\n    gdi32\n    dwmapi\n    opengl32\n    shell32\n    curl\n    SDL2\n    SDL2main\n    SDL2_mixer\n    SDL2_ttf\n    SDL2_image\n)\n\n\nset(CPACK_PROJECT_NAME ${PROJECT_NAME})\nset(CPACK_PROJECT_VERSION ${PROJECT_VERSION})\ninclude(CPack)\n"
        }
      ],
      "id": "tN5Cxx5I",
      "createdAt": 1715284837064,
      "updatedAt": 1715286944702
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "Nepojmenovaný snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": ""
        }
      ],
      "id": "_n3DWfxN",
      "createdAt": 1715363867322,
      "updatedAt": 1716404066434
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "u6rnxgPx",
      "tagsIds": [],
      "description": "zavolání ctest -V ukáže obsah výstupu do konzole testovacího subjektu",
      "name": "cmake oat++ app + ctest",
      "content": [
        {
          "label": "Fragment 1",
          "language": "makefile",
          "value": "cmake_minimum_required(VERSION 3.5.0)\nproject(MyWebServer VERSION 0.1.0 LANGUAGES C CXX)\n\nset(TEST MyWebServerTest)\n\ninclude(CTest)\nenable_testing()\n\nif(UNIX AND NOT APPLE)\n    set(LINUX TRUE)\nendif()\n\nset(COMMON_HEADER_FILES\n    ${PROJECT_SOURCE_DIR}/dto/DTOs.hpp\n    ${PROJECT_SOURCE_DIR}/controller/MyController.hpp\n    ${PROJECT_SOURCE_DIR}/src/AppComponent.hpp\n    ${PROJECT_SOURCE_DIR}/test/app/TestComponent.hpp\n    ${PROJECT_SOURCE_DIR}/test/app/MyApiTestClient.hpp\n    ${PROJECT_SOURCE_DIR}/test/MyControllerTest.hpp\n)\n\nset(COMMON_SOURCE_FILES\n    ${PROJECT_SOURCE_DIR}/test/MyControllerTest.cpp\n)\n\nfunction(configure_target TARGET_NAME)\n    if(LINUX)\n        target_include_directories(${TARGET_NAME} PUBLIC\n            ${PROJECT_SOURCE_DIR}/\n            \"/usr/local/include/oatpp-1.3.0/oatpp/\"\n        )\n        target_link_libraries(${TARGET_NAME} PUBLIC\n            \"/usr/local/lib/oatpp-1.3.0/liboatpp.a\"\n            \"/usr/local/lib/oatpp-1.3.0/liboatpp-test.a\"\n        )\n    endif(LINUX)\n\n    if(WIN32)\n        target_include_directories(${TARGET_NAME} PUBLIC\n            ${PROJECT_SOURCE_DIR}/\n            \"c:/tools/msys64/ucrt64/include/oatpp-1.3.0/oatpp/\"\n        )\n        target_link_libraries(${TARGET_NAME} PUBLIC\n            \"c:/tools/msys64/ucrt64/lib/oatpp-1.3.0/liboatpp.a\"\n            \"c:/tools/msys64/ucrt64/lib/oatpp-1.3.0/liboatpp-test.a\"\n            ws2_32\n        )\n    endif(WIN32)\nendfunction(configure_target)\n\nadd_executable(${PROJECT_NAME} ${COMMON_HEADER_FILES} ${PROJECT_SOURCE_DIR}/src/App.cpp ${COMMON_SOURCE_FILES})\nconfigure_target(${PROJECT_NAME})\n\nadd_executable(${TEST} ${COMMON_HEADER_FILES} ${PROJECT_SOURCE_DIR}/test/Tests.cpp ${COMMON_SOURCE_FILES})\nconfigure_target(${TEST})\n\n# ctest -V for verbose output\nadd_test(NAME ${TEST} COMMAND ${TEST})\n\nset(CPACK_PROJECT_NAME ${PROJECT_NAME})\nset(CPACK_PROJECT_VERSION ${PROJECT_VERSION})\ninclude(CPack)\n"
        }
      ],
      "id": "K8xiF6GA",
      "createdAt": 1715363871985,
      "updatedAt": 1715885431380
    }
  ],
  "tags": []
}